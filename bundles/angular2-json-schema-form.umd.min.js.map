{
  "version": 3,
  "file": "angular2-json-schema-form.umd.min.js",
  "sources": [
    "ng://angular2-json-schema-form/src/lib/src/shared/validator.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/utility.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/jsonpointer.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/format-regex.constants.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/json.validators.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/merge-schemas.function.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/json-schema.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/convert-schema-to-draft6.function.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/form-group.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/layout.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/date.functions.ts",
    "ng://angular2-json-schema-form/src/lib/src/locale/en-validation-messages.ts",
    "ng://angular2-json-schema-form/src/lib/src/locale/fr-validation-messages.ts",
    "ng://angular2-json-schema-form/src/lib/src/json-schema-form.service.ts",
    "ng://angular2-json-schema-form/src/lib/src/shared/orderable.directive.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/add-reference.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/one-of.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/button.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/checkbox.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/checkboxes.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/file.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/input.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/message.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/none.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/number.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/radios.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/root.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/section.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/select.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/select-framework.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/select-widget.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/submit.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/tabs.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/template.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/textarea.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/widget-library.service.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/framework.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/framework-library.service.ts",
    "ng://angular2-json-schema-form/src/lib/src/json-schema-form.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/hidden.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/tab.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/index.ts",
    "ng://angular2-json-schema-form/src/lib/src/widget-library/widget-library.module.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/no-framework/no-framework.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/no-framework/no.framework.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/no-framework/no-framework.module.ts",
    "ng://angular2-json-schema-form/src/lib/src/json-schema-form.module.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/flex-layout-root.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/flex-layout-section.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-add-reference.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-one-of.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-button.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-button-group.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-checkbox.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-checkboxes.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-chip-list.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-datepicker.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-file.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-input.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-number.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-radios.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-select.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-slider.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-stepper.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-tabs.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-textarea.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-design-framework.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-design.framework.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/index.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/material-design-framework/material-design-framework.module.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/bootstrap-3-framework/bootstrap-3-framework.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/bootstrap-3-framework/bootstrap-3.framework.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/bootstrap-3-framework/bootstrap-3-framework.module.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/bootstrap-4-framework/bootstrap-4-framework.component.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/bootstrap-4-framework/bootstrap-4.framework.ts",
    "ng://angular2-json-schema-form/src/lib/src/framework-library/bootstrap-4-framework/bootstrap-4-framework.module.ts"
  ],
  "sourcesContent": [
    "import { AbstractControl, ValidationErrors } from '@angular/forms';\nimport { Observable } from 'rxjs-compat/Observable';\nimport { fromPromise } from 'rxjs-compat/observable/fromPromise';\nimport { toPromise } from 'rxjs-compat/operator/toPromise';\n\n/**\n * Validator utility function library:\n *\n * Validator and error utilities:\n *   _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors\n *\n * Individual value checking:\n *   isDefined, hasValue, isEmpty\n *\n * Individual type checking:\n *   isString, isNumber, isInteger, isBoolean, isFunction, isObject, isArray,\n *   isMap, isSet, isPromise, isObservable\n *\n * Multiple type checking and fixing:\n *   getType, isType, isPrimitive, toJavaScriptType, toSchemaType,\n *   _toPromise, toObservable\n *\n * Utility functions:\n *   inArray, xor\n *\n * Typescript types and interfaces:\n *   SchemaPrimitiveType, SchemaType, JavaScriptPrimitiveType, JavaScriptType,\n *   PrimitiveValue, PlainObject, IValidatorFn, AsyncIValidatorFn\n *\n * Note: 'IValidatorFn' is short for 'invertable validator function',\n *   which is a validator functions that accepts an optional second\n *   argument which, if set to TRUE, causes the validator to perform\n *   the opposite of its original function.\n */\n\nexport type SchemaPrimitiveType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null';\nexport type SchemaType =\n  'string' | 'number' | 'integer' | 'boolean' | 'null' | 'object' | 'array';\nexport type JavaScriptPrimitiveType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined';\nexport type JavaScriptType =\n  'string' | 'number' | 'boolean' | 'null' | 'undefined' | 'object' | 'array' |\n  'map' | 'set' | 'arguments' | 'date' | 'error' | 'function' | 'json' |\n  'math' | 'regexp'; // Note: this list is incomplete\nexport type PrimitiveValue = string | number | boolean | null | undefined;\nexport interface PlainObject { [k: string]: any; }\n\nexport type IValidatorFn = (c: AbstractControl, i?: boolean) => PlainObject;\nexport type AsyncIValidatorFn = (c: AbstractControl, i?: boolean) => any;\n\n/**\n * '_executeValidators' utility function\n *\n * Validates a control against an array of validators, and returns\n * an array of the same length containing a combination of error messages\n * (from invalid validators) and null values (from valid validators)\n *\n * @param  { AbstractControl } control - control to validate\n * @param  { IValidatorFn[] } validators - array of validators\n * @param  { boolean } invert - invert?\n * @return { PlainObject[] } - array of nulls and error message\n */\nexport function _executeValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_executeAsyncValidators' utility function\n *\n * Validates a control against an array of async validators, and returns\n * an array of observabe results of the same length containing a combination of\n * error messages (from invalid validators) and null values (from valid ones)\n *\n * @param  { AbstractControl } control - control to validate\n * @param  { AsyncIValidatorFn[] } validators - array of async validators\n * @param  { boolean } invert - invert?\n * @return { any[] } - array of observable nulls and error message\n */\nexport function _executeAsyncValidators(control, validators, invert = false) {\n  return validators.map(validator => validator(control, invert));\n}\n\n/**\n * '_mergeObjects' utility function\n *\n * Recursively Merges one or more objects into a single object with combined keys.\n * Automatically detects and ignores null and undefined inputs.\n * Also detects duplicated boolean 'not' keys and XORs their values.\n *\n * @param  { PlainObject[] } objects - one or more objects to merge\n * @return { PlainObject } - merged object\n */\nexport function _mergeObjects(...objects) {\n  const mergedObject: PlainObject = { };\n  for (const currentObject of objects) {\n    if (isObject(currentObject)) {\n      for (const key of Object.keys(currentObject)) {\n        const currentValue = currentObject[key];\n        const mergedValue = mergedObject[key];\n        mergedObject[key] = !isDefined(mergedValue) ? currentValue :\n          key === 'not' && isBoolean(mergedValue, 'strict') &&\n            isBoolean(currentValue, 'strict') ? xor(mergedValue, currentValue) :\n          getType(mergedValue) === 'object' && getType(currentValue) === 'object' ?\n            _mergeObjects(mergedValue, currentValue) :\n            currentValue;\n      }\n    }\n  }\n  return mergedObject;\n}\n\n/**\n * '_mergeErrors' utility function\n *\n * Merges an array of objects.\n * Used for combining the validator errors returned from 'executeValidators'\n *\n * @param  { PlainObject[] } arrayOfErrors - array of objects\n * @return { PlainObject } - merged object, or null if no usable input objectcs\n */\nexport function _mergeErrors(arrayOfErrors) {\n  const mergedErrors = _mergeObjects(...arrayOfErrors);\n  return isEmpty(mergedErrors) ? null : mergedErrors;\n}\n\n/**\n * 'isDefined' utility function\n *\n * Checks if a variable contains a value of any type.\n * Returns true even for otherwise 'falsey' values of 0, '', and false.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined or null, otherwise true\n */\nexport function isDefined(value) {\n  return value !== undefined && value !== null;\n}\n\n/**\n * 'hasValue' utility function\n *\n * Checks if a variable contains a value.\n * Returs false for null, undefined, or a zero-length strng, '',\n * otherwise returns true.\n * (Stricter than 'isDefined' because it also returns false for '',\n * though it stil returns true for otherwise 'falsey' values 0 and false.)\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function hasValue(value) {\n  return value !== undefined && value !== null && value !== '';\n}\n\n/**\n * 'isEmpty' utility function\n *\n * Similar to !hasValue, but also returns true for empty arrays and objects.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - false if undefined, null, or '', otherwise true\n */\nexport function isEmpty(value) {\n  if (isArray(value)) { return !value.length; }\n  if (isObject(value)) { return !Object.keys(value).length; }\n  return value === undefined || value === null || value === '';\n}\n\n/**\n * 'isString' utility function\n *\n * Checks if a value is a string.\n *\n * @param  { any } value - the value to check\n * @return { boolean } - true if string, false if not\n */\nexport function isString(value) {\n  return typeof value === 'string';\n}\n\n/**\n * 'isNumber' utility function\n *\n * Checks if a value is a regular number, numeric string, or JavaScript Date.\n *\n * @param  { any } value - the value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return { boolean } - true if number, false if not\n */\nexport function isNumber(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) && value !== value / 0;\n}\n\n/**\n * 'isInteger' utility function\n *\n * Checks if a value is an integer.\n *\n * @param  { any } value - the value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return {boolean } - true if number, false if not\n */\nexport function isInteger(value, strict: any = false) {\n  if (strict && typeof value !== 'number') { return false; }\n  return !isNaN(value) &&  value !== value / 0 && value % 1 === 0;\n}\n\n/**\n * 'isBoolean' utility function\n *\n * Checks if a value is a boolean.\n *\n * @param  { any } value - the value to check\n * @param  { any = null } option - if 'strict', also checks JavaScript type\n *                              if TRUE or FALSE, checks only for that value\n * @return { boolean } - true if boolean, false if not\n */\nexport function isBoolean(value, option: any = null) {\n  if (option === 'strict') { return value === true || value === false; }\n  if (option === true) {\n    return value === true || value === 1 || value === 'true' || value === '1';\n  }\n  if (option === false) {\n    return value === false || value === 0 || value === 'false' || value === '0';\n  }\n  return value === true || value === 1 || value === 'true' || value === '1' ||\n    value === false || value === 0 || value === 'false' || value === '0';\n}\n\nexport function isFunction(item: any): boolean {\n  return typeof item === 'function';\n}\n\nexport function isObject(item: any): boolean {\n  return item !== null && typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Object]';\n}\n\nexport function isArray(item: any): boolean {\n  return Array.isArray(item) ||\n    Object.prototype.toString.call(item) === '[object Array]';\n}\n\nexport function isDate(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Date]';\n}\n\nexport function isMap(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Map]';\n}\n\nexport function isSet(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Set]';\n}\n\nexport function isSymbol(item: any): boolean {\n  return typeof item === 'symbol';\n}\n\n/**\n * 'getType' function\n *\n * Detects the JSON Schema Type of a value.\n * By default, detects numbers and integers even if formatted as strings.\n * (So all integers are also numbers, and any number may also be a string.)\n * However, it only detects true boolean values (to detect boolean values\n * in non-boolean formats, use isBoolean() instead).\n *\n * If passed a second optional parameter of 'strict', it will only detect\n * numbers and integers if they are formatted as JavaScript numbers.\n *\n * Examples:\n * getType('10.5') = 'number'\n * getType(10.5) = 'number'\n * getType('10') = 'integer'\n * getType(10) = 'integer'\n * getType('true') = 'string'\n * getType(true) = 'boolean'\n * getType(null) = 'null'\n * getType({ }) = 'object'\n * getType([]) = 'array'\n *\n * getType('10.5', 'strict') = 'string'\n * getType(10.5, 'strict') = 'number'\n * getType('10', 'strict') = 'string'\n * getType(10, 'strict') = 'integer'\n * getType('true', 'strict') = 'string'\n * getType(true, 'strict') = 'boolean'\n *\n * @param  { any } value - value to check\n * @param  { any = false } strict - if truthy, also checks JavaScript tyoe\n * @return { SchemaType }\n */\nexport function getType(value, strict: any = false) {\n  if (!isDefined(value)) { return 'null'; }\n  if (isArray(value)) { return 'array'; }\n  if (isObject(value)) { return 'object'; }\n  if (isBoolean(value, 'strict')) { return 'boolean'; }\n  if (isInteger(value, strict)) { return 'integer'; }\n  if (isNumber(value, strict)) { return 'number'; }\n  if (isString(value) || (!strict && isDate(value))) { return 'string'; }\n  return null;\n}\n\n/**\n * 'isType' function\n *\n * Checks wether an input (probably string) value contains data of\n * a specified JSON Schema type\n *\n * @param  { PrimitiveValue } value - value to check\n * @param  { SchemaPrimitiveType } type - type to check\n * @return { boolean }\n */\nexport function isType(value, type) {\n  switch (type) {\n    case 'string':\n      return isString(value) || isDate(value);\n    case 'number':\n      return isNumber(value);\n    case 'integer':\n      return isInteger(value);\n    case 'boolean':\n      return isBoolean(value);\n    case 'null':\n      return !hasValue(value);\n    default:\n      console.error(`isType error: \"${type}\" is not a recognized type.`);\n      return null;\n  }\n}\n\n/**\n * 'isPrimitive' function\n *\n * Checks wether an input value is a JavaScript primitive type:\n * string, number, boolean, or null.\n *\n * @param  { any } value - value to check\n * @return { boolean }\n */\nexport function isPrimitive(value) {\n  return (isString(value) || isNumber(value) ||\n    isBoolean(value, 'strict') || value === null);\n}\n\n/**\n * 'toJavaScriptType' function\n *\n * Converts an input (probably string) value to a JavaScript primitive type -\n * 'string', 'number', 'boolean', or 'null' - before storing in a JSON object.\n *\n * Does not coerce values (other than null), and only converts the types\n * of values that would otherwise be valid.\n *\n * If the optional third parameter 'strictIntegers' is TRUE, and the\n * JSON Schema type 'integer' is specified, it also verifies the input value\n * is an integer and, if it is, returns it as a JaveScript number.\n * If 'strictIntegers' is FALSE (or not set) the type 'integer' is treated\n * exactly the same as 'number', and allows decimals.\n *\n * Valid Examples:\n * toJavaScriptType('10',   'number' ) = 10   // '10'   is a number\n * toJavaScriptType('10',   'integer') = 10   // '10'   is also an integer\n * toJavaScriptType( 10,    'integer') = 10   //  10    is still an integer\n * toJavaScriptType( 10,    'string' ) = '10' //  10    can be made into a string\n * toJavaScriptType('10.5', 'number' ) = 10.5 // '10.5' is a number\n *\n * Invalid Examples:\n * toJavaScriptType('10.5', 'integer') = null // '10.5' is not an integer\n * toJavaScriptType( 10.5,  'integer') = null //  10.5  is still not an integer\n *\n * @param  { PrimitiveValue } value - value to convert\n * @param  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - types to convert to\n * @param  { boolean = false } strictIntegers - if FALSE, treat integers as numbers\n * @return { PrimitiveValue }\n */\nexport function toJavaScriptType(value, types, strictIntegers = true)  {\n  if (!isDefined(value)) { return null; }\n  if (isString(types)) { types = [types]; }\n  if (strictIntegers && inArray('integer', types)) {\n    if (isInteger(value, 'strict')) { return value; }\n    if (isInteger(value)) { return parseInt(value, 10); }\n  }\n  if (inArray('number', types) || (!strictIntegers && inArray('integer', types))) {\n    if (isNumber(value, 'strict')) { return value; }\n    if (isNumber(value)) { return parseFloat(value); }\n  }\n  if (inArray('string', types)) {\n    if (isString(value)) { return value; }\n    // If value is a date, and types includes 'string',\n    // convert the date to a string\n    if (isDate(value)) { return value.toISOString().slice(0, 10); }\n    if (isNumber(value)) { return value.toString(); }\n  }\n  // If value is a date, and types includes 'integer' or 'number',\n  // but not 'string', convert the date to a number\n  if (isDate(value) && (inArray('integer', types) || inArray('number', types))) {\n    return value.getTime();\n  }\n  if (inArray('boolean', types)) {\n    if (isBoolean(value, true)) { return true; }\n    if (isBoolean(value, false)) { return false; }\n  }\n  return null;\n}\n\n/**\n * 'toSchemaType' function\n *\n * Converts an input (probably string) value to the \"best\" JavaScript\n * equivalent available from an allowed list of JSON Schema types, which may\n * contain 'string', 'number', 'integer', 'boolean', and/or 'null'.\n * If necssary, it does progressively agressive type coersion.\n * It will not return null unless null is in the list of allowed types.\n *\n * Number conversion examples:\n * toSchemaType('10', ['number','integer','string']) = 10 // integer\n * toSchemaType('10', ['number','string']) = 10 // number\n * toSchemaType('10', ['string']) = '10' // string\n * toSchemaType('10.5', ['number','integer','string']) = 10.5 // number\n * toSchemaType('10.5', ['integer','string']) = '10.5' // string\n * toSchemaType('10.5', ['integer']) = 10 // integer\n * toSchemaType(10.5, ['null','boolean','string']) = '10.5' // string\n * toSchemaType(10.5, ['null','boolean']) = true // boolean\n *\n * String conversion examples:\n * toSchemaType('1.5x', ['boolean','number','integer','string']) = '1.5x' // string\n * toSchemaType('1.5x', ['boolean','number','integer']) = '1.5' // number\n * toSchemaType('1.5x', ['boolean','integer']) = '1' // integer\n * toSchemaType('1.5x', ['boolean']) = true // boolean\n * toSchemaType('xyz', ['number','integer','boolean','null']) = true // boolean\n * toSchemaType('xyz', ['number','integer','null']) = null // null\n * toSchemaType('xyz', ['number','integer']) = 0 // number\n *\n * Boolean conversion examples:\n * toSchemaType('1', ['integer','number','string','boolean']) = 1 // integer\n * toSchemaType('1', ['number','string','boolean']) = 1 // number\n * toSchemaType('1', ['string','boolean']) = '1' // string\n * toSchemaType('1', ['boolean']) = true // boolean\n * toSchemaType('true', ['number','string','boolean']) = 'true' // string\n * toSchemaType('true', ['boolean']) = true // boolean\n * toSchemaType('true', ['number']) = 0 // number\n * toSchemaType(true, ['number','string','boolean']) = true // boolean\n * toSchemaType(true, ['number','string']) = 'true' // string\n * toSchemaType(true, ['number']) = 1 // number\n *\n * @param  { PrimitiveValue } value - value to convert\n * @param  { SchemaPrimitiveType | SchemaPrimitiveType[] } types - allowed types to convert to\n * @return { PrimitiveValue }\n */\nexport function toSchemaType(value, types) {\n  if (!isArray(<SchemaPrimitiveType>types)) {\n    types = <SchemaPrimitiveType[]>[types];\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('null') && !hasValue(value)) {\n    return null;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && !isBoolean(value, 'strict')) {\n    return value;\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) {\n    const testValue = toJavaScriptType(value, 'integer');\n    if (testValue !== null) { return +testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) {\n    const testValue = toJavaScriptType(value, 'number');\n    if (testValue !== null) { return +testValue; }\n  }\n  if (\n    (isString(value) || isNumber(value, 'strict')) &&\n    (<SchemaPrimitiveType[]>types).includes('string')\n  ) { // Convert number to string\n    return toJavaScriptType(value, 'string');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean') && isBoolean(value)) {\n    return toJavaScriptType(value, 'boolean');\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('string')) { // Convert null & boolean to string\n    if (value === null) { return ''; }\n    const testValue = toJavaScriptType(value, 'string');\n    if (testValue !== null) { return testValue; }\n  }\n  if ((\n    (<SchemaPrimitiveType[]>types).includes('number') ||\n    (<SchemaPrimitiveType[]>types).includes('integer'))\n  ) {\n    if (value === true) { return 1; } // Convert boolean & null to number\n    if (value === false || value === null || value === '') { return 0; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('number')) { // Convert mixed string to number\n    const testValue = parseFloat(<string>value);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('integer')) { // Convert string or number to integer\n    const testValue = parseInt(<string>value, 10);\n    if (!!testValue) { return testValue; }\n  }\n  if ((<SchemaPrimitiveType[]>types).includes('boolean')) { // Convert anything to boolean\n    return !!value;\n  }\n  if ((\n      (<SchemaPrimitiveType[]>types).includes('number') ||\n      (<SchemaPrimitiveType[]>types).includes('integer')\n    ) && !(<SchemaPrimitiveType[]>types).includes('null')\n  ) {\n    return 0; // If null not allowed, return 0 for non-convertable values\n  }\n}\n\n/**\n * 'isPromise' function\n *\n * @param  { any } object\n * @return { boolean }\n */\nexport function isPromise(object): object is Promise<any> {\n  return !!object && typeof object.then === 'function';\n}\n\n/**\n * 'isObservable' function\n *\n * @param  { any } object\n * @return { boolean }\n */\nexport function isObservable(object): object is Observable<any> {\n  return !!object && typeof object.subscribe === 'function';\n}\n\n/**\n * '_toPromise' function\n *\n * @param  { object } object\n * @return { Promise<any> }\n */\nexport function _toPromise(object): Promise<any> {\n  return isPromise(object) ? object : toPromise.call(object);\n}\n\n/**\n * 'toObservable' function\n *\n * @param  { object } object\n * @return { Observable<any> }\n */\nexport function toObservable(object): Observable<any> {\n  const observable = isPromise(object) ? fromPromise(object) : object;\n  if (isObservable(observable)) { return observable; }\n  console.error('toObservable error: Expected validator to return Promise or Observable.');\n  return new Observable();\n}\n\n/**\n * 'inArray' function\n *\n * Searches an array for an item, or one of a list of items, and returns true\n * as soon as a match is found, or false if no match.\n *\n * If the optional third parameter allIn is set to TRUE, and the item to find\n * is an array, then the function returns true only if all elements from item\n * are found in the array list, and false if any element is not found. If the\n * item to find is not an array, setting allIn to TRUE has no effect.\n *\n * @param  { any|any[] } item - the item to search for\n * @param  { any[] } array - the array to search\n * @param  { boolean = false } allIn - if TRUE, all items must be in array\n * @return { boolean } - true if item(s) in array, false otherwise\n */\nexport function inArray(item, array, allIn = false) {\n  if (!isDefined(item) || !isArray(array)) { return false; }\n  return isArray(item) ?\n    item[allIn ? 'every' : 'some'](subItem => array.includes(subItem)) :\n    array.includes(item);\n}\n\n/**\n * 'xor' utility function - exclusive or\n *\n * Returns true if exactly one of two values is truthy.\n *\n * @param  { any } value1 - first value to check\n * @param  { any } value2 - second value to check\n * @return { boolean } - true if exactly one input value is truthy, false if not\n */\nexport function xor(value1, value2) {\n  return (!!value1 && !value2) || (!value1 && !!value2);\n}\n",
    "import {\n  hasValue, inArray, isArray, isDefined, isObject, isEmpty, isMap, isSet,\n  isString, PlainObject\n} from './validator.functions';\n\n/**\n * Utility function library:\n *\n * addClasses, copy, forEach, forEachCopy, hasOwn, mergeFilteredObject,\n * uniqueItems, commonItems, fixTitle, toTitleCase\n*/\n\n/**\n * 'addClasses' function\n *\n * Merges two space-delimited lists of CSS classes and removes duplicates.\n *\n * @param {string | string[] | Set<string>} oldClasses\n * @param {string | string[] | Set<string>} newClasses\n * @return {string | string[] | Set<string>} - Combined classes\n */\nexport function addClasses(\n  oldClasses: string | string[] | Set<string>,\n  newClasses: string | string[] | Set<string>\n): string | string[] | Set<string> {\n  const badType = i => !isSet(i) && !isArray(i) && !isString(i);\n  if (badType(newClasses)) { return oldClasses; }\n  if (badType(oldClasses)) { oldClasses = ''; }\n  const toSet = i => isSet(i) ? i : isArray(i) ? new Set(i) : new Set(i.split(' '));\n  const combinedSet: Set<any> = toSet(oldClasses);\n  const newSet: Set<any> = toSet(newClasses);\n  newSet.forEach(c => combinedSet.add(c));\n  if (isSet(oldClasses)) { return combinedSet; }\n  if (isArray(oldClasses)) { return Array.from(combinedSet); }\n  return Array.from(combinedSet).join(' ');\n}\n\n/**\n * 'copy' function\n *\n * Makes a shallow copy of a JavaScript object, array, Map, or Set.\n * If passed a JavaScript primitive value (string, number, boolean, or null),\n * it returns the value.\n *\n * @param {Object|Array|string|number|boolean|null} object - The object to copy\n * @param {boolean = false} errors - Show errors?\n * @return {Object|Array|string|number|boolean|null} - The copied object\n */\nexport function copy(object: any, errors = false): any {\n  if (typeof object !== 'object' || object === null) { return object; }\n  if (isMap(object))    { return new Map(object); }\n  if (isSet(object))    { return new Set(object); }\n  if (isArray(object))  { return [ ...object ];   }\n  if (isObject(object)) { return { ...object };   }\n  if (errors) {\n    console.error('copy error: Object to copy must be a JavaScript object or value.');\n  }\n  return object;\n}\n\n/**\n * 'forEach' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator funciton on each item.\n *\n * The iterator function is called with four values:\n * 1. The current item's value\n * 2. The current item's key\n * 3. The parent object, which contains the current item\n * 4. The root object\n *\n * Setting the optional third parameter to 'top-down' or 'bottom-up' will cause\n * it to also recursively iterate over items in sub-objects or sub-arrays in the\n * specified direction.\n *\n * @param {Object|Array} object - The object or array to iterate over\n * @param {function} fn - the iterator funciton to call on each item\n * @param {boolean = false} errors - Show errors?\n * @return {void}\n */\nexport function forEach(\n  object: any, fn: (v: any, k?: string | number, c?: any, rc?: any) => any,\n  recurse: boolean | string = false, rootObject: any = object, errors = false\n): void {\n  if (isEmpty(object)) { return; }\n  if ((isObject(object) || isArray(object)) && typeof fn === 'function') {\n    for (const key of Object.keys(object)) {\n      const value = object[key];\n      if (recurse === 'bottom-up' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject);\n      }\n      fn(value, key, object, rootObject);\n      if (recurse === 'top-down' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject);\n      }\n    }\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEach error: Iterator must be a function.');\n      console.error('function', fn);\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEach error: Input object must be an object or array.');\n      console.error('object', object);\n    }\n  }\n}\n\n/**\n * 'forEachCopy' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator function on each item. Returns a new object or array\n * with the same keys or indexes as the original, and values set to the results\n * of the iterator function.\n *\n * Does NOT recursively iterate over items in sub-objects or sub-arrays.\n *\n * @param {Object | Array} object - The object or array to iterate over\n * @param {function} fn - The iterator funciton to call on each item\n * @param {boolean = false} errors - Show errors?\n * @return {Object | Array} - The resulting object or array\n */\nexport function forEachCopy(\n  object: any, fn: (v: any, k?: string | number, o?: any, p?: string) => any,\n  errors = false\n): any {\n  if (!hasValue(object)) { return; }\n  if ((isObject(object) || isArray(object)) && typeof object !== 'function') {\n    const newObject: any = isArray(object) ? [] : {};\n    for (const key of Object.keys(object)) {\n      newObject[key] = fn(object[key], key, object);\n    }\n    return newObject;\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEachCopy error: Iterator must be a function.');\n      console.error('function', fn);\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEachCopy error: Input object must be an object or array.');\n      console.error('object', object);\n    }\n  }\n}\n\n/**\n * 'hasOwn' utility function\n *\n * Checks whether an object or array has a particular property.\n *\n * @param {any} object - the object to check\n * @param {string} property - the property to look for\n * @return {boolean} - true if object has property, false if not\n */\nexport function hasOwn(object: any, property: string): boolean {\n  if (!object || !['number', 'string', 'symbol'].includes(typeof property) ||\n    (!isObject(object) && !isArray(object) && !isMap(object) && !isSet(object))\n  ) { return false; }\n  if (isMap(object) || isSet(object)) { return object.has(property); }\n  if (typeof property === 'number') {\n    if (isArray(object)) { return object[<number>property]; }\n    property = property + '';\n  }\n  return object.hasOwnProperty(property);\n}\n\n/**\n * 'mergeFilteredObject' utility function\n *\n * Shallowly merges two objects, setting key and values from source object\n * in target object, excluding specified keys.\n *\n * Optionally, it can also use functions to transform the key names and/or\n * the values of the merging object.\n *\n * @param {PlainObject} targetObject - Target object to add keys and values to\n * @param {PlainObject} sourceObject - Source object to copy keys and values from\n * @param {string[]} excludeKeys - Array of keys to exclude\n * @param {(string: string) => string = (k) => k} keyFn - Function to apply to keys\n * @param {(any: any) => any = (v) => v} valueFn - Function to apply to values\n * @return {PlainObject} - Returns targetObject\n */\nexport function mergeFilteredObject(\n  targetObject: PlainObject,\n  sourceObject: PlainObject,\n  excludeKeys = <string[]>[],\n  keyFn = (key: string): string => key,\n  valFn = (val: any): any => val\n): PlainObject {\n  if (!isObject(sourceObject)) { return targetObject; }\n  if (!isObject(targetObject)) { targetObject = {}; }\n  for (const key of Object.keys(sourceObject)) {\n    if (!inArray(key, excludeKeys) && isDefined(sourceObject[key])) {\n      targetObject[keyFn(key)] = valFn(sourceObject[key]);\n    }\n  }\n  return targetObject;\n}\n\n/**\n * 'uniqueItems' function\n *\n * Accepts any number of string value inputs,\n * and returns an array of all input vaues, excluding duplicates.\n *\n * @param {...string} ...items -\n * @return {string[]} -\n */\nexport function uniqueItems(...items): string[] {\n  const returnItems = [];\n  for (const item of items) {\n    if (!returnItems.includes(item)) { returnItems.push(item); }\n  }\n  return returnItems;\n}\n\n/**\n * 'commonItems' function\n *\n * Accepts any number of strings or arrays of string values,\n * and returns a single array containing only values present in all inputs.\n *\n * @param {...string|string[]} ...arrays -\n * @return {string[]} -\n */\nexport function commonItems(...arrays): string[] {\n  let returnItems = null;\n  for (let array of arrays) {\n    if (isString(array)) { array = [array]; }\n    returnItems = returnItems === null ? [ ...array ] :\n      returnItems.filter(item => array.includes(item));\n    if (!returnItems.length) { return []; }\n  }\n  return returnItems;\n}\n\n/**\n * 'fixTitle' function\n *\n *\n * @param {string} input -\n * @return {string} -\n */\nexport function fixTitle(name: string): string {\n  return name && toTitleCase(name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' '));\n}\n\n/**\n * 'toTitleCase' function\n *\n * Intelligently converts an input string to Title Case.\n *\n * Accepts an optional second parameter with a list of additional\n * words and abbreviations to force into a particular case.\n *\n * This function is built on prior work by John Gruber and David Gouch:\n * http://daringfireball.net/2008/08/title_case_update\n * https://github.com/gouch/to-title-case\n *\n * @param {string} input -\n * @param {string|string[]} forceWords? -\n * @return {string} -\n */\nexport function toTitleCase(input: string, forceWords?: string|string[]): string {\n  if (!isString(input)) { return input; }\n  let forceArray: string[] = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'en',\n   'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'per', 'the', 'to', 'v', 'v.',\n   'vs', 'vs.', 'via'];\n  if (isString(forceWords)) { forceWords = (<string>forceWords).split('|'); }\n  if (isArray(forceWords)) { forceArray = forceArray.concat(forceWords); }\n  const forceArrayLower: string[] = forceArray.map(w => w.toLowerCase());\n  const noInitialCase: boolean =\n    input === input.toUpperCase() || input === input.toLowerCase();\n  let prevLastChar = '';\n  input = input.trim();\n  return input.replace(/[A-Za-z0-9\\u00C0-\\u00FF]+[^\\s-]*/g, (word, idx) => {\n    if (!noInitialCase && word.slice(1).search(/[A-Z]|\\../) !== -1) {\n      return word;\n    } else {\n      let newWord: string;\n      const forceWord: string =\n        forceArray[forceArrayLower.indexOf(word.toLowerCase())];\n      if (!forceWord) {\n        if (noInitialCase) {\n          if (word.slice(1).search(/\\../) !== -1) {\n            newWord = word.toLowerCase();\n          } else {\n            newWord = word[0].toUpperCase() + word.slice(1).toLowerCase();\n          }\n        } else {\n          newWord = word[0].toUpperCase() + word.slice(1);\n        }\n      } else if (\n        forceWord === forceWord.toLowerCase() && (\n          idx === 0 || idx + word.length === input.length ||\n          prevLastChar === ':' || input[idx - 1].search(/[^\\s-]/) !== -1 ||\n          (input[idx - 1] !== '-' && input[idx + word.length] === '-')\n        )\n      ) {\n        newWord = forceWord[0].toUpperCase() + forceWord.slice(1);\n      } else {\n        newWord = forceWord;\n      }\n      prevLastChar = word.slice(-1);\n      return newWord;\n    }\n  });\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport {\n  isDefined, isEmpty, isObject, isArray, isMap, isNumber, isString\n} from './validator.functions';\nimport { hasOwn, copy } from './utility.functions';\n\n/**\n * 'JsonPointer' class\n *\n * Some utilities for using JSON Pointers with JSON objects\n * https://tools.ietf.org/html/rfc6901\n *\n * get, getCopy, getFirst, set, setCopy, insert, insertCopy, remove, has, dict,\n * forEachDeep, forEachDeepCopy, escape, unescape, parse, compile, toKey,\n * isJsonPointer, isSubPointer, toIndexedPointer, toGenericPointer,\n * toControlPointer, toSchemaPointer, toDataPointer, parseObjectPath\n *\n * Some functions based on manuelstofer's json-pointer utilities\n * https://github.com/manuelstofer/json-pointer\n */\nexport type Pointer = string | string[];\n\n@Injectable()\nexport class JsonPointer {\n\n  /**\n   * 'get' function\n   *\n   * Uses a JSON Pointer to retrieve a value from an object.\n   *\n   * @param  { object } object - Object to get value from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * @param  { number } endSlice - Zero-based index of last Pointer key to use\n   * @param  { boolean = false } getBoolean - Return only true or false?\n   * @param  { boolean = false } errors - Show error if not found?\n   * @return { object } - Located value (or true or false if getBoolean = true)\n   */\n  static get(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    if (object === null) { return getBoolean ? false : undefined; }\n    let keyArray: any[] = this.parse(pointer, errors);\n    if (typeof object === 'object' && keyArray !== null) {\n      let subObject = object;\n      if (startSlice >= keyArray.length || endSlice <= -keyArray.length) { return object; }\n      if (startSlice <= -keyArray.length) { startSlice = 0; }\n      if (!isDefined(endSlice) || endSlice >= keyArray.length) { endSlice = keyArray.length; }\n      keyArray = keyArray.slice(startSlice, endSlice);\n      for (let key of keyArray) {\n        if (key === '-' && isArray(subObject) && subObject.length) {\n          key = subObject.length - 1;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else if (typeof subObject === 'object' && subObject !== null &&\n          hasOwn(subObject, key)\n        ) {\n          subObject = subObject[key];\n        } else {\n          if (errors) {\n            console.error(`get error: \"${key}\" key not found in object.`);\n            console.error(pointer);\n            console.error(object);\n          }\n          return getBoolean ? false : undefined;\n        }\n      }\n      return getBoolean ? true : subObject;\n    }\n    if (errors && keyArray === null) {\n      console.error(`get error: Invalid JSON Pointer: ${pointer}`);\n    }\n    if (errors && typeof object !== 'object') {\n      console.error('get error: Invalid object:');\n      console.error(object);\n    }\n    return getBoolean ? false : undefined;\n  }\n\n  /**\n   * 'getCopy' function\n   *\n   * Uses a JSON Pointer to deeply clone a value from an object.\n   *\n   * @param  { object } object - Object to get value from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { number = 0 } startSlice - Zero-based index of first Pointer key to use\n   * @param  { number } endSlice - Zero-based index of last Pointer key to use\n   * @param  { boolean = false } getBoolean - Return only true or false?\n   * @param  { boolean = false } errors - Show error if not found?\n   * @return { object } - Located value (or true or false if getBoolean = true)\n   */\n  static getCopy(\n    object, pointer, startSlice = 0, endSlice: number = null,\n    getBoolean = false, errors = false\n  ) {\n    const objectToCopy =\n      this.get(object, pointer, startSlice, endSlice, getBoolean, errors);\n    return this.forEachDeepCopy(objectToCopy);\n  }\n\n  /**\n   * 'getFirst' function\n   *\n   * Takes an array of JSON Pointers and objects,\n   * checks each object for a value specified by the pointer,\n   * and returns the first value found.\n   *\n   * @param  { [object, pointer][] } items - Array of objects and pointers to check\n   * @param  { any = null } defaultValue - Value to return if nothing found\n   * @param  { boolean = false } getCopy - Return a copy instead?\n   * @return { any } - First value found\n   */\n  static getFirst(items, defaultValue: any = null, getCopy = false) {\n    if (isEmpty(items)) { return; }\n    if (isArray(items)) {\n      for (const item of items) {\n        if (isEmpty(item)) { continue; }\n        if (isArray(item) && item.length >= 2) {\n          if (isEmpty(item[0]) || isEmpty(item[1])) { continue; }\n          const value = getCopy ?\n            this.getCopy(item[0], item[1]) :\n            this.get(item[0], item[1]);\n          if (value) { return value; }\n          continue;\n        }\n        console.error('getFirst error: Input not in correct format.\\n' +\n          'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n        return;\n      }\n      return defaultValue;\n    }\n    if (isMap(items)) {\n      for (const [object, pointer] of items) {\n        if (object === null || !this.isJsonPointer(pointer)) { continue; }\n        const value = getCopy ?\n          this.getCopy(object, pointer) :\n          this.get(object, pointer);\n        if (value) { return value; }\n      }\n      return defaultValue;\n    }\n    console.error('getFirst error: Input not in correct format.\\n' +\n      'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]');\n    return defaultValue;\n  }\n\n  /**\n   * 'getFirstCopy' function\n   *\n   * Similar to getFirst, but always returns a copy.\n   *\n   * @param  { [object, pointer][] } items - Array of objects and pointers to check\n   * @param  { any = null } defaultValue - Value to return if nothing found\n   * @return { any } - Copy of first value found\n   */\n  static getFirstCopy(items, defaultValue: any = null) {\n    const firstCopy = this.getFirst(items, defaultValue, true);\n    return firstCopy;\n  }\n\n  /**\n   * 'set' function\n   *\n   * Uses a JSON Pointer to set a value on an object.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing\n   * value (if any) at that location.\n   *\n   * So set([1, 2, 3], '/1', 4) => [1, 4, 3]\n   * and\n   * So set([1, 2, 3], '/1', 4, true) => [1, 4, 2, 3]\n   *\n   * @param  { object } object - The object to set value in\n   * @param  { Pointer } pointer - The JSON Pointer (string or array)\n   * @param  { any } value - The new value to set\n   * @param  { boolean } insert - insert value?\n   * @return { object } - The original object, modified with the set value\n   */\n  static set(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let subObject = object;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return object;\n    }\n    console.error(`set error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'setCopy' function\n   *\n   * Copies an object and uses a JSON Pointer to set a value on the copy.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing value.\n   *\n   * @param  { object } object - The object to copy and set value in\n   * @param  { Pointer } pointer - The JSON Pointer (string or array)\n   * @param  { any } value - The value to set\n   * @param  { boolean } insert - insert value?\n   * @return { object } - The new object with the set value\n   */\n  static setCopy(object, pointer, value, insert = false) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null) {\n      const newObject = copy(object);\n      let subObject = newObject;\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i];\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length;\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject.set(key, copy(subObject.get(key)));\n          subObject = subObject.get(key);\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {};\n          }\n          subObject[key] = copy(subObject[key]);\n          subObject = subObject[key];\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1];\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value);\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value);\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value);\n      } else {\n        subObject[lastKey] = value;\n      }\n      return newObject;\n    }\n    console.error(`setCopy error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'insert' function\n   *\n   * Calls 'set' with insert = TRUE\n   *\n   * @param  { object } object - object to insert value in\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { any } value - value to insert\n   * @return { object }\n   */\n  static insert(object, pointer, value) {\n    const updatedObject = this.set(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'insertCopy' function\n   *\n   * Calls 'setCopy' with insert = TRUE\n   *\n   * @param  { object } object - object to insert value in\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { any } value - value to insert\n   * @return { object }\n   */\n  static insertCopy(object, pointer, value) {\n    const updatedObject = this.setCopy(object, pointer, value, true);\n    return updatedObject;\n  }\n\n  /**\n   * 'remove' function\n   *\n   * Uses a JSON Pointer to remove a key and its attribute from an object\n   *\n   * @param  { object } object - object to delete attribute from\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @return { object }\n   */\n  static remove(object, pointer) {\n    const keyArray = this.parse(pointer);\n    if (keyArray !== null && keyArray.length) {\n      let lastKey = keyArray.pop();\n      const parentObject = this.get(object, keyArray);\n      if (isArray(parentObject)) {\n        if (lastKey === '-') { lastKey = parentObject.length - 1; }\n        parentObject.splice(lastKey, 1);\n      } else if (isObject(parentObject)) {\n        delete parentObject[lastKey];\n      }\n      return object;\n    }\n    console.error(`remove error: Invalid JSON Pointer: ${pointer}`);\n    return object;\n  }\n\n  /**\n   * 'has' function\n   *\n   * Tests if an object has a value at the location specified by a JSON Pointer\n   *\n   * @param  { object } object - object to chek for value\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @return { boolean }\n   */\n  static has(object, pointer) {\n    const hasValue = this.get(object, pointer, 0, null, true);\n    return hasValue;\n  }\n\n  /**\n   * 'dict' function\n   *\n   * Returns a (pointer -> value) dictionary for an object\n   *\n   * @param  { object } object - The object to create a dictionary from\n   * @return { object } - The resulting dictionary object\n   */\n  static dict(object) {\n    const results: any = {};\n    this.forEachDeep(object, (value, pointer) => {\n      if (typeof value !== 'object') { results[pointer] = value; }\n    });\n    return results;\n  }\n\n  /**\n   * 'forEachDeep' function\n   *\n   * Iterates over own enumerable properties of an object or items in an array\n   * and invokes an iteratee function for each key/value or index/value pair.\n   * By default, iterates over items within objects and arrays after calling\n   * the iteratee function on the containing object or array itself.\n   *\n   * The iteratee is invoked with three arguments: (value, pointer, rootObject),\n   * where pointer is a JSON pointer indicating the location of the current\n   * value within the root object, and rootObject is the root object initially\n   * submitted to th function.\n   *\n   * If a third optional parameter 'bottomUp' is set to TRUE, the iterator\n   * function will be called on sub-objects and arrays after being\n   * called on their contents, rather than before, which is the default.\n   *\n   * This function can also optionally be called directly on a sub-object by\n   * including optional 4th and 5th parameterss to specify the initial\n   * root object and pointer.\n   *\n   * @param  { object } object - the initial object or array\n   * @param  { (v: any, p?: string, o?: any) => any } function - iteratee function\n   * @param  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * @param  { object = object } rootObject - optional, root object or array\n   * @param  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * @return { object } - The modified object\n   */\n  static forEachDeep(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeep error: Iterator is not a function:`, fn);\n      return;\n    }\n    if (!bottomUp) { fn(object, pointer, rootObject); }\n    if (isObject(object) || isArray(object)) {\n      for (const key of Object.keys(object)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        this.forEachDeep(object[key], fn, bottomUp, newPointer, rootObject);\n      }\n    }\n    if (bottomUp) { fn(object, pointer, rootObject); }\n  }\n\n  /**\n   * 'forEachDeepCopy' function\n   *\n   * Similar to forEachDeep, but returns a copy of the original object, with\n   * the same keys and indexes, but with values replaced with the result of\n   * the iteratee function.\n   *\n   * @param  { object } object - the initial object or array\n   * @param  { (v: any, k?: string, o?: any, p?: any) => any } function - iteratee function\n   * @param  { boolean = false } bottomUp - optional, set to TRUE to reverse direction\n   * @param  { object = object } rootObject - optional, root object or array\n   * @param  { string = '' } pointer - optional, JSON Pointer to object within rootObject\n   * @return { object } - The copied object\n   */\n  static forEachDeepCopy(\n    object, fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false, pointer = '', rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeepCopy error: Iterator is not a function:`, fn);\n      return null;\n    }\n    if (isObject(object) || isArray(object)) {\n      let newObject = isArray(object) ? [ ...object ] : { ...object };\n      if (!bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      for (const key of Object.keys(newObject)) {\n        const newPointer = pointer + '/' + this.escape(key);\n        newObject[key] = this.forEachDeepCopy(\n          newObject[key], fn, bottomUp, newPointer, rootObject\n        );\n      }\n      if (bottomUp) { newObject = fn(newObject, pointer, rootObject); }\n      return newObject;\n    } else {\n      return fn(object, pointer, rootObject);\n    }\n  }\n\n  /**\n   * 'escape' function\n   *\n   * Escapes a string reference key\n   *\n   * @param  { string } key - string key to escape\n   * @return { string } - escaped key\n   */\n  static escape(key) {\n    const escaped = key.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n    return escaped;\n  }\n\n  /**\n   * 'unescape' function\n   *\n   * Unescapes a string reference key\n   *\n   * @param  { string } key - string key to unescape\n   * @return { string } - unescaped key\n   */\n  static unescape(key) {\n    const unescaped = key.toString().replace(/~1/g, '/').replace(/~0/g, '~');\n    return unescaped;\n  }\n\n  /**\n   * 'parse' function\n   *\n   * Converts a string JSON Pointer into a array of keys\n   * (if input is already an an array of keys, it is returned unchanged)\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string[] } - JSON Pointer array of keys\n   */\n  static parse(pointer, errors = false) {\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`parse error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) { return <string[]>pointer; }\n    if (typeof pointer === 'string') {\n      if ((<string>pointer)[0] === '#') { pointer = pointer.slice(1); }\n      if (<string>pointer === '' || <string>pointer === '/') { return []; }\n      return (<string>pointer).slice(1).split('/').map(this.unescape);\n    }\n  }\n\n  /**\n   * 'compile' function\n   *\n   * Converts an array of keys into a JSON Pointer string\n   * (if input is already a string, it is normalized and returned)\n   *\n   * The optional second parameter is a default which will replace any empty keys.\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { string | number = '' } defaultValue - Default value\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string } - JSON Pointer string\n   */\n  static compile(pointer, defaultValue = '', errors = false) {\n    if (pointer === '#') { return ''; }\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) { console.error(`compile error: Invalid JSON Pointer: ${pointer}`); }\n      return null;\n    }\n    if (isArray(pointer)) {\n      if ((<string[]>pointer).length === 0) { return ''; }\n      return '/' + (<string[]>pointer).map(\n        key => key === '' ? defaultValue : this.escape(key)\n      ).join('/');\n    }\n    if (typeof pointer === 'string') {\n      if (pointer[0] === '#') { pointer = pointer.slice(1); }\n      return pointer;\n    }\n  }\n\n  /**\n   * 'toKey' function\n   *\n   * Extracts name of the final key from a JSON Pointer.\n   *\n   * @param  { Pointer } pointer - JSON Pointer (string or array)\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { string } - the extracted key\n   */\n  static toKey(pointer, errors = false) {\n    const keyArray = this.parse(pointer, errors);\n    if (keyArray === null) { return null; }\n    if (!keyArray.length) { return ''; }\n    return keyArray[keyArray.length - 1];\n  }\n\n  /**\n   * 'isJsonPointer' function\n   *\n   * Checks a string or array value to determine if it is a valid JSON Pointer.\n   * Returns true if a string is empty, or starts with '/' or '#/'.\n   * Returns true if an array contains only string values.\n   *\n   * @param  { any } value - value to check\n   * @return { boolean } - true if value is a valid JSON Pointer, otherwise false\n   */\n  static isJsonPointer(value) {\n    if (isArray(value)) {\n      return value.every(key => typeof key === 'string');\n    } else if (isString(value)) {\n      if (value === '' || value === '#') { return true; }\n      if (value[0] === '/' || value.slice(0, 2) === '#/') {\n        return !/(~[^01]|~$)/g.test(value);\n      }\n    }\n    return false;\n  }\n\n  /**\n   * 'isSubPointer' function\n   *\n   * Checks whether one JSON Pointer is a subset of another.\n   *\n   * @param  { Pointer } shortPointer - potential subset JSON Pointer\n   * @param  { Pointer } longPointer - potential superset JSON Pointer\n   * @param  { boolean = false } trueIfMatching - return true if pointers match?\n   * @param  { boolean = false } errors - Show error if invalid pointer?\n   * @return { boolean } - true if shortPointer is a subset of longPointer, false if not\n   */\n  static isSubPointer(\n    shortPointer, longPointer, trueIfMatching = false, errors = false\n  ) {\n    if (!this.isJsonPointer(shortPointer) || !this.isJsonPointer(longPointer)) {\n      if (errors) {\n        let invalid = '';\n        if (!this.isJsonPointer(shortPointer)) { invalid += ` 1: ${shortPointer}`; }\n        if (!this.isJsonPointer(longPointer)) { invalid += ` 2: ${longPointer}`; }\n        console.error(`isSubPointer error: Invalid JSON Pointer ${invalid}`);\n      }\n      return;\n    }\n    shortPointer = this.compile(shortPointer, '', errors);\n    longPointer = this.compile(longPointer, '', errors);\n    return shortPointer === longPointer ? trueIfMatching :\n      `${shortPointer}/` === longPointer.slice(0, shortPointer.length + 1);\n  }\n\n  /**\n   * 'toIndexedPointer' function\n   *\n   * Merges an array of numeric indexes and a generic pointer to create an\n   * indexed pointer for a specific item.\n   *\n   * For example, merging the generic pointer '/foo/-/bar/-/baz' and\n   * the array [4, 2] would result in the indexed pointer '/foo/4/bar/2/baz'\n   *\n   * @function\n   * @param  { Pointer } genericPointer - The generic pointer\n   * @param  { number[] } indexArray - The array of numeric indexes\n   * @param  { Map<string, number> } arrayMap - An optional array map\n   * @return { string } - The merged pointer with indexes\n   */\n  static toIndexedPointer(\n    genericPointer, indexArray, arrayMap: Map<string, number> = null\n  ) {\n    if (this.isJsonPointer(genericPointer) && isArray(indexArray)) {\n      let indexedPointer = this.compile(genericPointer);\n      if (isMap(arrayMap)) {\n        let arrayIndex = 0;\n        return indexedPointer.replace(/\\/\\-(?=\\/|$)/g, (key, stringIndex) =>\n          arrayMap.has((<string>indexedPointer).slice(0, stringIndex)) ?\n            '/' + indexArray[arrayIndex++] : key\n        );\n      } else {\n        for (const pointerIndex of indexArray) {\n          indexedPointer = indexedPointer.replace('/-', '/' + pointerIndex);\n        }\n        return indexedPointer;\n      }\n    }\n    if (!this.isJsonPointer(genericPointer)) {\n      console.error(`toIndexedPointer error: Invalid JSON Pointer: ${genericPointer}`);\n    }\n    if (!isArray(indexArray)) {\n      console.error(`toIndexedPointer error: Invalid indexArray: ${indexArray}`);\n    }\n  }\n\n  /**\n   * 'toGenericPointer' function\n   *\n   * Compares an indexed pointer to an array map and removes list array\n   * indexes (but leaves tuple arrray indexes and all object keys, including\n   * numeric keys) to create a generic pointer.\n   *\n   * For example, using the indexed pointer '/foo/1/bar/2/baz/3' and\n   * the arrayMap [['/foo', 0], ['/foo/-/bar', 3], ['/foo/-/bar/-/baz', 0]]\n   * would result in the generic pointer '/foo/-/bar/2/baz/-'\n   * Using the indexed pointer '/foo/1/bar/4/baz/3' and the same arrayMap\n   * would result in the generic pointer '/foo/-/bar/-/baz/-'\n   * (the bar array has 3 tuple items, so index 2 is retained, but 4 is removed)\n   *\n   * The structure of the arrayMap is: [['path to array', number of tuple items]...]\n   *\n   * @function\n   * @param  { Pointer } indexedPointer - The indexed pointer (array or string)\n   * @param  { Map<string, number> } arrayMap - The optional array map (for preserving tuple indexes)\n   * @return { string } - The generic pointer with indexes removed\n   */\n  static toGenericPointer(indexedPointer, arrayMap = new Map<string, number>()) {\n    if (this.isJsonPointer(indexedPointer) && isMap(arrayMap)) {\n      const pointerArray = this.parse(indexedPointer);\n      for (let i = 1; i < pointerArray.length; i++) {\n        const subPointer = this.compile(pointerArray.slice(0, i));\n        if (arrayMap.has(subPointer) &&\n          arrayMap.get(subPointer) <= +pointerArray[i]\n        ) {\n          pointerArray[i] = '-';\n        }\n      }\n      return this.compile(pointerArray);\n    }\n    if (!this.isJsonPointer(indexedPointer)) {\n      console.error(`toGenericPointer error: invalid JSON Pointer: ${indexedPointer}`);\n    }\n    if (!isMap(arrayMap)) {\n      console.error(`toGenericPointer error: invalid arrayMap: ${arrayMap}`);\n    }\n  }\n\n  /**\n   * 'toControlPointer' function\n   *\n   * Accepts a JSON Pointer for a data object and returns a JSON Pointer for the\n   * matching control in an Angular FormGroup.\n   *\n   * @param  { Pointer } dataPointer - JSON Pointer (string or array) to a data object\n   * @param  { FormGroup } formGroup - Angular FormGroup to get value from\n   * @param  { boolean = false } controlMustExist - Only return if control exists?\n   * @return { Pointer } - JSON Pointer (string) to the formGroup object\n   */\n  static toControlPointer(dataPointer, formGroup, controlMustExist = false) {\n    const dataPointerArray = this.parse(dataPointer);\n    const controlPointerArray: string[] = [];\n    let subGroup = formGroup;\n    if (dataPointerArray !== null) {\n      for (const key of dataPointerArray) {\n        if (hasOwn(subGroup, 'controls')) {\n          controlPointerArray.push('controls');\n          subGroup = subGroup.controls;\n        }\n        if (isArray(subGroup) && (key === '-')) {\n          controlPointerArray.push((subGroup.length - 1).toString());\n          subGroup = subGroup[subGroup.length - 1];\n        } else if (hasOwn(subGroup, key)) {\n          controlPointerArray.push(key);\n          subGroup = subGroup[key];\n        } else if (controlMustExist) {\n          console.error(`toControlPointer error: Unable to find \"${key}\" item in FormGroup.`);\n          console.error(dataPointer);\n          console.error(formGroup);\n          return;\n        } else {\n          controlPointerArray.push(key);\n          subGroup = { controls: {} };\n        }\n      }\n      return this.compile(controlPointerArray);\n    }\n    console.error(`toControlPointer error: Invalid JSON Pointer: ${dataPointer}`);\n  }\n\n  /**\n   * 'toSchemaPointer' function\n   *\n   * Accepts a JSON Pointer to a value inside a data object and a JSON schema\n   * for that object.\n   *\n   * Returns a Pointer to the sub-schema for the value inside the object's schema.\n   *\n   * @param  { Pointer } dataPointer - JSON Pointer (string or array) to an object\n   * @param  { any } schema - JSON schema for the object\n   * @return { Pointer } - JSON Pointer (string) to the object's schema\n   */\n  static toSchemaPointer(dataPointer, schema) {\n    if (this.isJsonPointer(dataPointer) && typeof schema === 'object') {\n      const pointerArray = this.parse(dataPointer);\n      if (!pointerArray.length) { return ''; }\n      const firstKey = pointerArray.shift();\n      if (schema.type === 'object' || schema.properties || schema.additionalProperties) {\n        if ((schema.properties || {})[firstKey]) {\n          return `/properties/${this.escape(firstKey)}` +\n            this.toSchemaPointer(pointerArray, schema.properties[firstKey]);\n        } else  if (schema.additionalProperties) {\n          return '/additionalProperties' +\n            this.toSchemaPointer(pointerArray, schema.additionalProperties);\n        }\n      }\n      if ((schema.type === 'array' || schema.items) &&\n        (isNumber(firstKey) || firstKey === '-' || firstKey === '')\n      ) {\n        const arrayItem = firstKey === '-' || firstKey === '' ? 0 : +firstKey;\n        if (isArray(schema.items)) {\n          if (arrayItem < schema.items.length) {\n            return '/items/' + arrayItem +\n              this.toSchemaPointer(pointerArray, schema.items[arrayItem]);\n          } else if (schema.additionalItems) {\n            return '/additionalItems' +\n              this.toSchemaPointer(pointerArray, schema.additionalItems);\n          }\n        } else if (isObject(schema.items)) {\n          return '/items' + this.toSchemaPointer(pointerArray, schema.items);\n        } else if (isObject(schema.additionalItems)) {\n          return '/additionalItems' +\n            this.toSchemaPointer(pointerArray, schema.additionalItems);\n        }\n      }\n      console.error(`toSchemaPointer error: Data pointer ${dataPointer} ` +\n        `not compatible with schema ${schema}`);\n      return null;\n    }\n    if (!this.isJsonPointer(dataPointer)) {\n      console.error(`toSchemaPointer error: Invalid JSON Pointer: ${dataPointer}`);\n    }\n    if (typeof schema !== 'object') {\n      console.error(`toSchemaPointer error: Invalid JSON Schema: ${schema}`);\n    }\n    return null;\n  }\n\n  /**\n   * 'toDataPointer' function\n   *\n   * Accepts a JSON Pointer to a sub-schema inside a JSON schema and the schema.\n   *\n   * If possible, returns a generic Pointer to the corresponding value inside\n   * the data object described by the JSON schema.\n   *\n   * Returns null if the sub-schema is in an ambiguous location (such as\n   * definitions or additionalProperties) where the corresponding value\n   * location cannot be determined.\n   *\n   * @param  { Pointer } schemaPointer - JSON Pointer (string or array) to a JSON schema\n   * @param  { any } schema - the JSON schema\n   * @param  { boolean = false } errors - Show errors?\n   * @return { Pointer } - JSON Pointer (string) to the value in the data object\n   */\n  static toDataPointer(schemaPointer, schema, errors = false) {\n    if (this.isJsonPointer(schemaPointer) && typeof schema === 'object' &&\n      this.has(schema, schemaPointer)\n    ) {\n      const pointerArray = this.parse(schemaPointer);\n      if (!pointerArray.length) { return ''; }\n      const dataPointer = '';\n      const firstKey = pointerArray.shift();\n      if (firstKey === 'properties' ||\n        (firstKey === 'items' && isArray(schema.items))\n      ) {\n        const secondKey = pointerArray.shift();\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n        return pointerSuffix === null ? null : '/' + secondKey + pointerSuffix;\n      } else if (firstKey === 'additionalItems' ||\n        (firstKey === 'items' && isObject(schema.items))\n      ) {\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey]);\n        return pointerSuffix === null ? null : '/-' + pointerSuffix;\n      } else if (['allOf', 'anyOf', 'oneOf'].includes(firstKey)) {\n        const secondKey = pointerArray.shift();\n        return this.toDataPointer(pointerArray, schema[firstKey][secondKey]);\n      } else if (firstKey === 'not') {\n        return this.toDataPointer(pointerArray, schema[firstKey]);\n      } else if (['contains', 'definitions', 'dependencies', 'additionalItems',\n        'additionalProperties', 'patternProperties', 'propertyNames'].includes(firstKey)\n      ) {\n        if (errors) { console.error(`toDataPointer error: Ambiguous location`); }\n      }\n      return '';\n    }\n    if (errors) {\n      if (!this.isJsonPointer(schemaPointer)) {\n        console.error(`toDataPointer error: Invalid JSON Pointer: ${schemaPointer}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Invalid JSON Schema: ${schema}`);\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Pointer ${schemaPointer} invalid for Schema: ${schema}`);\n      }\n    }\n    return null;\n  }\n\n  /**\n   * 'parseObjectPath' function\n   *\n   * Parses a JavaScript object path into an array of keys, which\n   * can then be passed to compile() to convert into a string JSON Pointer.\n   *\n   * Based on mike-marcacci's excellent objectpath parse function:\n   * https://github.com/mike-marcacci/objectpath\n   *\n   * @param  { Pointer } path - The object path to parse\n   * @return { string[] } - The resulting array of keys\n   */\n  static parseObjectPath(path) {\n    if (isArray(path)) { return <string[]>path; }\n    if (this.isJsonPointer(path)) { return this.parse(path); }\n    if (typeof path === 'string') {\n      let index = 0;\n      const parts: string[] = [];\n      while (index < path.length) {\n        const nextDot = path.indexOf('.', index);\n        const nextOB = path.indexOf('[', index); // next open bracket\n        if (nextDot === -1 && nextOB === -1) { // last item\n          parts.push(path.slice(index));\n          index = path.length;\n        } else if (nextDot !== -1 && (nextDot < nextOB || nextOB === -1)) { // dot notation\n          parts.push(path.slice(index, nextDot));\n          index = nextDot + 1;\n        } else { // bracket notation\n          if (nextOB > index) {\n            parts.push(path.slice(index, nextOB));\n            index = nextOB;\n          }\n          const quote = path.charAt(nextOB + 1);\n          if (quote === '\"' || quote === '\\'') { // enclosing quotes\n            let nextCB = path.indexOf(quote + ']', nextOB); // next close bracket\n            while (nextCB !== -1 && path.charAt(nextCB - 1) === '\\\\') {\n              nextCB = path.indexOf(quote + ']', nextCB + 2);\n            }\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 2, nextCB)\n              .replace(new RegExp('\\\\' + quote, 'g'), quote));\n            index = nextCB + 2;\n          } else { // no enclosing quotes\n            let nextCB = path.indexOf(']', nextOB); // next close bracket\n            if (nextCB === -1) { nextCB = path.length; }\n            parts.push(path.slice(index + 1, nextCB));\n            index = nextCB + 1;\n          }\n          if (path.charAt(index) === '.') { index++; }\n        }\n      }\n      return parts;\n    }\n    console.error('parseObjectPath error: Input object path must be a string.');\n  }\n}\n",
    "// tslint:disable max-line-length\n// updated from AJV fast format regular expressions:\n// https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n\nexport const jsonSchemaFormatTests = {\n\n  'date': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n\n  'time': /^[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // Modified to allow incomplete entries, such as\n  // \"2000-03-14T01:59:26.535\" (needs \"Z\") or \"2000-03-14T01:59\" (needs \":00Z\")\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d(?::[0-5]\\d)?(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  'email': /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n\n  'hostname': /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i,\n\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  'ipv4': /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  'ipv6': /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  'uri': /^(?:[a-z][a-z0-9+-.]*)(?::|\\/)\\/?[^\\s]*$/i,\n\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i,\n\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  'uri-template': /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  // @todo Delete current URL in favour of the commented out URL rule when this ajv issue is fixed https://github.com/eslint/eslint/issues/7983.\n  // URL: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  'url': /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i,\n\n  // uuid: http://tools.ietf.org/html/rfc4122\n  'uuid': /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\n  // optimized https://gist.github.com/olmokramer/82ccce673f86db7cda5e\n  'color': /^\\s*(#(?:[\\da-f]{3}){1,2}|rgb\\((?:\\d{1,3},\\s*){2}\\d{1,3}\\)|rgba\\((?:\\d{1,3},\\s*){3}\\d*\\.?\\d+\\)|hsl\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2}\\)|hsla\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2},\\s*\\d*\\.?\\d+\\))\\s*$/gi,\n\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\n  'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\n  'regex': function(str) {\n    if (/[^\\\\]\\\\Z/.test(str)) { return false; }\n    try {\n      // tslint:disable-next-line no-unused-expression\n      new RegExp(str);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n};\n\nexport type JsonSchemaFormatNames =\n  'date'|'time'|'date-time'|'email'|'hostname'|'ipv4'|'ipv6'|\n  'uri'|'uri-reference'|'uri-template'|'url'|'uuid'|'color'|\n  'json-pointer'|'relative-json-pointer'|'regex';\n",
    "import { AbstractControl, ValidationErrors, ValidatorFn } from '@angular/forms';\nimport { Observable } from 'rxjs-compat/Observable';\nimport { forkJoin } from 'rxjs-compat/observable/forkJoin';\nimport { map } from 'rxjs-compat/operator/map';\n\nimport * as _ from 'lodash';\n\nimport {\n  _executeValidators, _executeAsyncValidators, _mergeObjects, _mergeErrors,\n  isEmpty, isDefined, hasValue, isString, isNumber, isBoolean, isArray,\n  getType, isType, toJavaScriptType, toObservable, xor, SchemaPrimitiveType,\n  PlainObject, IValidatorFn, AsyncIValidatorFn\n} from './validator.functions';\nimport { forEachCopy } from './utility.functions';\nimport { jsonSchemaFormatTests, JsonSchemaFormatNames } from './format-regex.constants';\n\n/**\n * 'JsonValidators' class\n *\n * Provides an extended set of validators to be used by form controls,\n * compatible with standard JSON Schema validation options.\n * http://json-schema.org/latest/json-schema-validation.html\n *\n * Note: This library is designed as a drop-in replacement for the Angular\n * Validators library, and except for one small breaking change to the 'pattern'\n * validator (described below) it can even be imported as a substitute, like so:\n *\n *   import { JsonValidators as Validators } from 'json-validators';\n *\n * and it should work with existing code as a complete replacement.\n *\n * The one exception is the 'pattern' validator, which has been changed to\n * matche partial values by default (the standard 'pattern' validator wrapped\n * all patterns in '^' and '$', forcing them to always match an entire value).\n * However, the old behavior can be restored by simply adding '^' and '$'\n * around your patterns, or by passing an optional second parameter of TRUE.\n * This change is to make the 'pattern' validator match the behavior of a\n * JSON Schema pattern, which allows partial matches, rather than the behavior\n * of an HTML input control pattern, which does not.\n *\n * This library replaces Angular's validators and combination functions\n * with the following validators and transformation functions:\n *\n * Validators:\n *   For all formControls:     required (*), type, enum, const\n *   For text formControls:    minLength (*), maxLength (*), pattern (*), format\n *   For numeric formControls: maximum, exclusiveMaximum,\n *                             minimum, exclusiveMinimum, multipleOf\n *   For formGroup objects:    minProperties, maxProperties, dependencies\n *   For formArray arrays:     minItems, maxItems, uniqueItems, contains\n *   Not used by JSON Schema:  min (*), max (*), requiredTrue (*), email (*)\n * (Validators originally included with Angular are maked with (*).)\n *\n * NOTE / TODO: The dependencies validator is not complete.\n * NOTE / TODO: The contains validator is not complete.\n *\n * Validators not used by JSON Schema (but included for compatibility)\n * and their JSON Schema equivalents:\n *\n *   Angular validator | JSON Schema equivalent\n *   ------------------|-----------------------\n *     min(number)     |   minimum(number)\n *     max(number)     |   maximum(number)\n *     requiredTrue()  |   const(true)\n *     email()         |   format('email')\n *\n * Validator transformation functions:\n *   composeAnyOf, composeOneOf, composeAllOf, composeNot\n * (Angular's original combination funciton, 'compose', is also included for\n * backward compatibility, though it is functionally equivalent to composeAllOf,\n * asside from its more generic error message.)\n *\n * All validators have also been extended to accept an optional second argument\n * which, if passed a TRUE value, causes the validator to perform the opposite\n * of its original finction. (This is used internally to enable 'not' and\n * 'composeOneOf' to function and return useful error messages.)\n *\n * The 'required' validator has also been overloaded so that if called with\n * a boolean parameter (or no parameters) it returns the original validator\n * function (rather than executing it). However, if it is called with an\n * AbstractControl parameter (as was previously required), it behaves\n * exactly as before.\n *\n * This enables all validators (including 'required') to be constructed in\n * exactly the same way, so they can be automatically applied using the\n * equivalent key names and values taken directly from a JSON Schema.\n *\n * This source code is partially derived from Angular,\n * which is Copyright (c) 2014-2017 Google, Inc.\n * Use of this source code is therefore governed by the same MIT-style license\n * that can be found in the LICENSE file at https://angular.io/license\n *\n * Original Angular Validators:\n * https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n */\nexport class JsonValidators {\n\n  /**\n   * Validator functions:\n   *\n   * For all formControls:     required, type, enum, const\n   * For text formControls:    minLength, maxLength, pattern, format\n   * For numeric formControls: maximum, exclusiveMaximum,\n   *                           minimum, exclusiveMinimum, multipleOf\n   * For formGroup objects:    minProperties, maxProperties, dependencies\n   * For formArray arrays:     minItems, maxItems, uniqueItems, contains\n   *\n   * TODO: finish dependencies validator\n   */\n\n  /**\n   * 'required' validator\n   *\n   * This validator is overloaded, compared to the default required validator.\n   * If called with no parameters, or TRUE, this validator returns the\n   * 'required' validator function (rather than executing it). This matches\n   * the behavior of all other validators in this library.\n   *\n   * If this validator is called with an AbstractControl parameter\n   * (as was previously required) it behaves the same as Angular's default\n   * required validator, and returns an error if the control is empty.\n   *\n   * Old behavior: (if input type = AbstractControl)\n   * @param {AbstractControl} control - required control\n   * @return {{[key: string]: boolean}} - returns error message if no input\n   *\n   * New behavior: (if no input, or input type = boolean)\n   * @param {boolean = true} required? - true to validate, false to disable\n   * @return {IValidatorFn} - returns the 'required' validator function itself\n   */\n  static required(input: AbstractControl): ValidationErrors|null;\n  static required(input?: boolean): IValidatorFn;\n\n  static required(input?: AbstractControl|boolean): ValidationErrors|null|IValidatorFn {\n    if (input === undefined) { input = true; }\n    switch (input) {\n      case true: // Return required function (do not execute it yet)\n        return (control: AbstractControl, invert = false): ValidationErrors|null => {\n          if (invert) { return null; } // if not required, always return valid\n          return hasValue(control.value) ? null : { 'required': true };\n        };\n      case false: // Do nothing (if field is not required, it is always valid)\n        return JsonValidators.nullValidator;\n      default: // Execute required function\n        return hasValue((<AbstractControl>input).value) ? null : { 'required': true };\n    }\n  }\n\n  /**\n   * 'type' validator\n   *\n   * Requires a control to only accept values of a specified type,\n   * or one of an array of types.\n   *\n   * Note: SchemaPrimitiveType = 'string'|'number'|'integer'|'boolean'|'null'\n   *\n   * @param {SchemaPrimitiveType|SchemaPrimitiveType[]} type - type(s) to accept\n   * @return {IValidatorFn}\n   */\n  static type(requiredType: SchemaPrimitiveType|SchemaPrimitiveType[]): IValidatorFn {\n    if (!hasValue(requiredType)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isValid = isArray(requiredType) ?\n        (<SchemaPrimitiveType[]>requiredType).some(type => isType(currentValue, type)) :\n        isType(currentValue, <SchemaPrimitiveType>requiredType);\n      return xor(isValid, invert) ?\n        null : { 'type': { requiredType, currentValue } };\n    };\n  }\n\n  /**\n   * 'enum' validator\n   *\n   * Requires a control to have a value from an enumerated list of values.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null enum values.\n   *\n   * @param {any[]} allowedValues - array of acceptable values\n   * @return {IValidatorFn}\n   */\n  static enum(allowedValues: any[]): IValidatorFn {\n    if (!isArray(allowedValues)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqual = (enumValue, inputValue) =>\n        enumValue === inputValue ||\n        (isNumber(enumValue) && +inputValue === +enumValue) ||\n        (isBoolean(enumValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === enumValue) ||\n        (enumValue === null && !hasValue(inputValue)) ||\n        _.isEqual(enumValue, inputValue);\n      const isValid = isArray(currentValue) ?\n        currentValue.every(inputValue => allowedValues.some(enumValue =>\n          isEqual(enumValue, inputValue)\n        )) :\n        allowedValues.some(enumValue => isEqual(enumValue, currentValue));\n      return xor(isValid, invert) ?\n        null : { 'enum': { allowedValues, currentValue } };\n    };\n  }\n\n  /**\n   * 'const' validator\n   *\n   * Requires a control to have a specific value.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null values.\n   *\n   * TODO: modify to work with objects\n   *\n   * @param {any[]} requiredValue - required value\n   * @return {IValidatorFn}\n   */\n  static const(requiredValue: any): IValidatorFn {\n    if (!hasValue(requiredValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue: any = control.value;\n      const isEqual = (constValue, inputValue) =>\n        constValue === inputValue ||\n        isNumber(constValue) && +inputValue === +constValue ||\n        isBoolean(constValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === constValue ||\n        constValue === null && !hasValue(inputValue);\n      const isValid = isEqual(requiredValue, currentValue);\n      return xor(isValid, invert) ?\n        null : { 'const': { requiredValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minLength' validator\n   *\n   * Requires a control's text value to be greater than a specified length.\n   *\n   * @param {number} minimumLength - minimum allowed string length\n   * @param {boolean = false} invert - instead return error object only if valid\n   * @return {IValidatorFn}\n   */\n  static minLength(minimumLength: number): IValidatorFn {\n    if (!hasValue(minimumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength >= minimumLength;\n      return xor(isValid, invert) ?\n        null : { 'minLength': { minimumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'maxLength' validator\n   *\n   * Requires a control's text value to be less than a specified length.\n   *\n   * @param {number} maximumLength - maximum allowed string length\n   * @param {boolean = false} invert - instead return error object only if valid\n   * @return {IValidatorFn}\n   */\n  static maxLength(maximumLength: number): IValidatorFn {\n    if (!hasValue(maximumLength)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentLength = isString(control.value) ? control.value.length : 0;\n      const isValid = currentLength <= maximumLength;\n      return xor(isValid, invert) ?\n        null : { 'maxLength': { maximumLength, currentLength } };\n    };\n  }\n\n  /**\n   * 'pattern' validator\n   *\n   * Note: NOT the same as Angular's default pattern validator.\n   *\n   * Requires a control's value to match a specified regular expression pattern.\n   *\n   * This validator changes the behavior of default pattern validator\n   * by replacing RegExp(`^${pattern}$`) with RegExp(`${pattern}`),\n   * which allows for partial matches.\n   *\n   * To return to the default funcitonality, and match the entire string,\n   * pass TRUE as the optional second parameter.\n   *\n   * @param {string} pattern - regular expression pattern\n   * @param {boolean = false} wholeString - match whole value string?\n   * @return {IValidatorFn}\n   */\n  static pattern(pattern: string|RegExp, wholeString = false): IValidatorFn {\n    if (!hasValue(pattern)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let regex: RegExp;\n      let requiredPattern: string;\n      if (typeof pattern === 'string') {\n        requiredPattern = (wholeString) ? `^${pattern}$` : pattern;\n        regex = new RegExp(requiredPattern);\n      } else {\n        requiredPattern = pattern.toString();\n        regex = pattern;\n      }\n      const currentValue: string = control.value;\n      const isValid = isString(currentValue) ? regex.test(currentValue) : false;\n      return xor(isValid, invert) ?\n        null : { 'pattern': { requiredPattern, currentValue } };\n    };\n  }\n\n  /**\n   * 'format' validator\n   *\n   * Requires a control to have a value of a certain format.\n   *\n   * This validator currently checks the following formsts:\n   *   date, time, date-time, email, hostname, ipv4, ipv6,\n   *   uri, uri-reference, uri-template, url, uuid, color,\n   *   json-pointer, relative-json-pointer, regex\n   *\n   * Fast format regular expressions copied from AJV:\n   * https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n   *\n   * @param {JsonSchemaFormatNames} requiredFormat - format to check\n   * @return {IValidatorFn}\n   */\n  static format(requiredFormat: JsonSchemaFormatNames): IValidatorFn {\n    if (!hasValue(requiredFormat)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      let isValid: boolean;\n      const currentValue: string|Date = control.value;\n      if (isString(currentValue)) {\n        const formatTest: Function|RegExp = jsonSchemaFormatTests[requiredFormat];\n        if (typeof formatTest === 'object') {\n          isValid = (<RegExp>formatTest).test(<string>currentValue);\n        } else if (typeof formatTest === 'function') {\n          isValid = (<Function>formatTest)(<string>currentValue);\n        } else {\n          console.error(`format validator error: \"${requiredFormat}\" is not a recognized format.`);\n          isValid = true;\n        }\n      } else {\n        // Allow JavaScript Date objects\n        isValid = ['date', 'time', 'date-time'].includes(requiredFormat) &&\n          Object.prototype.toString.call(currentValue) === '[object Date]';\n      }\n      return xor(isValid, invert) ?\n        null : { 'format': { requiredFormat, currentValue } };\n    };\n  }\n\n  /**\n   * 'minimum' validator\n   *\n   * Requires a control's numeric value to be greater than or equal to\n   * a minimum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a minimum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} minimum - minimum allowed value\n   * @return {IValidatorFn}\n   */\n  static minimum(minimumValue: number): IValidatorFn {\n    if (!hasValue(minimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || currentValue >= minimumValue;\n      return xor(isValid, invert) ?\n        null : { 'minimum': { minimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMinimum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} exclusiveMinimumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static exclusiveMinimum(exclusiveMinimumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMinimumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMinimumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMinimum': { exclusiveMinimumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'maximum' validator\n   *\n   * Requires a control's numeric value to be less than or equal to\n   * a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} maximumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static maximum(maximumValue: number): IValidatorFn {\n    if (!hasValue(maximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue <= maximumValue;\n      return xor(isValid, invert) ?\n        null : { 'maximum': { maximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'exclusiveMaximum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param {number} exclusiveMaximumValue - maximum allowed value\n   * @return {IValidatorFn}\n   */\n  static exclusiveMaximum(exclusiveMaximumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMaximumValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMaximumValue;\n      return xor(isValid, invert) ?\n        null : { 'exclusiveMaximum': { exclusiveMaximumValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'multipleOf' validator\n   *\n   * Requires a control to have a numeric value that is a multiple\n   * of a specified number.\n   *\n   * @param {number} multipleOfValue - number value must be a multiple of\n   * @return {IValidatorFn}\n   */\n  static multipleOf(multipleOfValue: number): IValidatorFn {\n    if (!hasValue(multipleOfValue)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentValue = control.value;\n      const isValid = isNumber(currentValue) &&\n        currentValue % multipleOfValue === 0;\n      return xor(isValid, invert) ?\n        null : { 'multipleOf': { multipleOfValue, currentValue } };\n    };\n  }\n\n  /**\n   * 'minProperties' validator\n   *\n   * Requires a form group to have a minimum number of properties (i.e. have\n   * values entered in a minimum number of controls within the group).\n   *\n   * @param {number} minimumProperties - minimum number of properties allowed\n   * @return {IValidatorFn}\n   */\n  static minProperties(minimumProperties: number): IValidatorFn {\n    if (!hasValue(minimumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties >= minimumProperties;\n      return xor(isValid, invert) ?\n        null : { 'minProperties': { minimumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'maxProperties' validator\n   *\n   * Requires a form group to have a maximum number of properties (i.e. have\n   * values entered in a maximum number of controls within the group).\n   *\n   * Note: Has no effect if the form group does not contain more than the\n   * maximum number of controls.\n   *\n   * @param {number} maximumProperties - maximum number of properties allowed\n   * @return {IValidatorFn}\n   */\n  static maxProperties(maximumProperties: number): IValidatorFn {\n    if (!hasValue(maximumProperties)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentProperties = Object.keys(control.value).length || 0;\n      const isValid = currentProperties <= maximumProperties;\n      return xor(isValid, invert) ?\n        null : { 'maxProperties': { maximumProperties, currentProperties } };\n    };\n  }\n\n  /**\n   * 'dependencies' validator\n   *\n   * Requires the controls in a form group to meet additional validation\n   * criteria, depending on the values of other controls in the group.\n   *\n   * Examples:\n   * https://spacetelescope.github.io/understanding-json-schema/reference/object.html#dependencies\n   *\n   * @param {any} dependencies - required dependencies\n   * @return {IValidatorFn}\n   */\n  static dependencies(dependencies: any): IValidatorFn {\n    if (getType(dependencies) !== 'object' || isEmpty(dependencies)) {\n      return JsonValidators.nullValidator;\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const allErrors = _mergeObjects(\n        forEachCopy(dependencies, (value, requiringField) => {\n          if (!hasValue(control.value[requiringField])) { return null; }\n          let requiringFieldErrors: ValidationErrors = { };\n          let requiredFields: string[];\n          let properties: ValidationErrors = { };\n          if (getType(dependencies[requiringField]) === 'array') {\n            requiredFields = dependencies[requiringField];\n          } else if (getType(dependencies[requiringField]) === 'object') {\n            requiredFields = dependencies[requiringField]['required'] || [];\n            properties = dependencies[requiringField]['properties'] || { };\n          }\n\n          // Validate property dependencies\n          for (const requiredField of requiredFields) {\n            if (xor(!hasValue(control.value[requiredField]), invert)) {\n              requiringFieldErrors[requiredField] = { 'required': true };\n            }\n          }\n\n          // Validate schema dependencies\n          requiringFieldErrors = _mergeObjects(requiringFieldErrors,\n            forEachCopy(properties, (requirements, requiredField) => {\n              const requiredFieldErrors = _mergeObjects(\n                forEachCopy(requirements, (requirement, parameter) => {\n                  let validator: IValidatorFn = null;\n                  if (requirement === 'maximum' || requirement === 'minimum') {\n                    const exclusive = !!requirements['exclusiveM' + requirement.slice(1)];\n                    validator = JsonValidators[requirement](parameter, exclusive);\n                  } else if (typeof JsonValidators[requirement] === 'function') {\n                    validator = JsonValidators[requirement](parameter);\n                  }\n                  return !isDefined(validator) ?\n                    null : validator(control.value[requiredField]);\n                })\n              );\n              return isEmpty(requiredFieldErrors) ?\n                null : { [requiredField]: requiredFieldErrors };\n            })\n          );\n          return isEmpty(requiringFieldErrors) ?\n            null : { [requiringField]: requiringFieldErrors };\n        })\n      );\n      return isEmpty(allErrors) ? null : allErrors;\n    };\n  }\n\n  /**\n   * 'minItems' validator\n   *\n   * Requires a form array to have a minimum number of values.\n   *\n   * @param {number} minimumItems - minimum number of items allowed\n   * @return {IValidatorFn}\n   */\n  static minItems(minimumItems: number): IValidatorFn {\n    if (!hasValue(minimumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems >= minimumItems;\n      return xor(isValid, invert) ?\n        null : { 'minItems': { minimumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'maxItems' validator\n   *\n   * Requires a form array to have a maximum number of values.\n   *\n   * @param {number} maximumItems - maximum number of items allowed\n   * @return {IValidatorFn}\n   */\n  static maxItems(maximumItems: number): IValidatorFn {\n    if (!hasValue(maximumItems)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const currentItems = isArray(control.value) ? control.value.length : 0;\n      const isValid = currentItems <= maximumItems;\n      return xor(isValid, invert) ?\n        null : { 'maxItems': { maximumItems, currentItems } };\n    };\n  }\n\n  /**\n   * 'uniqueItems' validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param {boolean = true} unique? - true to validate, false to disable\n   * @return {IValidatorFn}\n   */\n  static uniqueItems(unique = true): IValidatorFn {\n    if (!unique) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const sorted: any[] = control.value.slice().sort();\n      const duplicateItems = [];\n      for (let i = 1; i < sorted.length; i++) {\n        if (sorted[i - 1] === sorted[i] && duplicateItems.includes(sorted[i])) {\n          duplicateItems.push(sorted[i]);\n        }\n      }\n      const isValid = !duplicateItems.length;\n      return xor(isValid, invert) ?\n        null : { 'uniqueItems': { duplicateItems } };\n    };\n  }\n\n  /**\n   * 'contains' validator\n   *\n   * TODO: Complete this validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param {boolean = true} unique? - true to validate, false to disable\n   * @return {IValidatorFn}\n   */\n  static contains(requiredItem = true): IValidatorFn {\n    if (!requiredItem) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value) || !isArray(control.value)) { return null; }\n      const currentItems = control.value;\n      // const isValid = currentItems.some(item =>\n      //\n      // );\n      const isValid = true;\n      return xor(isValid, invert) ?\n        null : { 'contains': { requiredItem, currentItems } };\n    };\n  }\n\n  /**\n   * No-op validator. Included for backward compatibility.\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors|null {\n    return null;\n  }\n\n  /**\n   * Validator transformation functions:\n   * composeAnyOf, composeOneOf, composeAllOf, composeNot,\n   * compose, composeAsync\n   *\n   * TODO: Add composeAnyOfAsync, composeOneOfAsync,\n   *           composeAllOfAsync, composeNotAsync\n   */\n\n  /**\n   * 'composeAnyOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid if any one or more of the submitted validators are\n   * valid. If every validator is invalid, it returns combined errors from\n   * all validators.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeAnyOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators, invert).filter(isDefined);\n      const isValid = validators.length > arrayOfErrors.length;\n      return xor(isValid, invert) ?\n        null : _mergeObjects(...arrayOfErrors, { 'anyOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeOneOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if exactly one of the submitted validators\n   * is valid. Otherwise returns combined information from all validators,\n   * both valid and invalid.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeOneOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const arrayOfErrors =\n        _executeValidators(control, presentValidators);\n      const validControls =\n        validators.length - arrayOfErrors.filter(isDefined).length;\n      const isValid = validControls === 1;\n      if (xor(isValid, invert)) { return null; }\n      const arrayOfValids =\n        _executeValidators(control, presentValidators, invert);\n      return _mergeObjects(...arrayOfErrors, ...arrayOfValids, { 'oneOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeAllOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if all the submitted validators are individually\n   * valid. Otherwise it returns combined errors from all invalid validators.\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static composeAllOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      const combinedErrors = _mergeErrors(\n        _executeValidators(control, presentValidators, invert)\n      );\n      const isValid = combinedErrors === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(combinedErrors, { 'allOf': !invert });\n    };\n  }\n\n  /**\n   * 'composeNot' validator inversion function\n   *\n   * Accepts a single validator function and inverts its result.\n   * Returns valid if the submitted validator is invalid, and\n   * returns invalid if the submitted validator is valid.\n   * (Note: this function can itself be inverted\n   *   - e.g. composeNot(composeNot(validator)) -\n   *   but this can be confusing and is therefore not recommended.)\n   *\n   * @param {IValidatorFn[]} validators - validator(s) to invert\n   * @return {IValidatorFn} - new validator function that returns opposite result\n   */\n  static composeNot(validator: IValidatorFn): IValidatorFn {\n    if (!validator) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null => {\n      if (isEmpty(control.value)) { return null; }\n      const error = validator(control, !invert);\n      const isValid = error === null;\n      return (xor(isValid, invert)) ?\n        null : _mergeObjects(error, { 'not': !invert });\n    };\n  }\n\n  /**\n   * 'compose' validator combination function\n   *\n   * @param {IValidatorFn[]} validators - array of validators to combine\n   * @return {IValidatorFn} - single combined validator function\n   */\n  static compose(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl, invert = false): ValidationErrors|null =>\n      _mergeErrors(_executeValidators(control, presentValidators, invert));\n  }\n\n  /**\n   * 'composeAsync' async validator combination function\n   *\n   * @param {AsyncIValidatorFn[]} async validators - array of async validators\n   * @return {AsyncIValidatorFn} - single combined async validator function\n   */\n  static composeAsync(validators: AsyncIValidatorFn[]): AsyncIValidatorFn {\n    if (!validators) { return null; }\n    const presentValidators = validators.filter(isDefined);\n    if (presentValidators.length === 0) { return null; }\n    return (control: AbstractControl) => {\n      const observables =\n        _executeAsyncValidators(control, presentValidators).map(toObservable);\n      return map.call(forkJoin(observables), _mergeErrors);\n    };\n  }\n\n  // Additional angular validators (not used by Angualr JSON Schema Form)\n  // From https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   */\n  static min(min: number): ValidatorFn {\n    if (!hasValue(min)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(min)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return isNaN(value) || value >= min ? null : { 'min': { min, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   */\n  static max(max: number): ValidatorFn {\n    if (!hasValue(max)) { return JsonValidators.nullValidator; }\n    return (control: AbstractControl): ValidationErrors|null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(max)) { return null; }\n      const value = parseFloat(control.value);\n      const actual = control.value;\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return isNaN(value) || value <= max ? null : { 'max': { max, actual } };\n    };\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    return control.value === true ? null : { 'required': true };\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control: AbstractControl): ValidationErrors|null {\n    if (!control) { return JsonValidators.nullValidator; }\n    const EMAIL_REGEXP =\n      // tslint:disable-next-line max-line-length\n      /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/;\n    return EMAIL_REGEXP.test(control.value) ? null : { 'email': true };\n  }\n}\n",
    "import * as _ from 'lodash';\n\nimport {\n  isArray, isEmpty, isNumber, isObject, isString\n} from './validator.functions';\nimport { hasOwn, uniqueItems, commonItems } from './utility.functions';\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\n\n/**\n * 'mergeSchemas' function\n *\n * Merges multiple JSON schemas into a single schema with combined rules.\n *\n * If able to logically merge properties from all schemas,\n * returns a single schema object containing all merged properties.\n *\n * Example: ({ a: b, max: 1 }, { c: d, max: 2 }) => { a: b, c: d, max: 1 }\n *\n * If unable to logically merge, returns an allOf schema object containing\n * an array of the original schemas;\n *\n * Example: ({ a: b }, { a: d }) => { allOf: [ { a: b }, { a: d } ] }\n *\n * @param  { any } schemas - one or more input schemas\n * @return { any } - merged schema\n */\nexport function mergeSchemas(...schemas) {\n  schemas = schemas.filter(schema => !isEmpty(schema));\n  if (schemas.some(schema => !isObject(schema))) { return null; }\n  const combinedSchema: any = {};\n  for (const schema of schemas) {\n    for (const key of Object.keys(schema)) {\n      const combinedValue = combinedSchema[key];\n      const schemaValue = schema[key];\n      if (!hasOwn(combinedSchema, key) || _.isEqual(combinedValue, schemaValue)) {\n        combinedSchema[key] = schemaValue;\n      } else {\n        switch (key) {\n          case 'allOf':\n            // Combine all items from both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.allOf = mergeSchemas(...combinedValue, ...schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'additionalItems': case 'additionalProperties':\n          case 'contains': case 'propertyNames':\n            // Merge schema objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema[key] = mergeSchemas(combinedValue, schemaValue);\n            // additionalProperties == false in any schema overrides all other values\n            } else if (\n              key === 'additionalProperties' &&\n              (combinedValue === false || schemaValue === false)\n            ) {\n              combinedSchema.combinedSchema = false;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'anyOf': case 'oneOf': case 'enum':\n            // Keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema[key] = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema[key].length) { return { allOf: [ ...schemas ] }; }\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'definitions':\n            // Combine keys from both objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // Don't combine matching keys with different values\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.definitions = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'dependencies':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys,\n            // converting from arrays to objects if necessary\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are arrays, include all items from both arrays,\n                // excluding duplicates\n                } else if (\n                  isArray(schemaValue[subKey]) && isArray(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    uniqueItems(...combinedObject[subKey], ...schemaValue[subKey]);\n                // If either key is an object, merge the schemas\n                } else if (\n                  (isArray(schemaValue[subKey]) || isObject(schemaValue[subKey])) &&\n                  (isArray(combinedObject[subKey]) || isObject(combinedObject[subKey]))\n                ) {\n                  // If either key is an array, convert it to an object first\n                  const required = isArray(combinedSchema.required) ?\n                    combinedSchema.required : [];\n                  const combinedDependency = isArray(combinedObject[subKey]) ?\n                    { required: uniqueItems(...required, combinedObject[subKey]) } :\n                    combinedObject[subKey];\n                  const schemaDependency = isArray(schemaValue[subKey]) ?\n                    { required: uniqueItems(...required, schemaValue[subKey]) } :\n                    schemaValue[subKey];\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedDependency, schemaDependency);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.dependencies = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'items':\n            // If arrays, keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              );\n              if (!combinedSchema.items.length) { return { allOf: [ ...schemas ] }; }\n            // If both keys are objects, merge them\n            } else if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items = mergeSchemas(combinedValue, schemaValue);\n            // If object + array, combine object with each array item\n            } else if (isArray(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items =\n                combinedValue.map(item => mergeSchemas(item, schemaValue));\n            } else if (isObject(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items =\n                schemaValue.map(item => mergeSchemas(item, combinedValue));\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'multipleOf':\n            // TODO: Adjust to correctly handle decimal values\n            // If numbers, set to least common multiple\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              const gcd = (x, y) => !y ? x : gcd(y, x % y);\n              const lcm = (x, y) => (x * y) / gcd(x, y);\n              combinedSchema.multipleOf = lcm(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'maximum': case 'exclusiveMaximum': case 'maxLength':\n          case 'maxItems': case 'maxProperties':\n            // If numbers, set to lowest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.min(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'minimum': case 'exclusiveMinimum': case 'minLength':\n          case 'minItems': case 'minProperties':\n            // If numbers, set to highest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.max(combinedValue, schemaValue);\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'not':\n            // Combine not values into anyOf array\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const notAnyOf = [combinedValue, schemaValue]\n                .reduce((notAnyOfArray, notSchema) =>\n                  isArray(notSchema.anyOf) &&\n                  Object.keys(notSchema).length === 1 ?\n                    [ ...notAnyOfArray, ...notSchema.anyOf ] :\n                    [ ...notAnyOfArray, notSchema ]\n                , []);\n              // TODO: Remove duplicate items from array\n              combinedSchema.not = { anyOf: notAnyOf };\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'patternProperties':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) && isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.patternProperties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'properties':\n            // Combine all keys from both objects\n            // unless additionalProperties === false\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = { ...combinedValue };\n              // If new schema has additionalProperties,\n              // merge or remove non-matching property keys in combined schema\n              if (hasOwn(schemaValue, 'additionalProperties')) {\n                Object.keys(combinedValue)\n                  .filter(combinedKey => !Object.keys(schemaValue).includes(combinedKey))\n                  .forEach(nonMatchingKey => {\n                    if (schemaValue.additionalProperties === false) {\n                      delete combinedObject[nonMatchingKey];\n                    } else if (isObject(schemaValue.additionalProperties)) {\n                      combinedObject[nonMatchingKey] = mergeSchemas(\n                        combinedObject[nonMatchingKey],\n                        schemaValue.additionalProperties\n                      );\n                    }\n                  });\n              }\n              for (const subKey of Object.keys(schemaValue)) {\n                if (_.isEqual(combinedObject[subKey], schemaValue[subKey]) || (\n                  !hasOwn(combinedObject, subKey) &&\n                  !hasOwn(combinedObject, 'additionalProperties')\n                )) {\n                  combinedObject[subKey] = schemaValue[subKey];\n                // If combined schema has additionalProperties,\n                // merge or ignore non-matching property keys in new schema\n                } else if (\n                  !hasOwn(combinedObject, subKey) &&\n                  hasOwn(combinedObject, 'additionalProperties')\n                ) {\n                  // If combinedObject.additionalProperties === false,\n                  // do nothing (don't set key)\n                  // If additionalProperties is object, merge with new key\n                  if (isObject(combinedObject.additionalProperties)) {\n                    combinedObject[subKey] = mergeSchemas(\n                      combinedObject.additionalProperties, schemaValue[subKey]\n                    );\n                  }\n                // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) &&\n                  isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey]);\n                } else {\n                  return { allOf: [ ...schemas ] };\n                }\n              }\n              combinedSchema.properties = combinedObject;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'required':\n            // If arrays, include all items from both arrays, excluding duplicates\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.required = uniqueItems(...combinedValue, ...schemaValue);\n            // If booleans, aet true if either true\n            } else if (\n              typeof schemaValue === 'boolean' &&\n              typeof combinedValue === 'boolean'\n            ) {\n              combinedSchema.required = !!combinedValue || !!schemaValue;\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case '$schema': case '$id': case 'id':\n            // Don't combine these keys\n          break;\n          case 'title': case 'description':\n            // Return the last value, overwriting any previous one\n            // These properties are not used for validation, so conflicts don't matter\n            combinedSchema[key] = schemaValue;\n          break;\n          case 'type':\n            if (\n              (isArray(schemaValue) || isString(schemaValue)) &&\n              (isArray(combinedValue) || isString(combinedValue))\n            ) {\n              const combinedTypes = commonItems(combinedValue, schemaValue);\n              if (!combinedTypes.length) { return { allOf: [ ...schemas ] }; }\n              combinedSchema.type = combinedTypes.length > 1 ? combinedTypes : combinedTypes[0];\n            } else {\n              return { allOf: [ ...schemas ] };\n            }\n          break;\n          case 'uniqueItems':\n            // Set true if either true\n            combinedSchema.uniqueItems = !!combinedValue || !!schemaValue;\n          break;\n          default:\n            return { allOf: [ ...schemas ] };\n        }\n      }\n    }\n  }\n  return combinedSchema;\n}\n",
    "import * as _ from 'lodash';\n\nimport {\n  getType, hasValue, inArray, isArray, isEmpty, isFunction, isNumber, isObject,\n  isString\n} from './validator.functions';\nimport {\n  forEach, hasOwn, mergeFilteredObject, uniqueItems, commonItems\n} from './utility.functions';\nimport { mergeSchemas } from './merge-schemas.function';\nimport { JsonPointer, Pointer } from './jsonpointer.functions';\nimport { JsonValidators } from './json.validators';\n\n/**\n * JSON Schema function library:\n *\n * buildSchemaFromLayout:   TODO: Write this function\n *\n * buildSchemaFromData:\n *\n * getFromSchema:\n *\n * removeRecursiveReferences:\n *\n * getInputType:\n *\n * checkInlineType:\n *\n * isInputRequired:\n *\n * updateInputOptions:\n *\n * getTitleMapFromOneOf:\n *\n * getControlValidators:\n *\n * resolveSchemaReferences:\n *\n * getSubSchema:\n *\n * combineAllOf:\n *\n * fixRequiredArrayProperties:\n */\n\n/**\n * 'buildSchemaFromLayout' function\n *\n * TODO: Build a JSON Schema from a JSON Form layout\n *\n * @param  { any[] } layout - The JSON Form layout\n * @return { any } - The new JSON Schema\n */\nexport function buildSchemaFromLayout(layout) {\n  return;\n  // let newSchema: any = { };\n  // const walkLayout = (layoutItems: any[], callback: Function): any[] => {\n  //   let returnArray: any[] = [];\n  //   for (let layoutItem of layoutItems) {\n  //     const returnItem: any = callback(layoutItem);\n  //     if (returnItem) { returnArray = returnArray.concat(callback(layoutItem)); }\n  //     if (layoutItem.items) {\n  //       returnArray = returnArray.concat(walkLayout(layoutItem.items, callback));\n  //     }\n  //   }\n  //   return returnArray;\n  // };\n  // walkLayout(layout, layoutItem => {\n  //   let itemKey: string;\n  //   if (typeof layoutItem === 'string') {\n  //     itemKey = layoutItem;\n  //   } else if (layoutItem.key) {\n  //     itemKey = layoutItem.key;\n  //   }\n  //   if (!itemKey) { return; }\n  //   //\n  // });\n}\n\n/**\n * 'buildSchemaFromData' function\n *\n * Build a JSON Schema from a data object\n *\n * @param  { any } data - The data object\n * @param  { boolean = false } requireAllFields - Require all fields?\n * @param  { boolean = true } isRoot - is root\n * @return { any } - The new JSON Schema\n */\nexport function buildSchemaFromData(\n  data, requireAllFields = false, isRoot = true\n) {\n  const newSchema: any = {};\n  const getFieldType = (value: any): string => {\n    const fieldType = getType(value, 'strict');\n    return { integer: 'number', null: 'string' }[fieldType] || fieldType;\n  };\n  const buildSubSchema = (value) =>\n    buildSchemaFromData(value, requireAllFields, false);\n  if (isRoot) { newSchema.$schema = 'http://json-schema.org/draft-06/schema#'; }\n  newSchema.type = getFieldType(data);\n  if (newSchema.type === 'object') {\n    newSchema.properties = {};\n    if (requireAllFields) { newSchema.required = []; }\n    for (const key of Object.keys(data)) {\n      newSchema.properties[key] = buildSubSchema(data[key]);\n      if (requireAllFields) { newSchema.required.push(key); }\n    }\n  } else if (newSchema.type === 'array') {\n    newSchema.items = data.map(buildSubSchema);\n    // If all items are the same type, use an object for items instead of an array\n    if ((new Set(data.map(getFieldType))).size === 1) {\n      newSchema.items = newSchema.items.reduce((a, b) => ({ ...a, ...b }), {});\n    }\n    if (requireAllFields) { newSchema.minItems = 1; }\n  }\n  return newSchema;\n}\n\n/**\n * 'getFromSchema' function\n *\n * Uses a JSON Pointer for a value within a data object to retrieve\n * the schema for that value within schema for the data object.\n *\n * The optional third parameter can also be set to return something else:\n * 'schema' (default): the schema for the value indicated by the data pointer\n * 'parentSchema': the schema for the value's parent object or array\n * 'schemaPointer': a pointer to the value's schema within the object's schema\n * 'parentSchemaPointer': a pointer to the schema for the value's parent object or array\n *\n * @param  { any } schema - The schema to get the sub-schema from\n * @param  { Pointer } dataPointer - JSON Pointer (string or array)\n * @param  { string = 'schema' } returnType - what to return?\n * @return { any } - The located sub-schema\n */\nexport function getFromSchema(schema, dataPointer, returnType = 'schema') {\n  const dataPointerArray: any[] = JsonPointer.parse(dataPointer);\n  if (dataPointerArray === null) {\n    console.error(`getFromSchema error: Invalid JSON Pointer: ${dataPointer}`);\n    return null;\n  }\n  let subSchema = schema;\n  const schemaPointer = [];\n  const length = dataPointerArray.length;\n  if (returnType.slice(0, 6) === 'parent') { dataPointerArray.length--; }\n  for (let i = 0; i < length; ++i) {\n    const parentSchema = subSchema;\n    const key = dataPointerArray[i];\n    let subSchemaFound = false;\n    if (typeof subSchema !== 'object') {\n      console.error(`getFromSchema error: Unable to find \"${key}\" key in schema.`);\n      console.error(schema);\n      console.error(dataPointer);\n      return null;\n    }\n    if (subSchema.type === 'array' && (!isNaN(key) || key === '-')) {\n      if (hasOwn(subSchema, 'items')) {\n        if (isObject(subSchema.items)) {\n          subSchemaFound = true;\n          subSchema = subSchema.items;\n          schemaPointer.push('items');\n        } else if (isArray(subSchema.items)) {\n          if (!isNaN(key) && subSchema.items.length >= +key) {\n            subSchemaFound = true;\n            subSchema = subSchema.items[+key];\n            schemaPointer.push('items', key);\n          }\n        }\n      }\n      if (!subSchemaFound && isObject(subSchema.additionalItems)) {\n        subSchemaFound = true;\n        subSchema = subSchema.additionalItems;\n        schemaPointer.push('additionalItems');\n      } else if (subSchema.additionalItems !== false) {\n        subSchemaFound = true;\n        subSchema = { };\n        schemaPointer.push('additionalItems');\n      }\n    } else if (subSchema.type === 'object') {\n      if (isObject(subSchema.properties) && hasOwn(subSchema.properties, key)) {\n        subSchemaFound = true;\n        subSchema = subSchema.properties[key];\n        schemaPointer.push('properties', key);\n      } else if (isObject(subSchema.additionalProperties)) {\n        subSchemaFound = true;\n        subSchema = subSchema.additionalProperties;\n        schemaPointer.push('additionalProperties');\n      } else if (subSchema.additionalProperties !== false) {\n        subSchemaFound = true;\n        subSchema = { };\n        schemaPointer.push('additionalProperties');\n      }\n    }\n    if (!subSchemaFound) {\n      console.error(`getFromSchema error: Unable to find \"${key}\" item in schema.`);\n      console.error(schema);\n      console.error(dataPointer);\n      return;\n    }\n  }\n  return returnType.slice(-7) === 'Pointer' ? schemaPointer : subSchema;\n}\n\n/**\n * 'removeRecursiveReferences' function\n *\n * Checks a JSON Pointer against a map of recursive references and returns\n * a JSON Pointer to the shallowest equivalent location in the same object.\n *\n * Using this functions enables an object to be constructed with unlimited\n * recursion, while maintaing a fixed set of metadata, such as field data types.\n * The object can grow as large as it wants, and deeply recursed nodes can\n * just refer to the metadata for their shallow equivalents, instead of having\n * to add additional redundant metadata for each recursively added node.\n *\n * Example:\n *\n * pointer:         '/stuff/and/more/and/more/and/more/and/more/stuff'\n * recursiveRefMap: [['/stuff/and/more/and/more', '/stuff/and/more/']]\n * returned:        '/stuff/and/more/stuff'\n *\n * @param  { Pointer } pointer -\n * @param  { Map<string, string> } recursiveRefMap -\n * @param  { Map<string, number> = new Map() } arrayMap - optional\n * @return { string } -\n */\nexport function removeRecursiveReferences(\n  pointer, recursiveRefMap, arrayMap = new Map()\n) {\n  if (!pointer) { return ''; }\n  let genericPointer =\n    JsonPointer.toGenericPointer(JsonPointer.compile(pointer), arrayMap);\n  if (genericPointer.indexOf('/') === -1) { return genericPointer; }\n  let possibleReferences = true;\n  while (possibleReferences) {\n    possibleReferences = false;\n    recursiveRefMap.forEach((toPointer, fromPointer) => {\n      if (JsonPointer.isSubPointer(toPointer, fromPointer)) {\n        while (JsonPointer.isSubPointer(fromPointer, genericPointer, true)) {\n          genericPointer = JsonPointer.toGenericPointer(\n            toPointer + genericPointer.slice(fromPointer.length), arrayMap\n          );\n          possibleReferences = true;\n        }\n      }\n    });\n  }\n  return genericPointer;\n}\n\n/**\n * 'getInputType' function\n *\n * @param  { any } schema\n * @param  { any = null } layoutNode\n * @return { string }\n */\nexport function getInputType(schema, layoutNode: any = null) {\n  // x-schema-form = Angular Schema Form compatibility\n  // widget & component = React Jsonschema Form compatibility\n  const controlType = JsonPointer.getFirst([\n    [schema, '/x-schema-form/type'],\n    [schema, '/x-schema-form/widget/component'],\n    [schema, '/x-schema-form/widget'],\n    [schema, '/widget/component'],\n    [schema, '/widget']\n  ]);\n  if (isString(controlType)) { return checkInlineType(controlType, schema, layoutNode); }\n  let schemaType = schema.type;\n  if (schemaType) {\n    if (isArray(schemaType)) { // If multiple types listed, use most inclusive type\n      schemaType =\n        inArray('object', schemaType) && hasOwn(schema, 'properties') ? 'object' :\n        inArray('array', schemaType) && hasOwn(schema, 'items') ? 'array' :\n        inArray('array', schemaType) && hasOwn(schema, 'additionalItems') ? 'array' :\n        inArray('string', schemaType) ? 'string' :\n        inArray('number', schemaType) ? 'number' :\n        inArray('integer', schemaType) ? 'integer' :\n        inArray('boolean', schemaType) ? 'boolean' : 'unknown';\n    }\n    if (schemaType === 'boolean') { return 'checkbox'; }\n    if (schemaType === 'object') {\n      if (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) {\n        return 'section';\n      }\n      // TODO: Figure out how to handle additionalProperties\n      if (hasOwn(schema, '$ref')) { return '$ref'; }\n    }\n    if (schemaType === 'array') {\n      const itemsObject = JsonPointer.getFirst([\n        [schema, '/items'],\n        [schema, '/additionalItems']\n      ]) || {};\n      return hasOwn(itemsObject, 'enum') && schema.maxItems !== 1 ?\n        checkInlineType('checkboxes', schema, layoutNode) : 'array';\n    }\n    if (schemaType === 'null') { return 'none'; }\n    if (JsonPointer.has(layoutNode, '/options/titleMap') ||\n      hasOwn(schema, 'enum') || getTitleMapFromOneOf(schema, null, true)\n    ) { return 'select'; }\n    if (schemaType === 'number' || schemaType === 'integer') {\n      return (schemaType === 'integer' || hasOwn(schema, 'multipleOf')) &&\n        hasOwn(schema, 'maximum') && hasOwn(schema, 'minimum') ? 'range' : schemaType;\n    }\n    if (schemaType === 'string') {\n      return {\n        'color': 'color',\n        'date': 'date',\n        'date-time': 'datetime-local',\n        'email': 'email',\n        'uri': 'url',\n      }[schema.format] || 'text';\n    }\n  }\n  if (hasOwn(schema, '$ref')) { return '$ref'; }\n  if (isArray(schema.oneOf) || isArray(schema.anyOf)) { return 'one-of'; }\n  console.error(`getInputType error: Unable to determine input type for ${schemaType}`);\n  console.error('schema', schema);\n  if (layoutNode) { console.error('layoutNode', layoutNode); }\n  return 'none';\n}\n\n/**\n * 'checkInlineType' function\n *\n * Checks layout and schema nodes for 'inline: true', and converts\n * 'radios' or 'checkboxes' to 'radios-inline' or 'checkboxes-inline'\n *\n * @param  { string } controlType -\n * @param  { any } schema -\n * @param  { any = null } layoutNode -\n * @return { string }\n */\nexport function checkInlineType(controlType, schema, layoutNode: any = null) {\n  if (!isString(controlType) || (\n    controlType.slice(0, 8) !== 'checkbox' && controlType.slice(0, 5) !== 'radio'\n  )) {\n    return controlType;\n  }\n  if (\n    JsonPointer.getFirst([\n      [layoutNode, '/inline'],\n      [layoutNode, '/options/inline'],\n      [schema, '/inline'],\n      [schema, '/x-schema-form/inline'],\n      [schema, '/x-schema-form/options/inline'],\n      [schema, '/x-schema-form/widget/inline'],\n      [schema, '/x-schema-form/widget/component/inline'],\n      [schema, '/x-schema-form/widget/component/options/inline'],\n      [schema, '/widget/inline'],\n      [schema, '/widget/component/inline'],\n      [schema, '/widget/component/options/inline'],\n    ]) === true\n  ) {\n    return controlType.slice(0, 5) === 'radio' ?\n      'radios-inline' : 'checkboxes-inline';\n  } else {\n    return controlType;\n  }\n}\n\n/**\n * 'isInputRequired' function\n *\n * Checks a JSON Schema to see if an item is required\n *\n * @param  { any } schema - the schema to check\n * @param  { string } schemaPointer - the pointer to the item to check\n * @return { boolean } - true if the item is required, false if not\n */\nexport function isInputRequired(schema, schemaPointer) {\n  if (!isObject(schema)) {\n    console.error('isInputRequired error: Input schema must be an object.');\n    return false;\n  }\n  const listPointerArray = JsonPointer.parse(schemaPointer);\n  if (isArray(listPointerArray)) {\n    if (!listPointerArray.length) { return schema.required === true; }\n    const keyName = listPointerArray.pop();\n    const nextToLastKey = listPointerArray[listPointerArray.length - 1];\n    if (['properties', 'additionalProperties', 'patternProperties', 'items', 'additionalItems']\n      .includes(nextToLastKey)\n    ) {\n      listPointerArray.pop();\n    }\n    const parentSchema = JsonPointer.get(schema, listPointerArray) || {};\n    if (isArray(parentSchema.required)) {\n      return parentSchema.required.includes(keyName);\n    }\n    if (parentSchema.type === 'array') {\n      return hasOwn(parentSchema, 'minItems') &&\n        isNumber(keyName) &&\n        +parentSchema.minItems > +keyName;\n    }\n  }\n  return false;\n}\n\n/**\n * 'updateInputOptions' function\n *\n * @param  { any } layoutNode\n * @param  { any } schema\n * @param  { any } jsf\n * @return { void }\n */\nexport function updateInputOptions(layoutNode, schema, jsf) {\n  if (!isObject(layoutNode) || !isObject(layoutNode.options)) { return; }\n\n  // Set all option values in layoutNode.options\n  const newOptions: any = { };\n  const fixUiKeys = key => key.slice(0, 3).toLowerCase() === 'ui:' ? key.slice(3) : key;\n  mergeFilteredObject(newOptions, jsf.formOptions.defautWidgetOptions, [], fixUiKeys);\n  [ [ JsonPointer.get(schema, '/ui:widget/options'), [] ],\n    [ JsonPointer.get(schema, '/ui:widget'), [] ],\n    [ schema, [\n      'additionalProperties', 'additionalItems', 'properties', 'items',\n      'required', 'type', 'x-schema-form', '$ref'\n    ] ],\n    [ JsonPointer.get(schema, '/x-schema-form/options'), [] ],\n    [ JsonPointer.get(schema, '/x-schema-form'), ['items', 'options'] ],\n    [ layoutNode, [\n      '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n      'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n    ] ],\n    [ layoutNode.options, [] ],\n  ].forEach(([ object, excludeKeys ]) =>\n    mergeFilteredObject(newOptions, object, excludeKeys, fixUiKeys)\n  );\n  if (!hasOwn(newOptions, 'titleMap')) {\n    let newTitleMap: any = null;\n    newTitleMap = getTitleMapFromOneOf(schema, newOptions.flatList);\n    if (newTitleMap) { newOptions.titleMap = newTitleMap; }\n    if (!hasOwn(newOptions, 'titleMap') && !hasOwn(newOptions, 'enum') && hasOwn(schema, 'items')) {\n      if (JsonPointer.has(schema, '/items/titleMap')) {\n        newOptions.titleMap = schema.items.titleMap;\n      } else if (JsonPointer.has(schema, '/items/enum')) {\n        newOptions.enum = schema.items.enum;\n        if (!hasOwn(newOptions, 'enumNames') && JsonPointer.has(schema, '/items/enumNames')) {\n          newOptions.enumNames = schema.items.enumNames;\n        }\n      } else if (JsonPointer.has(schema, '/items/oneOf')) {\n        newTitleMap = getTitleMapFromOneOf(schema.items, newOptions.flatList);\n        if (newTitleMap) { newOptions.titleMap = newTitleMap; }\n      }\n    }\n  }\n\n  // If schema type is integer, enforce by setting multipleOf = 1\n  if (schema.type === 'integer' && !hasValue(newOptions.multipleOf)) {\n    newOptions.multipleOf = 1;\n  }\n\n  // Copy any typeahead word lists to options.typeahead.source\n  if (JsonPointer.has(newOptions, '/autocomplete/source')) {\n    newOptions.typeahead = newOptions.autocomplete;\n  } else if (JsonPointer.has(newOptions, '/tagsinput/source')) {\n    newOptions.typeahead = newOptions.tagsinput;\n  } else if (JsonPointer.has(newOptions, '/tagsinput/typeahead/source')) {\n    newOptions.typeahead = newOptions.tagsinput.typeahead;\n  }\n\n  layoutNode.options = newOptions;\n}\n\n/**\n * 'getTitleMapFromOneOf' function\n *\n * @param  { schema } schema\n * @param  { boolean = null } flatList\n * @param  { boolean = false } validateOnly\n * @return { validators }\n */\nexport function getTitleMapFromOneOf(\n  schema: any = {}, flatList: boolean = null, validateOnly = false\n) {\n  let titleMap = null;\n  const oneOf = schema.oneOf || schema.anyOf || null;\n  if (isArray(oneOf) && oneOf.every(item => item.title)) {\n    if (oneOf.every(item => isArray(item.enum) && item.enum.length === 1)) {\n      if (validateOnly) { return true; }\n      titleMap = oneOf.map(item => ({ name: item.title, value: item.enum[0] }));\n    } else if (oneOf.every(item => item.const)) {\n      if (validateOnly) { return true; }\n      titleMap = oneOf.map(item => ({ name: item.title, value: item.const }));\n    }\n\n    // if flatList !== false and some items have colons, make grouped map\n    if (flatList !== false && (titleMap || [])\n      .filter(title => ((title || {}).name || '').indexOf(': ')).length > 1\n    ) {\n\n      // Split name on first colon to create grouped map (name -> group: name)\n      const newTitleMap = titleMap.map(title => {\n        const [group, name] = title.name.split(/: (.+)/);\n        return group && name ? { ...title, group, name } : title;\n      });\n\n      // If flatList === true or at least one group has multiple items, use grouped map\n      if (flatList === true || newTitleMap.some((title, index) => index &&\n        hasOwn(title, 'group') && title.group === newTitleMap[index - 1].group\n      )) {\n        titleMap = newTitleMap;\n      }\n    }\n  }\n  return validateOnly ? false : titleMap;\n}\n\n/**\n * 'getControlValidators' function\n *\n * @param { any } schema\n * @return { validators }\n */\nexport function getControlValidators(schema) {\n  if (!isObject(schema)) { return null; }\n  const validators: any = { };\n  if (hasOwn(schema, 'type')) {\n    switch (schema.type) {\n      case 'string':\n        forEach(['pattern', 'format', 'minLength', 'maxLength'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'number': case 'integer':\n        forEach(['Minimum', 'Maximum'], (ucLimit) => {\n          const eLimit = 'exclusive' + ucLimit;\n          const limit = ucLimit.toLowerCase();\n          if (hasOwn(schema, limit)) {\n            const exclusive = hasOwn(schema, eLimit) && schema[eLimit] === true;\n            validators[limit] = [schema[limit], exclusive];\n          }\n        });\n        forEach(['multipleOf', 'type'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'object':\n        forEach(['minProperties', 'maxProperties', 'dependencies'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n      case 'array':\n        forEach(['minItems', 'maxItems', 'uniqueItems'], (prop) => {\n          if (hasOwn(schema, prop)) { validators[prop] = [schema[prop]]; }\n        });\n      break;\n    }\n  }\n  if (hasOwn(schema, 'enum')) { validators.enum = [schema.enum]; }\n  return validators;\n}\n\n/**\n * 'resolveSchemaReferences' function\n *\n * Find all $ref links in schema and save links and referenced schemas in\n * schemaRefLibrary, schemaRecursiveRefMap, and dataRecursiveRefMap\n *\n * @param { any } schema\n * @param { any } schemaRefLibrary\n * @param { Map<string, string> } schemaRecursiveRefMap\n * @param { Map<string, string> } dataRecursiveRefMap\n * @param { Map<string, number> } arrayMap\n * @return { any }\n */\nexport function resolveSchemaReferences(\n  schema, schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, arrayMap\n) {\n  if (!isObject(schema)) {\n    console.error('resolveSchemaReferences error: schema must be an object.');\n    return;\n  }\n  const refLinks = new Set<string>();\n  const refMapSet = new Set<string>();\n  const refMap = new Map<string, string>();\n  const recursiveRefMap = new Map<string, string>();\n  const refLibrary: any = {};\n\n  // Search schema for all $ref links, and build full refLibrary\n  JsonPointer.forEachDeep(schema, (subSchema, subSchemaPointer) => {\n    if (hasOwn(subSchema, '$ref') && isString(subSchema['$ref'])) {\n      const refPointer = JsonPointer.compile(subSchema['$ref']);\n      refLinks.add(refPointer);\n      refMapSet.add(subSchemaPointer + '~~' + refPointer);\n      refMap.set(subSchemaPointer, refPointer);\n    }\n  });\n  refLinks.forEach(ref => refLibrary[ref] = getSubSchema(schema, ref));\n\n  // Follow all ref links and save in refMapSet,\n  // to find any multi-link recursive refernces\n  let checkRefLinks = true;\n  while (checkRefLinks) {\n    checkRefLinks = false;\n    Array.from(refMap).forEach(([fromRef1, toRef1]) => Array.from(refMap)\n      .filter(([fromRef2, toRef2]) =>\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef2, toRef1, true) &&\n        !refMapSet.has(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2)\n      )\n      .forEach(([fromRef2, toRef2]) => {\n        refMapSet.add(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2);\n        checkRefLinks = true;\n      })\n    );\n  }\n\n  // Build full recursiveRefMap\n  // First pass - save all internally recursive refs from refMapSet\n  Array.from(refMapSet)\n    .map(refLink => refLink.split('~~'))\n    .filter(([fromRef, toRef]) => JsonPointer.isSubPointer(toRef, fromRef))\n    .forEach(([fromRef, toRef]) => recursiveRefMap.set(fromRef, toRef));\n  // Second pass - create recursive versions of any other refs that link to recursive refs\n  Array.from(refMap)\n    .filter(([fromRef1, toRef1]) => Array.from(recursiveRefMap.keys())\n      .every(fromRef2 => !JsonPointer.isSubPointer(fromRef1, fromRef2, true))\n    )\n    .forEach(([fromRef1, toRef1]) => Array.from(recursiveRefMap)\n      .filter(([fromRef2, toRef2]) =>\n        !recursiveRefMap.has(fromRef1 + fromRef2.slice(toRef1.length)) &&\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef1, fromRef1, true)\n      )\n      .forEach(([fromRef2, toRef2]) => recursiveRefMap.set(\n        fromRef1 + fromRef2.slice(toRef1.length),\n        fromRef1 + toRef2.slice(toRef1.length)\n      ))\n    );\n\n  // Create compiled schema by replacing all non-recursive $ref links with\n  // thieir linked schemas and, where possible, combining schemas in allOf arrays.\n  let compiledSchema = { ...schema };\n  delete compiledSchema.definitions;\n  compiledSchema =\n    getSubSchema(compiledSchema, '', refLibrary, recursiveRefMap);\n\n  // Make sure all remaining schema $refs are recursive, and build final\n  // schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap\n  JsonPointer.forEachDeep(compiledSchema, (subSchema, subSchemaPointer) => {\n    if (isString(subSchema['$ref'])) {\n      let refPointer = JsonPointer.compile(subSchema['$ref']);\n      if (!JsonPointer.isSubPointer(refPointer, subSchemaPointer, true)) {\n        refPointer = removeRecursiveReferences(subSchemaPointer, recursiveRefMap);\n        JsonPointer.set(compiledSchema, subSchemaPointer, { $ref: `#${refPointer}` });\n      }\n      if (!hasOwn(schemaRefLibrary, 'refPointer')) {\n        schemaRefLibrary[refPointer] = !refPointer.length ? compiledSchema :\n          getSubSchema(compiledSchema, refPointer, schemaRefLibrary, recursiveRefMap);\n      }\n      if (!schemaRecursiveRefMap.has(subSchemaPointer)) {\n        schemaRecursiveRefMap.set(subSchemaPointer, refPointer);\n      }\n      const fromDataRef = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);\n      if (!dataRecursiveRefMap.has(fromDataRef)) {\n        const toDataRef = JsonPointer.toDataPointer(refPointer, compiledSchema);\n        dataRecursiveRefMap.set(fromDataRef, toDataRef);\n      }\n    }\n    if (subSchema.type === 'array' &&\n      (hasOwn(subSchema, 'items') || hasOwn(subSchema, 'additionalItems'))\n    ) {\n      const dataPointer = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema);\n      if (!arrayMap.has(dataPointer)) {\n        const tupleItems = isArray(subSchema.items) ? subSchema.items.length : 0;\n        arrayMap.set(dataPointer, tupleItems);\n      }\n    }\n  }, true);\n  return compiledSchema;\n}\n\n/**\n * 'getSubSchema' function\n *\n * @param  { any } schema\n * @param  { Pointer } pointer\n * @param  { object } schemaRefLibrary\n * @param  { Map<string, string> } schemaRecursiveRefMap\n * @param  { string[] = [] } usedPointers\n * @return { any }\n */\nexport function getSubSchema(\n  schema, pointer, schemaRefLibrary = null,\n  schemaRecursiveRefMap: Map<string, string> = null, usedPointers: string[] = []\n) {\n  if (!schemaRefLibrary || !schemaRecursiveRefMap) {\n    return JsonPointer.getCopy(schema, pointer);\n  }\n  if (typeof pointer !== 'string') { pointer = JsonPointer.compile(pointer); }\n  usedPointers = [ ...usedPointers, pointer ];\n  let newSchema: any = null;\n  if (pointer === '') {\n    newSchema = _.cloneDeep(schema);\n  } else {\n    const shortPointer = removeRecursiveReferences(pointer, schemaRecursiveRefMap);\n    if (shortPointer !== pointer) { usedPointers = [ ...usedPointers, shortPointer ]; }\n    newSchema = JsonPointer.getFirstCopy([\n      [schemaRefLibrary, [shortPointer]],\n      [schema, pointer],\n      [schema, shortPointer]\n    ]);\n  }\n  return JsonPointer.forEachDeepCopy(newSchema, (subSchema, subPointer) => {\n    if (isObject(subSchema)) {\n\n      // Replace non-recursive $ref links with referenced schemas\n      if (isString(subSchema.$ref)) {\n        const refPointer = JsonPointer.compile(subSchema.$ref);\n        if (refPointer.length && usedPointers.every(ptr =>\n          !JsonPointer.isSubPointer(refPointer, ptr, true)\n        )) {\n          const refSchema = getSubSchema(\n            schema, refPointer, schemaRefLibrary, schemaRecursiveRefMap, usedPointers\n          );\n          if (Object.keys(subSchema).length === 1) {\n            return refSchema;\n          } else {\n            const extraKeys = { ...subSchema };\n            delete extraKeys.$ref;\n            return mergeSchemas(refSchema, extraKeys);\n          }\n        }\n      }\n\n      // TODO: Convert schemas with 'type' arrays to 'oneOf'\n\n      // Combine allOf subSchemas\n      if (isArray(subSchema.allOf)) { return combineAllOf(subSchema); }\n\n      // Fix incorrectly placed array object required lists\n      if (subSchema.type === 'array' && isArray(subSchema.required)) {\n        return fixRequiredArrayProperties(subSchema);\n      }\n    }\n    return subSchema;\n  }, true, <string>pointer);\n}\n\n/**\n * 'combineAllOf' function\n *\n * Attempt to convert an allOf schema object into\n * a non-allOf schema object with equivalent rules.\n *\n * @param  { any } schema - allOf schema object\n * @return { any } - converted schema object\n */\nexport function combineAllOf(schema) {\n  if (!isObject(schema) || !isArray(schema.allOf)) { return schema; }\n  let mergedSchema = mergeSchemas(...schema.allOf);\n  if (Object.keys(schema).length > 1) {\n    const extraKeys = { ...schema };\n    delete extraKeys.allOf;\n    mergedSchema = mergeSchemas(mergedSchema, extraKeys);\n  }\n  return mergedSchema;\n}\n\n/**\n * 'fixRequiredArrayProperties' function\n *\n * Fixes an incorrectly placed required list inside an array schema, by moving\n * it into items.properties or additionalItems.properties, where it belongs.\n *\n * @param  { any } schema - allOf schema object\n * @return { any } - converted schema object\n */\nexport function fixRequiredArrayProperties(schema) {\n  if (schema.type === 'array' && isArray(schema.required)) {\n    const itemsObject = hasOwn(schema.items, 'properties') ? 'items' :\n      hasOwn(schema.additionalItems, 'properties') ? 'additionalItems' : null;\n    if (itemsObject && !hasOwn(schema[itemsObject], 'required') && (\n      hasOwn(schema[itemsObject], 'additionalProperties') ||\n      schema.required.every(key => hasOwn(schema[itemsObject].properties, key))\n    )) {\n      schema = _.cloneDeep(schema);\n      schema[itemsObject].required = schema.required;\n      delete schema.required;\n    }\n  }\n  return schema;\n}\n",
    "import * as _ from 'lodash';\n\n/**\n * 'convertSchemaToDraft6' function\n *\n * Converts a JSON Schema from draft 1 through 4 format to draft 6 format\n *\n * Inspired by on geraintluff's JSON Schema 3 to 4 compatibility function:\n *   https://github.com/geraintluff/json-schema-compatibility\n * Also uses suggestions from AJV's JSON Schema 4 to 6 migration guide:\n *   https://github.com/epoberezkin/ajv/releases/tag/5.0.0\n * And additional details from the official JSON Schema documentation:\n *   http://json-schema.org\n *\n * @param  { object } originalSchema - JSON schema (draft 1, 2, 3, 4, or 6)\n * @param  { OptionObject = {} } options - options: parent schema changed?, schema draft number?\n * @return { object } - JSON schema (draft 6)\n */\nexport interface OptionObject { changed?: boolean; draft?: number; }\nexport function convertSchemaToDraft6(schema, options: OptionObject = {}) {\n  let draft: number = options.draft || null;\n  let changed: boolean = options.changed || false;\n\n  if (typeof schema !== 'object') { return schema; }\n  if (typeof schema.map === 'function') {\n    return [ ...schema.map(subSchema => convertSchemaToDraft6(subSchema, { changed, draft })) ];\n  }\n  let newSchema = { ...schema };\n  const simpleTypes = ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string'];\n\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0\\d\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    draft = newSchema.$schema[30];\n  }\n\n  // Convert v1-v2 'contentEncoding' to 'media.binaryEncoding'\n  // Note: This is only used in JSON hyper-schema (not regular JSON schema)\n  if (newSchema.contentEncoding) {\n    newSchema.media = { binaryEncoding: newSchema.contentEncoding };\n    delete newSchema.contentEncoding;\n    changed = true;\n  }\n\n  // Convert v1-v3 'extends' to 'allOf'\n  if (typeof newSchema.extends === 'object') {\n    newSchema.allOf = typeof newSchema.extends.map === 'function' ?\n      newSchema.extends.map(subSchema => convertSchemaToDraft6(subSchema, { changed, draft })) :\n      [ convertSchemaToDraft6(newSchema.extends, { changed, draft }) ];\n    delete newSchema.extends;\n    changed = true;\n  }\n\n  // Convert v1-v3 'disallow' to 'not'\n  if (newSchema.disallow) {\n    if (typeof newSchema.disallow === 'string') {\n      newSchema.not = { type: newSchema.disallow };\n    } else if (typeof newSchema.disallow.map === 'function') {\n      newSchema.not = {\n        anyOf: newSchema.disallow\n          .map(type => typeof type === 'object' ? type : { type })\n      };\n    }\n    delete newSchema.disallow;\n    changed = true;\n  }\n\n  // Convert v3 string 'dependencies' properties to arrays\n  if (typeof newSchema.dependencies === 'object' &&\n    Object.keys(newSchema.dependencies)\n      .some(key => typeof newSchema.dependencies[key] === 'string')\n  ) {\n    newSchema.dependencies = { ...newSchema.dependencies };\n    Object.keys(newSchema.dependencies)\n      .filter(key => typeof newSchema.dependencies[key] === 'string')\n      .forEach(key => newSchema.dependencies[key] = [ newSchema.dependencies[key] ]);\n    changed = true;\n  }\n\n  // Convert v1 'maxDecimal' to 'multipleOf'\n  if (typeof newSchema.maxDecimal === 'number') {\n    newSchema.multipleOf = 1 / Math.pow(10, newSchema.maxDecimal);\n    delete newSchema.divisibleBy;\n    changed = true;\n    if (!draft || draft === 2) { draft = 1; }\n  }\n\n  // Convert v2-v3 'divisibleBy' to 'multipleOf'\n  if (typeof newSchema.divisibleBy === 'number') {\n    newSchema.multipleOf = newSchema.divisibleBy;\n    delete newSchema.divisibleBy;\n    changed = true;\n  }\n\n  // Convert v1-v2 boolean 'minimumCanEqual' to 'exclusiveMinimum'\n  if (typeof newSchema.minimum === 'number' && newSchema.minimumCanEqual === false) {\n    newSchema.exclusiveMinimum = newSchema.minimum;\n    delete newSchema.minimum;\n    changed = true;\n    if (!draft) { draft = 2; }\n  } else if (typeof newSchema.minimumCanEqual === 'boolean') {\n    delete newSchema.minimumCanEqual;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMinimum' to numeric\n  if (typeof newSchema.minimum === 'number' && newSchema.exclusiveMinimum === true) {\n    newSchema.exclusiveMinimum = newSchema.minimum;\n    delete newSchema.minimum;\n    changed = true;\n  } else if (typeof newSchema.exclusiveMinimum === 'boolean') {\n    delete newSchema.exclusiveMinimum;\n    changed = true;\n  }\n\n  // Convert v1-v2 boolean 'maximumCanEqual' to 'exclusiveMaximum'\n  if (typeof newSchema.maximum === 'number' && newSchema.maximumCanEqual === false) {\n    newSchema.exclusiveMaximum = newSchema.maximum;\n    delete newSchema.maximum;\n    changed = true;\n    if (!draft) { draft = 2; }\n  } else if (typeof newSchema.maximumCanEqual === 'boolean') {\n    delete newSchema.maximumCanEqual;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMaximum' to numeric\n  if (typeof newSchema.maximum === 'number' && newSchema.exclusiveMaximum === true) {\n    newSchema.exclusiveMaximum = newSchema.maximum;\n    delete newSchema.maximum;\n    changed = true;\n  } else if (typeof newSchema.exclusiveMaximum === 'boolean') {\n    delete newSchema.exclusiveMaximum;\n    changed = true;\n  }\n\n  // Search object 'properties' for 'optional', 'required', and 'requires' items,\n  // and convert them into object 'required' arrays and 'dependencies' objects\n  if (typeof newSchema.properties === 'object') {\n    const properties = { ...newSchema.properties };\n    const requiredKeys = Array.isArray(newSchema.required) ?\n      new Set(newSchema.required) : new Set();\n\n    // Convert v1-v2 boolean 'optional' properties to 'required' array\n    if (draft === 1 || draft === 2 ||\n      Object.keys(properties).some(key => properties[key].optional === true)\n    ) {\n      Object.keys(properties)\n        .filter(key => properties[key].optional !== true)\n        .forEach(key => requiredKeys.add(key));\n      changed = true;\n      if (!draft) { draft = 2; }\n    }\n\n    // Convert v3 boolean 'required' properties to 'required' array\n    if (Object.keys(properties).some(key => properties[key].required === true)) {\n      Object.keys(properties)\n        .filter(key => properties[key].required === true)\n        .forEach(key => requiredKeys.add(key));\n      changed = true;\n    }\n\n    if (requiredKeys.size) { newSchema.required = Array.from(requiredKeys); }\n\n    // Convert v1-v2 array or string 'requires' properties to 'dependencies' object\n    if (Object.keys(properties).some(key => properties[key].requires)) {\n      const dependencies = typeof newSchema.dependencies === 'object' ?\n        { ...newSchema.dependencies } : {};\n      Object.keys(properties)\n        .filter(key => properties[key].requires)\n        .forEach(key => dependencies[key] =\n          typeof properties[key].requires === 'string' ?\n            [ properties[key].requires ] : properties[key].requires\n        );\n      newSchema.dependencies = dependencies;\n      changed = true;\n      if (!draft) { draft = 2; }\n    }\n\n    newSchema.properties = properties;\n  }\n\n  // Revove v1-v2 boolean 'optional' key\n  if (typeof newSchema.optional === 'boolean') {\n    delete newSchema.optional;\n    changed = true;\n    if (!draft) { draft = 2; }\n  }\n\n  // Revove v1-v2 'requires' key\n  if (newSchema.requires) {\n    delete newSchema.requires;\n  }\n\n  // Revove v3 boolean 'required' key\n  if (typeof newSchema.required === 'boolean') {\n    delete newSchema.required;\n  }\n\n  // Convert id to $id\n  if (typeof newSchema.id === 'string' && !newSchema.$id) {\n    if (newSchema.id.slice(-1) === '#') {\n      newSchema.id = newSchema.id.slice(0, -1);\n    }\n    newSchema.$id = newSchema.id + '-CONVERTED-TO-DRAFT-06#';\n    delete newSchema.id;\n    changed = true;\n  }\n\n  // Check if v1-v3 'any' or object types will be converted\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n    !newSchema.type.every(type => simpleTypes.includes(type)) :\n    !simpleTypes.includes(newSchema.type)\n  )) {\n    changed = true;\n  }\n\n  // If schema changed, update or remove $schema identifier\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0[1-4]\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    newSchema.$schema = 'http://json-schema.org/draft-06/schema#';\n    changed = true;\n  } else if (changed && typeof newSchema.$schema === 'string') {\n    const addToDescription = 'Converted to draft 6 from ' + newSchema.$schema;\n    if (typeof newSchema.description === 'string' && newSchema.description.length) {\n      newSchema.description += '\\n' + addToDescription;\n    } else {\n      newSchema.description = addToDescription;\n    }\n    delete newSchema.$schema;\n  }\n\n  // Convert v1-v3 'any' and object types\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n    !newSchema.type.every(type => simpleTypes.includes(type)) :\n    !simpleTypes.includes(newSchema.type)\n  )) {\n    if (newSchema.type.length === 1) { newSchema.type = newSchema.type[0]; }\n    if (typeof newSchema.type === 'string') {\n      // Convert string 'any' type to array of all standard types\n      if (newSchema.type === 'any') {\n        newSchema.type = simpleTypes;\n      // Delete non-standard string type\n      } else {\n        delete newSchema.type;\n      }\n    } else if (typeof newSchema.type === 'object') {\n      if (typeof newSchema.type.every === 'function') {\n        // If array of strings, only allow standard types\n        if (newSchema.type.every(type => typeof type === 'string')) {\n          newSchema.type = newSchema.type.some(type => type === 'any') ?\n            newSchema.type = simpleTypes :\n            newSchema.type.filter(type => simpleTypes.includes(type));\n        // If type is an array with objects, convert the current schema to an 'anyOf' array\n        } else if (newSchema.type.length > 1) {\n          const arrayKeys = [ 'additionalItems', 'items', 'maxItems', 'minItems', 'uniqueItems', 'contains'];\n          const numberKeys = [ 'multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum'];\n          const objectKeys = [ 'maxProperties', 'minProperties', 'required', 'additionalProperties',\n            'properties', 'patternProperties', 'dependencies', 'propertyNames'];\n          const stringKeys = [ 'maxLength', 'minLength', 'pattern', 'format'];\n          const filterKeys = {\n            'array':   [ ...numberKeys, ...objectKeys, ...stringKeys ],\n            'integer': [  ...arrayKeys, ...objectKeys, ...stringKeys ],\n            'number':  [  ...arrayKeys, ...objectKeys, ...stringKeys ],\n            'object':  [  ...arrayKeys, ...numberKeys, ...stringKeys ],\n            'string':  [  ...arrayKeys, ...numberKeys, ...objectKeys ],\n            'all':     [  ...arrayKeys, ...numberKeys, ...objectKeys, ...stringKeys ],\n          };\n          const anyOf = [];\n          for (const type of newSchema.type) {\n            const newType = typeof type === 'string' ? { type } : { ...type };\n            Object.keys(newSchema)\n              .filter(key => !newType.hasOwnProperty(key) &&\n                ![ ...(filterKeys[newType.type] || filterKeys.all), 'type', 'default' ]\n                  .includes(key)\n              )\n              .forEach(key => newType[key] = newSchema[key]);\n            anyOf.push(newType);\n          }\n          newSchema = newSchema.hasOwnProperty('default') ?\n            { anyOf, default: newSchema.default } : { anyOf };\n        // If type is an object, merge it with the current schema\n        } else {\n          const typeSchema = newSchema.type;\n          delete newSchema.type;\n          Object.assign(newSchema, typeSchema);\n        }\n      }\n    } else {\n      delete newSchema.type;\n    }\n  }\n\n  // Convert sub schemas\n  Object.keys(newSchema)\n    .filter(key => typeof newSchema[key] === 'object')\n    .forEach(key => {\n      if (\n        [ 'definitions', 'dependencies', 'properties', 'patternProperties' ]\n          .includes(key) && typeof newSchema[key].map !== 'function'\n      ) {\n        const newKey = {};\n        Object.keys(newSchema[key]).forEach(subKey => newKey[subKey] =\n          convertSchemaToDraft6(newSchema[key][subKey], { changed, draft })\n        );\n        newSchema[key] = newKey;\n      } else if (\n        [ 'items', 'additionalItems', 'additionalProperties',\n          'allOf', 'anyOf', 'oneOf', 'not' ].includes(key)\n      ) {\n        newSchema[key] = convertSchemaToDraft6(newSchema[key], { changed, draft });\n      } else {\n        newSchema[key] = _.cloneDeep(newSchema[key]);\n      }\n    });\n\n  return newSchema;\n}\n",
    "import {\n  AbstractControl, FormArray, FormControl, FormGroup, ValidatorFn\n} from '@angular/forms';\n\nimport * as _ from 'lodash';\n\nimport {\n  hasValue, inArray, isArray, isEmpty, isDate, isObject, isDefined, isPrimitive,\n  toJavaScriptType, toSchemaType, SchemaPrimitiveType\n} from './validator.functions';\nimport { forEach, hasOwn } from './utility.functions';\nimport { Pointer, JsonPointer } from './jsonpointer.functions';\nimport { JsonValidators } from './json.validators';\nimport {\n  combineAllOf, getControlValidators, getSubSchema, removeRecursiveReferences\n} from './json-schema.functions';\n\n/**\n * FormGroup function library:\n *\n * buildFormGroupTemplate:  Builds a FormGroupTemplate from schema\n *\n * buildFormGroup:          Builds an Angular FormGroup from a FormGroupTemplate\n *\n * mergeValues:\n *\n * setRequiredFields:\n *\n * formatFormData:\n *\n * getControl:\n *\n * ---- TODO: ----\n * TODO: add buildFormGroupTemplateFromLayout function\n * buildFormGroupTemplateFromLayout: Builds a FormGroupTemplate from a form layout\n */\n\n/**\n * 'buildFormGroupTemplate' function\n *\n * Builds a template for an Angular FormGroup from a JSON Schema.\n *\n * TODO: add support for pattern properties\n * https://spacetelescope.github.io/understanding-json-schema/reference/object.html\n *\n * @param  {any} jsf -\n * @param  {any = null} nodeValue -\n * @param  {boolean = true} mapArrays -\n * @param  {string = ''} schemaPointer -\n * @param  {string = ''} dataPointer -\n * @param  {any = ''} templatePointer -\n * @return {any} -\n */\nexport function buildFormGroupTemplate(\n  jsf: any, nodeValue: any = null, setValues = true,\n  schemaPointer = '', dataPointer = '', templatePointer = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer);\n  if (setValues) {\n    if (!isDefined(nodeValue) && (\n      jsf.formOptions.setSchemaDefaults === true ||\n      (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n    )) {\n      nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');\n    }\n  } else {\n    nodeValue = null;\n  }\n  // TODO: If nodeValue still not set, check layout for default value\n  const schemaType: string | string[] = JsonPointer.get(schema, '/type');\n  const controlType =\n    (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) &&\n      schemaType === 'object' ? 'FormGroup' :\n    (hasOwn(schema, 'items') || hasOwn(schema, 'additionalItems')) &&\n      schemaType === 'array' ? 'FormArray' :\n    !schemaType && hasOwn(schema, '$ref') ? '$ref' : 'FormControl';\n  const shortDataPointer =\n    removeRecursiveReferences(dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap);\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map());\n  }\n  const nodeOptions = jsf.dataMap.get(shortDataPointer);\n  if (!nodeOptions.has('schemaType')) {\n    nodeOptions.set('schemaPointer', schemaPointer);\n    nodeOptions.set('schemaType', schema.type);\n    if (schema.format) {\n      nodeOptions.set('schemaFormat', schema.format);\n      if (!schema.type) { nodeOptions.set('schemaType', 'string'); }\n    }\n    if (controlType) {\n      nodeOptions.set('templatePointer', templatePointer);\n      nodeOptions.set('templateType', controlType);\n    }\n  }\n  let controls: any;\n  const validators = getControlValidators(schema);\n  switch (controlType) {\n\n    case 'FormGroup':\n      controls = {};\n      if (hasOwn(schema, 'ui:order') || hasOwn(schema, 'properties')) {\n        const propertyKeys = schema['ui:order'] || Object.keys(schema.properties);\n        if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n          const unnamedKeys = Object.keys(schema.properties)\n            .filter(key => !propertyKeys.includes(key));\n          for (let i = propertyKeys.length - 1; i >= 0; i--) {\n            if (propertyKeys[i] === '*') {\n              propertyKeys.splice(i, 1, ...unnamedKeys);\n            }\n          }\n        }\n        propertyKeys\n          .filter(key => hasOwn(schema.properties, key) ||\n            hasOwn(schema, 'additionalProperties')\n          )\n          .forEach(key => controls[key] = buildFormGroupTemplate(\n            jsf, JsonPointer.get(nodeValue, [<string>key]), setValues,\n            schemaPointer + (hasOwn(schema.properties, key) ?\n              '/properties/' + key : '/additionalProperties'\n            ),\n            dataPointer + '/' + key,\n            templatePointer + '/controls/' + key\n          ));\n        jsf.formOptions.fieldsRequired = setRequiredFields(schema, controls);\n      }\n      return { controlType, controls, validators };\n\n    case 'FormArray':\n      controls = [];\n      const minItems =\n        Math.max(schema.minItems || 0, nodeOptions.get('minItems') || 0);\n      const maxItems =\n        Math.min(schema.maxItems || 1000, nodeOptions.get('maxItems') || 1000);\n      let additionalItemsPointer: string = null;\n      if (isArray(schema.items)) { // 'items' is an array = tuple items\n        const tupleItems = nodeOptions.get('tupleItems') ||\n          (isArray(schema.items) ? Math.min(schema.items.length, maxItems) : 0);\n        for (let i = 0; i < tupleItems; i++) {\n          if (i < minItems) {\n            controls.push(buildFormGroupTemplate(\n              jsf, isArray(nodeValue) ? nodeValue[i] : nodeValue, setValues,\n              schemaPointer + '/items/' + i,\n              dataPointer + '/' + i,\n              templatePointer + '/controls/' + i\n            ));\n          } else {\n            const schemaRefPointer = removeRecursiveReferences(\n              schemaPointer + '/items/' + i, jsf.schemaRecursiveRefMap\n            );\n            const itemRefPointer = removeRecursiveReferences(\n              shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n            );\n            const itemRecursive = itemRefPointer !== shortDataPointer + '/' + i;\n            if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n              jsf.templateRefLibrary[itemRefPointer] = null;\n              jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n                jsf, null, setValues,\n                schemaRefPointer,\n                itemRefPointer,\n                templatePointer + '/controls/' + i\n              );\n            }\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaPointer + '/items/' + i,\n                  dataPointer + '/' + i,\n                  templatePointer + '/controls/' + i\n                ) :\n              itemRecursive ?\n                null : _.cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            );\n          }\n        }\n\n        // If 'additionalItems' is an object = additional list items (after tuple items)\n        if (schema.items.length < maxItems && isObject(schema.additionalItems)) {\n          additionalItemsPointer = schemaPointer + '/additionalItems';\n        }\n\n      // If 'items' is an object = list items only (no tuple items)\n      } else {\n        additionalItemsPointer = schemaPointer + '/items';\n      }\n\n      if (additionalItemsPointer) {\n        const schemaRefPointer = removeRecursiveReferences(\n          additionalItemsPointer, jsf.schemaRecursiveRefMap\n        );\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        const itemRecursive = itemRefPointer !== shortDataPointer + '/-';\n        if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n          jsf.templateRefLibrary[itemRefPointer] = null;\n          jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n            jsf, null, setValues,\n            schemaRefPointer,\n            itemRefPointer,\n            templatePointer + '/controls/-'\n          );\n        }\n        // const itemOptions = jsf.dataMap.get(itemRefPointer) || new Map();\n        const itemOptions = nodeOptions;\n        if (!itemRecursive || hasOwn(validators, 'required')) {\n          const arrayLength = Math.min(Math.max(\n            itemRecursive ? 0 :\n              (itemOptions.get('tupleItems') + itemOptions.get('listItems')) || 0,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), maxItems);\n          for (let i = controls.length; i < arrayLength; i++) {\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaRefPointer,\n                  dataPointer + '/-',\n                  templatePointer + '/controls/-'\n                ) :\n                itemRecursive ?\n                  null : _.cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            );\n          }\n        }\n      }\n      return { controlType, controls, validators };\n\n    case '$ref':\n      const schemaRef = JsonPointer.compile(schema.$ref);\n      const dataRef = JsonPointer.toDataPointer(schemaRef, schema);\n      const refPointer = removeRecursiveReferences(\n        dataRef, jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      if (refPointer && !hasOwn(jsf.templateRefLibrary, refPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.templateRefLibrary[refPointer] = null;\n        const newTemplate = buildFormGroupTemplate(jsf, setValues, setValues, schemaRef);\n        if (newTemplate) {\n          jsf.templateRefLibrary[refPointer] = newTemplate;\n        } else {\n          delete jsf.templateRefLibrary[refPointer];\n        }\n      }\n      return null;\n\n    case 'FormControl':\n      const value = {\n        value: setValues && isPrimitive(nodeValue) ? nodeValue : null,\n        disabled: nodeOptions.get('disabled') || false\n      };\n      return { controlType, value, validators };\n\n    default:\n      return null;\n  }\n}\n\n/**\n * 'buildFormGroup' function\n *\n * @param {any} template -\n * @return {AbstractControl}\n*/\nexport function buildFormGroup(template: any): AbstractControl {\n  const validatorFns: ValidatorFn[] = [];\n  let validatorFn: ValidatorFn = null;\n  if (hasOwn(template, 'validators')) {\n    forEach(template.validators, (parameters, validator) => {\n      if (typeof JsonValidators[validator] === 'function') {\n        validatorFns.push(JsonValidators[validator].apply(null, parameters));\n      }\n    });\n    if (validatorFns.length &&\n      inArray(template.controlType, ['FormGroup', 'FormArray'])\n    ) {\n      validatorFn = validatorFns.length > 1 ?\n        JsonValidators.compose(validatorFns) : validatorFns[0];\n    }\n  }\n  if (hasOwn(template, 'controlType')) {\n    switch (template.controlType) {\n      case 'FormGroup':\n        const groupControls: { [key: string]: AbstractControl } = {};\n        forEach(template.controls, (controls, key) => {\n          const newControl: AbstractControl = buildFormGroup(controls);\n          if (newControl) { groupControls[key] = newControl; }\n        });\n        return new FormGroup(groupControls, validatorFn);\n      case 'FormArray':\n        return new FormArray(_.filter(_.map(template.controls,\n          controls => buildFormGroup(controls)\n        )), validatorFn);\n      case 'FormControl':\n        return new FormControl(template.value, validatorFns);\n    }\n  }\n  return null;\n}\n\n/**\n * 'mergeValues' function\n *\n * @param  {any[]} ...valuesToMerge - Multiple values to merge\n * @return {any} - Merged values\n */\nexport function mergeValues(...valuesToMerge) {\n  let mergedValues: any = null;\n  for (const currentValue of valuesToMerge) {\n    if (!isEmpty(currentValue)) {\n      if (typeof currentValue === 'object' &&\n        (isEmpty(mergedValues) || typeof mergedValues !== 'object')\n      ) {\n        if (isArray(currentValue)) {\n          mergedValues = [ ...currentValue ];\n        } else if (isObject(currentValue)) {\n          mergedValues = { ...currentValue };\n        }\n      } else if (typeof currentValue !== 'object') {\n        mergedValues = currentValue;\n      } else if (isObject(mergedValues) && isObject(currentValue)) {\n        Object.assign(mergedValues, currentValue);\n      } else if (isObject(mergedValues) && isArray(currentValue)) {\n        const newValues = [];\n        for (const value of currentValue) {\n          newValues.push(mergeValues(mergedValues, value));\n        }\n        mergedValues = newValues;\n      } else if (isArray(mergedValues) && isObject(currentValue)) {\n        const newValues = [];\n        for (const value of mergedValues) {\n          newValues.push(mergeValues(value, currentValue));\n        }\n        mergedValues = newValues;\n      } else if (isArray(mergedValues) && isArray(currentValue)) {\n        const newValues = [];\n        for (let i = 0; i < Math.max(mergedValues.length, currentValue.length); i++) {\n          if (i < mergedValues.length && i < currentValue.length) {\n            newValues.push(mergeValues(mergedValues[i], currentValue[i]));\n          } else if (i < mergedValues.length) {\n            newValues.push(mergedValues[i]);\n          } else if (i < currentValue.length) {\n            newValues.push(currentValue[i]);\n          }\n        }\n        mergedValues = newValues;\n      }\n    }\n  }\n  return mergedValues;\n}\n\n/**\n * 'setRequiredFields' function\n *\n * @param {schema} schema - JSON Schema\n * @param {object} formControlTemplate - Form Control Template object\n * @return {boolean} - true if any fields have been set to required, false if not\n */\nexport function setRequiredFields(schema: any, formControlTemplate: any): boolean {\n  let fieldsRequired = false;\n  if (hasOwn(schema, 'required') && !isEmpty(schema.required)) {\n    fieldsRequired = true;\n    let requiredArray = isArray(schema.required) ? schema.required : [schema.required];\n    requiredArray = forEach(requiredArray,\n      key => JsonPointer.set(formControlTemplate, '/' + key + '/validators/required', [])\n    );\n  }\n  return fieldsRequired;\n\n  // TODO: Add support for patternProperties\n  // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#pattern-properties\n}\n\n/**\n * 'formatFormData' function\n *\n * @param {any} formData - Angular FormGroup data object\n * @param {Map<string, any>} dataMap -\n * @param {Map<string, string>} recursiveRefMap -\n * @param {Map<string, number>} arrayMap -\n * @param {boolean = false} fixErrors - if TRUE, tries to fix data\n * @return {any} - formatted data object\n */\nexport function formatFormData(\n  formData: any, dataMap: Map<string, any>,\n  recursiveRefMap: Map<string, string>, arrayMap: Map<string, number>,\n  returnEmptyFields = false, fixErrors = false\n): any {\n  if (formData === null || typeof formData !== 'object') { return formData; }\n  const formattedData = isArray(formData) ? [] : {};\n  JsonPointer.forEachDeep(formData, (value, dataPointer) => {\n\n    // If returnEmptyFields === true,\n    // add empty arrays and objects to all allowed keys\n    if (returnEmptyFields && isArray(value)) {\n      JsonPointer.set(formattedData, dataPointer, []);\n    } else if (returnEmptyFields && isObject(value) && !isDate(value)) {\n      JsonPointer.set(formattedData, dataPointer, {});\n    } else {\n      const genericPointer =\n        JsonPointer.has(dataMap, [dataPointer, 'schemaType']) ? dataPointer :\n          removeRecursiveReferences(dataPointer, recursiveRefMap, arrayMap);\n      if (JsonPointer.has(dataMap, [genericPointer, 'schemaType'])) {\n        const schemaType: SchemaPrimitiveType | SchemaPrimitiveType[] =\n          dataMap.get(genericPointer).get('schemaType');\n        if (schemaType === 'null') {\n          JsonPointer.set(formattedData, dataPointer, null);\n        } else if ((hasValue(value) || returnEmptyFields) &&\n          inArray(schemaType, ['string', 'integer', 'number', 'boolean'])\n        ) {\n          const newValue = (fixErrors || (value === null && returnEmptyFields)) ?\n            toSchemaType(value, schemaType) : toJavaScriptType(value, schemaType);\n          if (isDefined(newValue) || returnEmptyFields) {\n            JsonPointer.set(formattedData, dataPointer, newValue);\n          }\n\n        // If returnEmptyFields === false,\n        // only add empty arrays and objects to required keys\n        } else if (schemaType === 'object' && !returnEmptyFields) {\n          (dataMap.get(genericPointer).get('required') || []).forEach(key => {\n            const keySchemaType =\n              dataMap.get(`${genericPointer}/${key}`).get('schemaType');\n            if (keySchemaType === 'array') {\n              JsonPointer.set(formattedData, `${dataPointer}/${key}`, []);\n            } else if (keySchemaType === 'object') {\n              JsonPointer.set(formattedData, `${dataPointer}/${key}`, {});\n            }\n          });\n        }\n\n        // Finish incomplete 'date-time' entries\n        if (dataMap.get(genericPointer).get('schemaFormat') === 'date-time') {\n          // \"2000-03-14T01:59:26.535\" -> \"2000-03-14T01:59:26.535Z\" (add \"Z\")\n          if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}Z`);\n          // \"2000-03-14T01:59\" -> \"2000-03-14T01:59:00Z\" (add \":00Z\")\n          } else if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00Z`);\n          // \"2000-03-14\" -> \"2000-03-14T00:00:00Z\" (add \"T00:00:00Z\")\n          } else if (fixErrors && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00:00:00Z`);\n          }\n        }\n      } else if (typeof value !== 'object' || isDate(value) ||\n        (value === null && returnEmptyFields)\n      ) {\n        console.error('formatFormData error: ' +\n          `Schema type not found for form value at ${genericPointer}`);\n        console.error('dataMap', dataMap);\n        console.error('recursiveRefMap', recursiveRefMap);\n        console.error('genericPointer', genericPointer);\n      }\n    }\n  });\n  return formattedData;\n}\n\n/**\n * 'getControl' function\n *\n * Uses a JSON Pointer for a data object to retrieve a control from\n * an Angular formGroup or formGroup template. (Note: though a formGroup\n * template is much simpler, its basic structure is idential to a formGroup).\n *\n * If the optional third parameter 'returnGroup' is set to TRUE, the group\n * containing the control is returned, rather than the control itself.\n *\n * @param {FormGroup} formGroup - Angular FormGroup to get value from\n * @param {Pointer} dataPointer - JSON Pointer (string or array)\n * @param {boolean = false} returnGroup - If true, return group containing control\n * @return {group} - Located value (or null, if no control found)\n */\nexport function getControl(\n  formGroup: any, dataPointer: Pointer, returnGroup = false\n): any {\n  if (!isObject(formGroup) || !JsonPointer.isJsonPointer(dataPointer)) {\n    if (!JsonPointer.isJsonPointer(dataPointer)) {\n      // If dataPointer input is not a valid JSON pointer, check to\n      // see if it is instead a valid object path, using dot notaion\n      if (typeof dataPointer === 'string') {\n        const formControl = formGroup.get(dataPointer);\n        if (formControl) { return formControl; }\n      }\n      console.error(`getControl error: Invalid JSON Pointer: ${dataPointer}`);\n    }\n    if (!isObject(formGroup)) {\n      console.error(`getControl error: Invalid formGroup: ${formGroup}`);\n    }\n    return null;\n  }\n  let dataPointerArray = JsonPointer.parse(dataPointer);\n  if (returnGroup) { dataPointerArray = dataPointerArray.slice(0, -1); }\n\n  // If formGroup input is a real formGroup (not a formGroup template)\n  // try using formGroup.get() to return the control\n  if (typeof formGroup.get === 'function' &&\n    dataPointerArray.every(key => key.indexOf('.') === -1)\n  ) {\n    const formControl = formGroup.get(dataPointerArray.join('.'));\n    if (formControl) { return formControl; }\n  }\n\n  // If formGroup input is a formGroup template,\n  // or formGroup.get() failed to return the control,\n  // search the formGroup object for dataPointer's control\n  let subGroup = formGroup;\n  for (const key of dataPointerArray) {\n    if (hasOwn(subGroup, 'controls')) { subGroup = subGroup.controls; }\n    if (isArray(subGroup) && (key === '-')) {\n      subGroup = subGroup[subGroup.length - 1];\n    } else if (hasOwn(subGroup, key)) {\n      subGroup = subGroup[key];\n    } else {\n      console.error(`getControl error: Unable to find \"${key}\" item in FormGroup.`);\n      console.error(dataPointer);\n      console.error(formGroup);\n      return;\n    }\n  }\n  return subGroup;\n}\n",
    "import { BehaviorSubject } from 'rxjs-compat/BehaviorSubject';\n\nimport * as _ from 'lodash';\n\nimport { TitleMapItem } from '../json-schema-form.service';\nimport {\n  inArray, isArray, isEmpty, isNumber, isObject, isDefined, isString\n} from './validator.functions';\nimport { copy, fixTitle, forEach, hasOwn } from './utility.functions';\nimport { Pointer, JsonPointer } from './jsonpointer.functions';\nimport {\n  getFromSchema, getInputType, getSubSchema, checkInlineType, isInputRequired,\n  removeRecursiveReferences, updateInputOptions\n} from './json-schema.functions';\nimport { buildFormGroupTemplate, getControl } from './form-group.functions';\n\n/**\n * Layout function library:\n *\n * buildLayout:            Builds a complete layout from an input layout and schema\n *\n * buildLayoutFromSchema:  Builds a complete layout entirely from an input schema\n *\n * mapLayout:\n *\n * getLayoutNode:\n *\n * buildTitleMap:\n */\n\n/**\n * 'buildLayout' function\n *\n * @param  { any } jsf\n * @param  { any } widgetLibrary\n * @return { any[] }\n */\nexport function buildLayout(jsf, widgetLibrary) {\n  let hasSubmitButton = !JsonPointer.get(jsf, '/formOptions/addSubmit');\n  const formLayout = mapLayout(jsf.layout, (layoutItem, index, layoutPointer) => {\n    const currentIndex = index;\n    const newNode: any = {\n      _id: _.uniqueId(),\n      options: {},\n    };\n    if (isObject(layoutItem)) {\n      Object.assign(newNode, layoutItem);\n      Object.keys(newNode)\n        .filter(option => !inArray(option, [\n          '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n          'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n        ]))\n        .forEach(option => {\n          newNode.options[option] = newNode[option];\n          delete newNode[option];\n        });\n      if (!hasOwn(newNode, 'type') && isString(newNode.widget)) {\n        newNode.type = newNode.widget;\n        delete newNode.widget;\n      }\n      if (!hasOwn(newNode.options, 'title')) {\n        if (hasOwn(newNode.options, 'legend')) {\n          newNode.options.title = newNode.options.legend;\n          delete newNode.options.legend;\n        }\n      }\n      if (!hasOwn(newNode.options, 'validationMessages')) {\n        if (hasOwn(newNode.options, 'errorMessages')) {\n          newNode.options.validationMessages = newNode.options.errorMessages;\n          delete newNode.options.errorMessages;\n\n        // Convert Angular Schema Form (AngularJS) 'validationMessage' to\n        // Angular JSON Schema Form 'validationMessages'\n        // TV4 codes from https://github.com/geraintluff/tv4/blob/master/source/api.js\n        } else if (hasOwn(newNode.options, 'validationMessage')) {\n          if (typeof newNode.options.validationMessage === 'string') {\n            newNode.options.validationMessages = newNode.options.validationMessage;\n          } else {\n            newNode.options.validationMessages = {};\n            Object.keys(newNode.options.validationMessage).forEach(key => {\n              const code = key + '';\n              const newKey =\n                code ===  '0'  ? 'type' :\n                code ===  '1'  ? 'enum' :\n                code === '100' ? 'multipleOf' :\n                code === '101' ? 'minimum' :\n                code === '102' ? 'exclusiveMinimum' :\n                code === '103' ? 'maximum' :\n                code === '104' ? 'exclusiveMaximum' :\n                code === '200' ? 'minLength' :\n                code === '201' ? 'maxLength' :\n                code === '202' ? 'pattern' :\n                code === '300' ? 'minProperties' :\n                code === '301' ? 'maxProperties' :\n                code === '302' ? 'required' :\n                code === '304' ? 'dependencies' :\n                code === '400' ? 'minItems' :\n                code === '401' ? 'maxItems' :\n                code === '402' ? 'uniqueItems' :\n                code === '500' ? 'format' : code + '';\n              newNode.options.validationMessages[newKey] = newNode.options.validationMessage[key];\n            });\n          }\n          delete newNode.options.validationMessage;\n        }\n      }\n    } else if (JsonPointer.isJsonPointer(layoutItem)) {\n      newNode.dataPointer = layoutItem;\n    } else if (isString(layoutItem)) {\n      newNode.key = layoutItem;\n    } else {\n      console.error('buildLayout error: Form layout element not recognized:');\n      console.error(layoutItem);\n      return null;\n    }\n    let nodeSchema: any = null;\n\n    // If newNode does not have a dataPointer, try to find an equivalent\n    if (!hasOwn(newNode, 'dataPointer')) {\n\n      // If newNode has a key, change it to a dataPointer\n      if (hasOwn(newNode, 'key')) {\n        newNode.dataPointer = newNode.key === '*' ? newNode.key :\n          JsonPointer.compile(JsonPointer.parseObjectPath(newNode.key), '-');\n        delete newNode.key;\n\n      // If newNode is an array, search for dataPointer in child nodes\n      } else if (hasOwn(newNode, 'type') && newNode.type.slice(-5) === 'array') {\n        const findDataPointer = (items) => {\n          if (items === null || typeof items !== 'object') { return; }\n          if (hasOwn(items, 'dataPointer')) { return items.dataPointer; }\n          if (isArray(items.items)) {\n            for (const item of items.items) {\n              if (hasOwn(item, 'dataPointer') && item.dataPointer.indexOf('/-') !== -1) {\n                return item.dataPointer;\n              }\n              if (hasOwn(item, 'items')) {\n                const searchItem = findDataPointer(item);\n                if (searchItem) { return searchItem; }\n              }\n            }\n          }\n        };\n        const childDataPointer = findDataPointer(newNode);\n        if (childDataPointer) {\n          newNode.dataPointer =\n            childDataPointer.slice(0, childDataPointer.lastIndexOf('/-'));\n        }\n      }\n    }\n\n    if (hasOwn(newNode, 'dataPointer')) {\n      if (newNode.dataPointer === '*') {\n        return buildLayoutFromSchema(jsf, widgetLibrary, jsf.formValues);\n      }\n      const nodeValue =\n        JsonPointer.get(jsf.formValues, newNode.dataPointer.replace(/\\/-/g, '/1'));\n\n      // TODO: Create function getFormValues(jsf, dataPointer, forRefLibrary)\n      // check formOptions.setSchemaDefaults and formOptions.setLayoutDefaults\n      // then set apropriate values from initialVaues, schema, or layout\n\n      newNode.dataPointer =\n        JsonPointer.toGenericPointer(newNode.dataPointer, jsf.arrayMap);\n      const LastKey = JsonPointer.toKey(newNode.dataPointer);\n      if (!newNode.name && isString(LastKey) && LastKey !== '-') {\n        newNode.name = LastKey;\n      }\n      const shortDataPointer = removeRecursiveReferences(\n        newNode.dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      const recursive = !shortDataPointer.length ||\n        shortDataPointer !== newNode.dataPointer;\n      let schemaPointer: string;\n      if (!jsf.dataMap.has(shortDataPointer)) {\n        jsf.dataMap.set(shortDataPointer, new Map());\n      }\n      const nodeDataMap = jsf.dataMap.get(shortDataPointer);\n      if (nodeDataMap.has('schemaPointer')) {\n        schemaPointer = nodeDataMap.get('schemaPointer');\n      } else {\n        schemaPointer = JsonPointer.toSchemaPointer(shortDataPointer, jsf.schema);\n        nodeDataMap.set('schemaPointer', schemaPointer);\n      }\n      nodeDataMap.set('disabled', !!newNode.options.disabled);\n      nodeSchema = JsonPointer.get(jsf.schema, schemaPointer);\n      if (nodeSchema) {\n        if (!hasOwn(newNode, 'type')) {\n          newNode.type = getInputType(nodeSchema, newNode);\n        } else if (!widgetLibrary.hasWidget(newNode.type)) {\n          const oldWidgetType = newNode.type;\n          newNode.type = getInputType(nodeSchema, newNode);\n          console.error(`error: widget type \"${oldWidgetType}\" ` +\n            `not found in library. Replacing with \"${newNode.type}\".`);\n        } else {\n          newNode.type = checkInlineType(newNode.type, nodeSchema, newNode);\n        }\n        if (nodeSchema.type === 'object' && isArray(nodeSchema.required)) {\n          nodeDataMap.set('required', nodeSchema.required);\n        }\n        newNode.dataType =\n          nodeSchema.type || (hasOwn(nodeSchema, '$ref') ? '$ref' : null);\n        updateInputOptions(newNode, nodeSchema, jsf);\n\n        // Present checkboxes as single control, rather than array\n        if (newNode.type === 'checkboxes' && hasOwn(nodeSchema, 'items')) {\n          updateInputOptions(newNode, nodeSchema.items, jsf);\n        } else if (newNode.dataType === 'array') {\n          newNode.options.maxItems = Math.min(\n            nodeSchema.maxItems || 1000, newNode.options.maxItems || 1000\n          );\n          newNode.options.minItems = Math.max(\n            nodeSchema.minItems || 0, newNode.options.minItems || 0\n          );\n          newNode.options.listItems = Math.max(\n            newNode.options.listItems || 0, isArray(nodeValue) ? nodeValue.length : 0\n          );\n          newNode.options.tupleItems =\n            isArray(nodeSchema.items) ? nodeSchema.items.length : 0;\n          if (newNode.options.maxItems < newNode.options.tupleItems) {\n            newNode.options.tupleItems = newNode.options.maxItems;\n            newNode.options.listItems = 0;\n          } else if (newNode.options.maxItems <\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.maxItems - newNode.options.tupleItems;\n          } else if (newNode.options.minItems >\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.minItems - newNode.options.tupleItems;\n          }\n          if (!nodeDataMap.has('maxItems')) {\n            nodeDataMap.set('maxItems', newNode.options.maxItems);\n            nodeDataMap.set('minItems', newNode.options.minItems);\n            nodeDataMap.set('tupleItems', newNode.options.tupleItems);\n            nodeDataMap.set('listItems', newNode.options.listItems);\n          }\n          if (!jsf.arrayMap.has(shortDataPointer)) {\n            jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);\n          }\n        }\n        if (isInputRequired(jsf.schema, schemaPointer)) {\n          newNode.options.required = true;\n          jsf.fieldsRequired = true;\n        }\n      } else {\n        // TODO: create item in FormGroup model from layout key (?)\n        updateInputOptions(newNode, {}, jsf);\n      }\n\n      if (!newNode.options.title && !/^\\d+$/.test(newNode.name)) {\n        newNode.options.title = fixTitle(newNode.name);\n      }\n\n      if (hasOwn(newNode.options, 'copyValueTo')) {\n        if (typeof newNode.options.copyValueTo === 'string') {\n          newNode.options.copyValueTo = [newNode.options.copyValueTo];\n        }\n        if (isArray(newNode.options.copyValueTo)) {\n          newNode.options.copyValueTo = newNode.options.copyValueTo.map(item =>\n            JsonPointer.compile(JsonPointer.parseObjectPath(item), '-')\n          );\n        }\n      }\n\n      newNode.widget = widgetLibrary.getWidget(newNode.type);\n      nodeDataMap.set('inputType', newNode.type);\n      nodeDataMap.set('widget', newNode.widget);\n\n      if (newNode.dataType === 'array' &&\n        (hasOwn(newNode, 'items') || hasOwn(newNode, 'additionalItems'))\n      ) {\n        const itemRefPointer = removeRecursiveReferences(\n          newNode.dataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        if (!jsf.dataMap.has(itemRefPointer)) {\n          jsf.dataMap.set(itemRefPointer, new Map());\n        }\n        jsf.dataMap.get(itemRefPointer).set('inputType', 'section');\n\n        // Fix insufficiently nested array item groups\n        if (newNode.items.length > 1) {\n          const arrayItemGroup = [];\n          const arrayItemGroupTemplate = [];\n          let newIndex = 0;\n          for (let i = newNode.items.length - 1; i >= 0; i--) {\n            const subItem = newNode.items[i];\n            if (hasOwn(subItem, 'dataPointer') &&\n              subItem.dataPointer.slice(0, itemRefPointer.length) === itemRefPointer\n            ) {\n              const arrayItem = newNode.items.splice(i, 1)[0];\n              arrayItem.dataPointer = newNode.dataPointer + '/-' +\n                arrayItem.dataPointer.slice(itemRefPointer.length);\n              arrayItemGroup.unshift(arrayItem);\n              newIndex++;\n            } else {\n              subItem.arrayItem = true;\n              // TODO: Check schema to get arrayItemType and removable\n              subItem.arrayItemType = 'list';\n              subItem.removable = newNode.options.removable !== false;\n            }\n          }\n          if (arrayItemGroup.length) {\n            newNode.items.push({\n              _id: _.uniqueId(),\n              arrayItem: true,\n              arrayItemType: newNode.options.tupleItems > newNode.items.length ?\n                'tuple' : 'list',\n              items: arrayItemGroup,\n              options: { removable: newNode.options.removable !== false, },\n              dataPointer: newNode.dataPointer + '/-',\n              type: 'section',\n              widget: widgetLibrary.getWidget('section'),\n            });\n          }\n        } else {\n          // TODO: Fix to hndle multiple items\n          newNode.items[0].arrayItem = true;\n          if (!newNode.items[0].dataPointer) {\n            newNode.items[0].dataPointer =\n              JsonPointer.toGenericPointer(itemRefPointer, jsf.arrayMap);\n          }\n          if (!JsonPointer.has(newNode, '/items/0/options/removable')) {\n            newNode.items[0].options.removable = true;\n          }\n          if (newNode.options.orderable === false) {\n            newNode.items[0].options.orderable = false;\n          }\n          newNode.items[0].arrayItemType =\n            newNode.options.tupleItems ? 'tuple' : 'list';\n        }\n\n        if (isArray(newNode.items)) {\n          const arrayListItems =\n            newNode.items.filter(item => item.type !== '$ref').length -\n              newNode.options.tupleItems;\n          if (arrayListItems > newNode.options.listItems) {\n            newNode.options.listItems = arrayListItems;\n            nodeDataMap.set('listItems', arrayListItems);\n          }\n        }\n\n        if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n          jsf.layoutRefLibrary[itemRefPointer] =\n            _.cloneDeep(newNode.items[newNode.items.length - 1]);\n          if (recursive) {\n            jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n          }\n          forEach(jsf.layoutRefLibrary[itemRefPointer], (item, key) => {\n            if (hasOwn(item, '_id')) { item._id = null; }\n            if (recursive) {\n              if (hasOwn(item, 'dataPointer')) {\n                item.dataPointer = item.dataPointer.slice(itemRefPointer.length);\n              }\n            }\n          }, 'top-down');\n        }\n\n        // Add any additional default items\n        if (!newNode.recursiveReference || newNode.options.required) {\n          const arrayLength = Math.min(Math.max(\n            newNode.options.tupleItems + newNode.options.listItems,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), newNode.options.maxItems);\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: newNode.dataPointer,\n              recursiveReference: newNode.recursiveReference,\n            }, jsf, widgetLibrary));\n          }\n        }\n\n        // If needed, add button to add items to array\n        if (newNode.options.addable !== false &&\n          newNode.options.minItems < newNode.options.maxItems &&\n          (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n        ) {\n          let buttonText = 'Add';\n          if (newNode.options.title) {\n            if (/^add\\b/i.test(newNode.options.title)) {\n              buttonText = newNode.options.title;\n            } else {\n              buttonText += ' ' + newNode.options.title;\n            }\n          } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n            if (/^add\\b/i.test(newNode.name)) {\n              buttonText += ' ' + fixTitle(newNode.name);\n            } else {\n              buttonText = fixTitle(newNode.name);\n            }\n\n          // If newNode doesn't have a title, look for title of parent array item\n          } else {\n            const parentSchema =\n              getFromSchema(jsf.schema, newNode.dataPointer, 'parentSchema');\n            if (hasOwn(parentSchema, 'title')) {\n              buttonText += ' to ' + parentSchema.title;\n            } else {\n              const pointerArray = JsonPointer.parse(newNode.dataPointer);\n              buttonText += ' to ' + fixTitle(pointerArray[pointerArray.length - 2]);\n            }\n          }\n          newNode.items.push({\n            _id: _.uniqueId(),\n            arrayItem: true,\n            arrayItemType: 'list',\n            dataPointer: newNode.dataPointer + '/-',\n            options: {\n              listItems: newNode.options.listItems,\n              maxItems: newNode.options.maxItems,\n              minItems: newNode.options.minItems,\n              removable: false,\n              title: buttonText,\n              tupleItems: newNode.options.tupleItems,\n            },\n            recursiveReference: recursive,\n            type: '$ref',\n            widget: widgetLibrary.getWidget('$ref'),\n            $ref: itemRefPointer,\n          });\n          if (isString(JsonPointer.get(newNode, '/style/add'))) {\n            newNode.items[newNode.items.length - 1].options.fieldStyle =\n              newNode.style.add;\n            delete newNode.style.add;\n            if (isEmpty(newNode.style)) { delete newNode.style; }\n          }\n        }\n      } else {\n        newNode.arrayItem = false;\n      }\n    } else if (hasOwn(newNode, 'type') || hasOwn(newNode, 'items')) {\n      const parentType: string =\n        JsonPointer.get(jsf.layout, layoutPointer, 0, -2).type;\n      if (!hasOwn(newNode, 'type')) {\n        newNode.type =\n          inArray(parentType, ['tabs', 'tabarray']) ? 'tab' : 'array';\n      }\n      newNode.arrayItem = parentType === 'array';\n      newNode.widget = widgetLibrary.getWidget(newNode.type);\n      updateInputOptions(newNode, {}, jsf);\n    }\n    if (newNode.type === 'submit') { hasSubmitButton = true; }\n    return newNode;\n  });\n  if (jsf.hasRootReference) {\n    const fullLayout = _.cloneDeep(formLayout);\n    if (fullLayout[fullLayout.length - 1].type === 'submit') { fullLayout.pop(); }\n    jsf.layoutRefLibrary[''] = {\n      _id: null,\n      dataPointer: '',\n      dataType: 'object',\n      items: fullLayout,\n      name: '',\n      options: _.cloneDeep(jsf.formOptions.defautWidgetOptions),\n      recursiveReference: true,\n      required: false,\n      type: 'section',\n      widget: widgetLibrary.getWidget('section'),\n    };\n  }\n  if (!hasSubmitButton) {\n    formLayout.push({\n      _id: _.uniqueId(),\n      options: { title: 'Submit' },\n      type: 'submit',\n      widget: widgetLibrary.getWidget('submit'),\n    });\n  }\n  return formLayout;\n}\n\n/**\n * 'buildLayoutFromSchema' function\n *\n * @param  { any } jsf -\n * @param  { any } widgetLibrary -\n * @param  { any } nodeValue -\n * @param  { string = '' } schemaPointer -\n * @param  { string = '' } dataPointer -\n * @param  { boolean = false } arrayItem -\n * @param  { string = null } arrayItemType -\n * @param  { boolean = null } removable -\n * @param  { boolean = false } forRefLibrary -\n * @param  { string = '' } dataPointerPrefix -\n * @return { any }\n */\nexport function buildLayoutFromSchema(\n  jsf, widgetLibrary, nodeValue = null, schemaPointer = '',\n  dataPointer = '', arrayItem = false, arrayItemType: string = null,\n  removable: boolean = null, forRefLibrary = false, dataPointerPrefix = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer);\n  if (!hasOwn(schema, 'type') && !hasOwn(schema, '$ref') &&\n    !hasOwn(schema, 'x-schema-form')\n  ) { return null; }\n  const newNodeType: string = getInputType(schema);\n  if (!isDefined(nodeValue) && (\n    jsf.formOptions.setSchemaDefaults === true ||\n    (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n  )) {\n    nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default');\n  }\n  let newNode: any = {\n    _id: forRefLibrary ? null : _.uniqueId(),\n    arrayItem: arrayItem,\n    dataPointer: JsonPointer.toGenericPointer(dataPointer, jsf.arrayMap),\n    dataType: schema.type || (hasOwn(schema, '$ref') ? '$ref' : null),\n    options: {},\n    required: isInputRequired(jsf.schema, schemaPointer),\n    type: newNodeType,\n    widget: widgetLibrary.getWidget(newNodeType),\n  };\n  const lastDataKey = JsonPointer.toKey(newNode.dataPointer);\n  if (lastDataKey !== '-') { newNode.name = lastDataKey; }\n  if (newNode.arrayItem) {\n    newNode.arrayItemType = arrayItemType;\n    newNode.options.removable = removable !== false;\n  }\n  const shortDataPointer = removeRecursiveReferences(\n    dataPointerPrefix + dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n  );\n  const recursive = !shortDataPointer.length ||\n    shortDataPointer !== dataPointerPrefix + dataPointer;\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map());\n  }\n  const nodeDataMap = jsf.dataMap.get(shortDataPointer);\n  if (!nodeDataMap.has('inputType')) {\n    nodeDataMap.set('schemaPointer', schemaPointer);\n    nodeDataMap.set('inputType', newNode.type);\n    nodeDataMap.set('widget', newNode.widget);\n    nodeDataMap.set('disabled', !!newNode.options.disabled);\n  }\n  updateInputOptions(newNode, schema, jsf);\n  if (!newNode.options.title && newNode.name && !/^\\d+$/.test(newNode.name)) {\n    newNode.options.title = fixTitle(newNode.name);\n  }\n\n  if (newNode.dataType === 'object') {\n    if (isArray(schema.required) && !nodeDataMap.has('required')) {\n      nodeDataMap.set('required', schema.required);\n    }\n    if (isObject(schema.properties)) {\n      const newSection: any[] = [];\n      const propertyKeys = schema['ui:order'] || Object.keys(schema.properties);\n      if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n        const unnamedKeys = Object.keys(schema.properties)\n          .filter(key => !propertyKeys.includes(key));\n        for (let i = propertyKeys.length - 1; i >= 0; i--) {\n          if (propertyKeys[i] === '*') {\n            propertyKeys.splice(i, 1, ...unnamedKeys);\n          }\n        }\n      }\n      propertyKeys\n        .filter(key => hasOwn(schema.properties, key) ||\n          hasOwn(schema, 'additionalProperties')\n        )\n        .forEach(key => {\n          const keySchemaPointer = hasOwn(schema.properties, key) ?\n            '/properties/' + key : '/additionalProperties';\n          const innerItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isObject(nodeValue) ? nodeValue[key] : null,\n            schemaPointer + keySchemaPointer,\n            dataPointer + '/' + key,\n            false, null, null, forRefLibrary, dataPointerPrefix\n          );\n          if (innerItem) {\n            if (isInputRequired(schema, '/' + key)) {\n              innerItem.options.required = true;\n              jsf.fieldsRequired = true;\n            }\n            newSection.push(innerItem);\n          }\n        });\n      if (dataPointer === '' && !forRefLibrary) {\n        newNode = newSection;\n      } else {\n        newNode.items = newSection;\n      }\n    }\n    // TODO: Add patternProperties and additionalProperties inputs?\n    // ... possibly provide a way to enter both key names and values?\n    // if (isObject(schema.patternProperties)) { }\n    // if (isObject(schema.additionalProperties)) { }\n\n  } else if (newNode.dataType === 'array') {\n    newNode.items = [];\n    const templateArray: any[] = [];\n    newNode.options.maxItems = Math.min(\n      schema.maxItems || 1000, newNode.options.maxItems || 1000\n    );\n    newNode.options.minItems = Math.max(\n      schema.minItems || 0, newNode.options.minItems || 0\n    );\n    if (!newNode.options.minItems && isInputRequired(jsf.schema, schemaPointer)) {\n      newNode.options.minItems = 1;\n    }\n    if (!hasOwn(newNode.options, 'listItems')) { newNode.options.listItems = 1; }\n    newNode.options.tupleItems = isArray(schema.items) ? schema.items.length : 0;\n    if (newNode.options.maxItems <= newNode.options.tupleItems) {\n      newNode.options.tupleItems = newNode.options.maxItems;\n      newNode.options.listItems = 0;\n    } else if (newNode.options.maxItems <\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.maxItems - newNode.options.tupleItems;\n    } else if (newNode.options.minItems >\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.minItems - newNode.options.tupleItems;\n    }\n    if (!nodeDataMap.has('maxItems')) {\n      nodeDataMap.set('maxItems', newNode.options.maxItems);\n      nodeDataMap.set('minItems', newNode.options.minItems);\n      nodeDataMap.set('tupleItems', newNode.options.tupleItems);\n      nodeDataMap.set('listItems', newNode.options.listItems);\n    }\n    if (!jsf.arrayMap.has(shortDataPointer)) {\n      jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems);\n    }\n    removable = newNode.options.removable !== false;\n    let additionalItemsSchemaPointer: string = null;\n\n    // If 'items' is an array = tuple items\n    if (isArray(schema.items)) {\n      newNode.items = [];\n      for (let i = 0; i < newNode.options.tupleItems; i++) {\n        let newItem: any;\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n        );\n        const itemRecursive = !itemRefPointer.length ||\n          itemRefPointer !== shortDataPointer + '/' + i;\n\n        // If removable, add tuple item layout to layoutRefLibrary\n        if (removable && i >= newNode.options.minItems) {\n          if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n            // Set to null first to prevent recursive reference from causing endless loop\n            jsf.layoutRefLibrary[itemRefPointer] = null;\n            jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n              jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n              schemaPointer + '/items/' + i,\n              itemRecursive ? '' : dataPointer + '/' + i,\n              true, 'tuple', true, true, itemRecursive ? dataPointer + '/' + i : ''\n            );\n            if (itemRecursive) {\n              jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n            }\n          }\n          newItem = getLayoutNode({\n            $ref: itemRefPointer,\n            dataPointer: dataPointer + '/' + i,\n            recursiveReference: itemRecursive,\n          }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null);\n        } else {\n          newItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n            schemaPointer + '/items/' + i,\n            dataPointer + '/' + i,\n            true, 'tuple', false, forRefLibrary, dataPointerPrefix\n          );\n        }\n        if (newItem) { newNode.items.push(newItem); }\n      }\n\n      // If 'additionalItems' is an object = additional list items, after tuple items\n      if (isObject(schema.additionalItems)) {\n        additionalItemsSchemaPointer = schemaPointer + '/additionalItems';\n      }\n\n    // If 'items' is an object = list items only (no tuple items)\n    } else if (isObject(schema.items)) {\n      additionalItemsSchemaPointer = schemaPointer + '/items';\n    }\n\n    if (additionalItemsSchemaPointer) {\n      const itemRefPointer = removeRecursiveReferences(\n        shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n      );\n      const itemRecursive = !itemRefPointer.length ||\n        itemRefPointer !== shortDataPointer + '/-';\n      const itemSchemaPointer = removeRecursiveReferences(\n        additionalItemsSchemaPointer, jsf.schemaRecursiveRefMap, jsf.arrayMap\n      );\n      // Add list item layout to layoutRefLibrary\n      if (itemRefPointer.length && !hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[itemRefPointer] = null;\n        jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n          jsf, widgetLibrary, null,\n          itemSchemaPointer,\n          itemRecursive ? '' : dataPointer + '/-',\n          true, 'list', removable, true, itemRecursive ? dataPointer + '/-' : ''\n        );\n        if (itemRecursive) {\n          jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true;\n        }\n      }\n\n      // Add any additional default items\n      if (!itemRecursive || newNode.options.required) {\n        const arrayLength = Math.min(Math.max(\n          itemRecursive ? 0 :\n            newNode.options.tupleItems + newNode.options.listItems,\n          isArray(nodeValue) ? nodeValue.length : 0\n        ), newNode.options.maxItems);\n        if (newNode.items.length < arrayLength) {\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: dataPointer + '/-',\n              recursiveReference: itemRecursive,\n            }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null));\n          }\n        }\n      }\n\n      // If needed, add button to add items to array\n      if (newNode.options.addable !== false &&\n        newNode.options.minItems < newNode.options.maxItems &&\n        (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n      ) {\n        let buttonText =\n          ((jsf.layoutRefLibrary[itemRefPointer] || {}).options || {}).title;\n        const prefix = buttonText ? 'Add ' : 'Add to ';\n        if (!buttonText) {\n          buttonText = schema.title || fixTitle(JsonPointer.toKey(dataPointer));\n        }\n        if (!/^add\\b/i.test(buttonText)) { buttonText = prefix + buttonText; }\n        newNode.items.push({\n          _id: _.uniqueId(),\n          arrayItem: true,\n          arrayItemType: 'list',\n          dataPointer: newNode.dataPointer + '/-',\n          options: {\n            listItems: newNode.options.listItems,\n            maxItems: newNode.options.maxItems,\n            minItems: newNode.options.minItems,\n            removable: false,\n            title: buttonText,\n            tupleItems: newNode.options.tupleItems,\n          },\n          recursiveReference: itemRecursive,\n          type: '$ref',\n          widget: widgetLibrary.getWidget('$ref'),\n          $ref: itemRefPointer,\n        });\n      }\n    }\n\n  } else if (newNode.dataType === '$ref') {\n    const schemaRef = JsonPointer.compile(schema.$ref);\n    const dataRef = JsonPointer.toDataPointer(schemaRef, jsf.schema);\n    let buttonText = '';\n\n    // Get newNode title\n    if (newNode.options.add) {\n      buttonText = newNode.options.add;\n    } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n      buttonText =\n        (/^add\\b/i.test(newNode.name) ? '' : 'Add ') + fixTitle(newNode.name);\n\n    // If newNode doesn't have a title, look for title of parent array item\n    } else {\n      const parentSchema =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1);\n      if (hasOwn(parentSchema, 'title')) {\n        buttonText = 'Add to ' + parentSchema.title;\n      } else {\n        const pointerArray = JsonPointer.parse(newNode.dataPointer);\n        buttonText = 'Add to ' + fixTitle(pointerArray[pointerArray.length - 2]);\n      }\n    }\n    Object.assign(newNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n      $ref: dataRef,\n    });\n    Object.assign(newNode.options, {\n      removable: false,\n      title: buttonText,\n    });\n    if (isNumber(JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems)) {\n      newNode.options.maxItems =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems;\n    }\n\n    // Add layout template to layoutRefLibrary\n    if (dataRef.length) {\n      if (!hasOwn(jsf.layoutRefLibrary, dataRef)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[dataRef] = null;\n        const newLayout = buildLayoutFromSchema(\n          jsf, widgetLibrary, null, schemaRef, '',\n          newNode.arrayItem, newNode.arrayItemType, true, true, dataPointer\n        );\n        if (newLayout) {\n          newLayout.recursiveReference = true;\n          jsf.layoutRefLibrary[dataRef] = newLayout;\n        } else {\n          delete jsf.layoutRefLibrary[dataRef];\n        }\n      } else if (!jsf.layoutRefLibrary[dataRef].recursiveReference) {\n        jsf.layoutRefLibrary[dataRef].recursiveReference = true;\n      }\n    }\n  }\n  return newNode;\n}\n\n/**\n * 'mapLayout' function\n *\n * Creates a new layout by running each element in an existing layout through\n * an iteratee. Recursively maps within array elements 'items' and 'tabs'.\n * The iteratee is invoked with four arguments: (value, index, layout, path)\n *\n * The returned layout may be longer (or shorter) then the source layout.\n *\n * If an item from the source layout returns multiple items (as '*' usually will),\n * this function will keep all returned items in-line with the surrounding items.\n *\n * If an item from the source layout causes an error and returns null, it is\n * skipped without error, and the function will still return all non-null items.\n *\n * @param  { any[] } layout - the layout to map\n * @param  { (v: any, i?: number, l?: any, p?: string) => any }\n *   function - the funciton to invoke on each element\n * @param  { string|string[] = '' } layoutPointer - the layoutPointer to layout, inside rootLayout\n * @param  { any[] = layout } rootLayout - the root layout, which conatins layout\n * @return { any[] }\n */\nexport function mapLayout(layout, fn, layoutPointer = '', rootLayout = layout) {\n  let indexPad = 0;\n  let newLayout: any[] = [];\n  forEach(layout, (item, index) => {\n    const realIndex = +index + indexPad;\n    const newLayoutPointer = layoutPointer + '/' + realIndex;\n    let newNode: any = copy(item);\n    let itemsArray: any[] = [];\n    if (isObject(item)) {\n      if (hasOwn(item, 'tabs')) {\n        item.items = item.tabs;\n        delete item.tabs;\n      }\n      if (hasOwn(item, 'items')) {\n        itemsArray = isArray(item.items) ? item.items : [item.items];\n      }\n    }\n    if (itemsArray.length) {\n      newNode.items = mapLayout(itemsArray, fn, newLayoutPointer + '/items', rootLayout);\n    }\n    newNode = fn(newNode, realIndex, newLayoutPointer, rootLayout);\n    if (!isDefined(newNode)) {\n      indexPad--;\n    } else {\n      if (isArray(newNode)) { indexPad += newNode.length - 1; }\n      newLayout = newLayout.concat(newNode);\n    }\n  });\n  return newLayout;\n}\n\n/**\n * 'getLayoutNode' function\n * Copy a new layoutNode from layoutRefLibrary\n *\n * @param  { any } refNode -\n * @param  { any } layoutRefLibrary -\n * @param  { any = null } widgetLibrary -\n * @param  { any = null } nodeValue -\n * @return { any } copied layoutNode\n */\nexport function getLayoutNode(\n  refNode, jsf, widgetLibrary: any = null, nodeValue: any = null\n) {\n\n  // If recursive reference and building initial layout, return Add button\n  if (refNode.recursiveReference && widgetLibrary) {\n    const newLayoutNode = _.cloneDeep(refNode);\n    if (!newLayoutNode.options) { newLayoutNode.options = {}; }\n    Object.assign(newLayoutNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n    });\n    Object.assign(newLayoutNode.options, {\n      removable: false,\n      title: 'Add ' + newLayoutNode.$ref,\n    });\n    return newLayoutNode;\n\n  // Otherwise, return referenced layout\n} else {\n    let newLayoutNode = jsf.layoutRefLibrary[refNode.$ref];\n    // If value defined, build new node from schema (to set array lengths)\n    if (isDefined(nodeValue)) {\n      newLayoutNode = buildLayoutFromSchema(\n        jsf, widgetLibrary, nodeValue,\n        JsonPointer.toSchemaPointer(refNode.$ref, jsf.schema),\n        refNode.$ref, newLayoutNode.arrayItem,\n        newLayoutNode.arrayItemType, newLayoutNode.options.removable, false\n      );\n    } else {\n      // If value not defined, copy node from layoutRefLibrary\n      newLayoutNode = _.cloneDeep(newLayoutNode);\n      JsonPointer.forEachDeep(newLayoutNode, (subNode, pointer) => {\n\n        // Reset all _id's in newLayoutNode to unique values\n        if (hasOwn(subNode, '_id')) { subNode._id = _.uniqueId(); }\n\n        // If adding a recursive item, prefix current dataPointer\n        // to all dataPointers in new layoutNode\n        if (refNode.recursiveReference && hasOwn(subNode, 'dataPointer')) {\n          subNode.dataPointer = refNode.dataPointer + subNode.dataPointer;\n        }\n      });\n    }\n    return newLayoutNode;\n  }\n}\n\n/**\n * 'buildTitleMap' function\n *\n * @param  { any } titleMap -\n * @param  { any } enumList -\n * @param  { boolean = true } fieldRequired -\n * @param  { boolean = true } flatList -\n * @return { TitleMapItem[] }\n */\nexport function buildTitleMap(\n  titleMap, enumList, fieldRequired = true, flatList = true\n) {\n  let newTitleMap: TitleMapItem[] = [];\n  let hasEmptyValue = false;\n  if (titleMap) {\n    if (isArray(titleMap)) {\n      if (enumList) {\n        for (const i of Object.keys(titleMap)) {\n          if (isObject(titleMap[i])) { // JSON Form style\n            const value = titleMap[i].value;\n            if (enumList.includes(value)) {\n              const name = titleMap[i].name;\n              newTitleMap.push({ name, value });\n              if (value === undefined || value === null) { hasEmptyValue = true; }\n            }\n          } else if (isString(titleMap[i])) { // React Jsonschema Form style\n            if (i < enumList.length) {\n              const name = titleMap[i];\n              const value = enumList[i];\n              newTitleMap.push({ name, value });\n              if (value === undefined || value === null) { hasEmptyValue = true; }\n            }\n          }\n        }\n      } else { // If array titleMap and no enum list, just return the titleMap - Angular Schema Form style\n        newTitleMap = titleMap;\n        if (!fieldRequired) {\n          hasEmptyValue = !!newTitleMap\n            .filter(i => i.value === undefined || i.value === null)\n            .length;\n        }\n      }\n    } else if (enumList) { // Alternate JSON Form style, with enum list\n      for (const i of Object.keys(enumList)) {\n        const value = enumList[i];\n        if (hasOwn(titleMap, value)) {\n          const name = titleMap[value];\n          newTitleMap.push({ name, value });\n          if (value === undefined || value === null) { hasEmptyValue = true; }\n        }\n      }\n    } else { // Alternate JSON Form style, without enum list\n      for (const value of Object.keys(titleMap)) {\n        const name = titleMap[value];\n        newTitleMap.push({ name, value });\n        if (value === undefined || value === null) { hasEmptyValue = true; }\n      }\n    }\n  } else if (enumList) { // Build map from enum list alone\n    for (const i of Object.keys(enumList)) {\n      const name = enumList[i];\n      const value = enumList[i];\n      newTitleMap.push({ name, value});\n      if (value === undefined || value === null) { hasEmptyValue = true; }\n    }\n  } else { // If no titleMap and no enum list, return default map of boolean values\n    newTitleMap = [ { name: 'True', value: true }, { name: 'False', value: false } ];\n  }\n\n  // Does titleMap have groups?\n  if (newTitleMap.some(title => hasOwn(title, 'group'))) {\n    hasEmptyValue = false;\n\n    // If flatList = true, flatten items & update name to group: name\n    if (flatList) {\n      newTitleMap = newTitleMap.reduce((groupTitleMap, title) => {\n        if (hasOwn(title, 'group')) {\n          if (isArray(title.items)) {\n            groupTitleMap = [\n              ...groupTitleMap,\n              ...title.items.map(item =>\n                ({ ...item, ...{ name: `${title.group}: ${item.name}` } })\n              )\n            ];\n            if (title.items.some(item => item.value === undefined || item.value === null)) {\n              hasEmptyValue = true;\n            }\n          }\n          if (hasOwn(title, 'name') && hasOwn(title, 'value')) {\n            title.name = `${title.group}: ${title.name}`;\n            delete title.group;\n            groupTitleMap.push(title);\n            if (title.value === undefined || title.value === null) {\n              hasEmptyValue = true;\n            }\n          }\n        } else {\n          groupTitleMap.push(title);\n          if (title.value === undefined || title.value === null) {\n            hasEmptyValue = true;\n          }\n        }\n        return groupTitleMap;\n      }, []);\n\n    // If flatList = false, combine items from matching groups\n    } else {\n      newTitleMap = newTitleMap.reduce((groupTitleMap, title) => {\n        if (hasOwn(title, 'group')) {\n          if (title.group !== (groupTitleMap[groupTitleMap.length - 1] || {}).group) {\n            groupTitleMap.push({ group: title.group, items: title.items || [] });\n          }\n          if (hasOwn(title, 'name') && hasOwn(title, 'value')) {\n            groupTitleMap[groupTitleMap.length - 1].items\n              .push({ name: title.name, value: title.value });\n            if (title.value === undefined || title.value === null) {\n              hasEmptyValue = true;\n            }\n          }\n        } else {\n          groupTitleMap.push(title);\n          if (title.value === undefined || title.value === null) {\n            hasEmptyValue = true;\n          }\n        }\n        return groupTitleMap;\n      }, []);\n    }\n  }\n  if (!fieldRequired && !hasEmptyValue) {\n    newTitleMap.unshift({ name: '<em>None</em>', value: null });\n  }\n  return newTitleMap;\n}\n",
    "/**\n * 'dateToString' function\n *\n * @param  { Date | string } date\n * @param  { any } options\n * @return { string }\n */\nexport function dateToString(date, options: any = {}) {\n  const dateFormat = options.dateFormat || 'YYYY-MM-DD';\n  // TODO: Use options.locale to change default format and names\n  // const locale = options.locale || 'en-US';\n  if (typeof date === 'string') { date = stringToDate(date); }\n  if (Object.prototype.toString.call(date) !== '[object Date]') { return null; }\n  const longMonths = ['January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'];\n  const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];\n  const longDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n  return dateFormat\n    .replace(/YYYY/ig, date.getFullYear() + '')\n    .replace(/YY/ig, (date.getFullYear() + '').slice(-2))\n    .replace(/MMMM/ig, longMonths[date.getMonth()])\n    .replace(/MMM/ig, shortMonths[date.getMonth()])\n    .replace(/MM/ig, ('0' + (date.getMonth() + 1)).slice(-2))\n    .replace(/M/ig, (date.getMonth() + 1) + '')\n    .replace(/DDDD/ig, longDays[date.getDay()])\n    .replace(/DDD/ig, shortDays[date.getDay()])\n    .replace(/DD/ig, ('0' + date.getDate()).slice(-2))\n    .replace(/D/ig, date.getDate() + '')\n    .replace(/S/ig, ordinal(date.getDate()));\n}\n\nexport function ordinal(number: number|string): string {\n  if (typeof number === 'number') { number = number + ''; }\n  const last = number.slice(-1);\n  const nextToLast = number.slice(-2, 1);\n  return (nextToLast !== '1' && { '1': 'st', '2': 'nd', '3': 'rd' }[last]) || 'th';\n}\n\n/**\n * 'stringToDate' function\n *\n * @param  { string } dateString\n * @return { Date }\n */\nexport function stringToDate(dateString) {\n  const getDate: string = findDate(dateString);\n  if (!getDate) { return null; }\n  let dateParts: number[] = [];\n  // Split x-y-z to [x, y, z]\n  if (/^\\d+[^\\d]\\d+[^\\d]\\d+$/.test(getDate)) {\n    dateParts = getDate.split(/[^\\d]/).map(part => +part);\n  // Split xxxxyyzz to [xxxx, yy, zz]\n  } else if (/^\\d{8}$/.test(getDate)) {\n    dateParts = [+getDate.slice(0, 4), +getDate.slice(4, 6), +getDate.slice(6)];\n  }\n  const thisYear = +(new Date().getFullYear() + '').slice(-2);\n  // Check for [YYYY, MM, DD]\n  if (dateParts[0] > 1000 && dateParts[0] < 2100 && dateParts[1] <= 12 && dateParts[2] <= 31) {\n    return new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);\n  // Check for [MM, DD, YYYY]\n  } else if (dateParts[0] <= 12 && dateParts[1] <= 31 && dateParts[2] > 1000 && dateParts[2] < 2100) {\n    return new Date(dateParts[2], dateParts[0] - 1, dateParts[1]);\n  // Check for [MM, DD, YY]\n  } else if (dateParts[0] <= 12 && dateParts[1] <= 31 && dateParts[2] < 100) {\n    const year = (dateParts[2] <= thisYear ? 2000 : 1900) + dateParts[2];\n    return new Date(year, dateParts[0] - 1, dateParts[1]);\n  // Check for [YY, MM, DD]\n  } else if (dateParts[0] < 100 && dateParts[1] <= 12 && dateParts[2] <= 31) {\n    const year = (dateParts[0] <= thisYear ? 2000 : 1900) + dateParts[0];\n    return new Date(year, dateParts[1] - 1, dateParts[2]);\n  }\n  return null;\n}\n\n/**\n * 'findDate' function\n *\n * @param  { string } text\n * @return { string }\n */\nexport function findDate(text) {\n  if (!text) { return null; }\n  let foundDate: any[];\n  // Match ...YYYY-MM-DD...\n  foundDate = text.match(/(?:19|20)\\d\\d[-_\\\\\\/\\. ](?:0?\\d|1[012])[-_\\\\\\/\\. ](?:[012]?\\d|3[01])(?!\\d)/);\n  if (foundDate) { return foundDate[0]; }\n  // Match ...MM-DD-YYYY...\n  foundDate = text.match(/(?:[012]?\\d|3[01])[-_\\\\\\/\\. ](?:0?\\d|1[012])[-_\\\\\\/\\. ](?:19|20)\\d\\d(?!\\d)/);\n  if (foundDate) { return foundDate[0]; }\n  // Match MM-DD-YY...\n  foundDate = text.match(/^(?:[012]?\\d|3[01])[-_\\\\\\/\\. ](?:0?\\d|1[012])[-_\\\\\\/\\. ]\\d\\d(?!\\d)/);\n  if (foundDate) { return foundDate[0]; }\n  // Match YY-MM-DD...\n  foundDate = text.match(/^\\d\\d[-_\\\\\\/\\. ](?:[012]?\\d|3[01])[-_\\\\\\/\\. ](?:0?\\d|1[012])(?!\\d)/);\n  if (foundDate) { return foundDate[0]; }\n  // Match YYYYMMDD...\n  foundDate = text.match(/^(?:19|20)\\d\\d(?:0\\d|1[012])(?:[012]\\d|3[01])/);\n  if (foundDate) { return foundDate[0]; }\n}\n",
    "export const enValidationMessages: any = { // Default English error messages\n  required: 'This field is required.',\n  minLength: 'Must be {{minimumLength}} characters or longer (current length: {{currentLength}})',\n  maxLength: 'Must be {{maximumLength}} characters or shorter (current length: {{currentLength}})',\n  pattern: 'Must match pattern: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Must be a date, like \"2000-12-31\"';\n      case 'time':\n        return 'Must be a time, like \"16:20\" or \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Must be a date-time, like \"2000-03-14T01:59\" or \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Must be an email address, like \"name@example.com\"';\n      case 'hostname':\n        return 'Must be a hostname, like \"example.com\"';\n      case 'ipv4':\n        return 'Must be an IPv4 address, like \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Must be an IPv6 address, like \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Must be a url, like \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Must be a uuid, like \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Must be a color, like \"#FFFFFF\" or \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Must be a JSON Pointer, like \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Must be a relative JSON Pointer, like \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Must be a regular expression, like \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Must be a correctly formatted ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Must be {{minimumValue}} or more',\n  exclusiveMinimum: 'Must be more than {{exclusiveMinimumValue}}',\n  maximum: 'Must be {{maximumValue}} or less',\n  exclusiveMaximum: 'Must be less than {{exclusiveMaximumValue}}',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Must have ${decimals} or fewer decimal places.`;\n    } else {\n      return `Must be a multiple of ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Must have {{minimumProperties}} or more items (current items: {{currentProperties}})',\n  maxProperties: 'Must have {{maximumProperties}} or fewer items (current items: {{currentProperties}})',\n  minItems: 'Must have {{minimumItems}} or more items (current items: {{currentItems}})',\n  maxItems: 'Must have {{maximumItems}} or fewer items (current items: {{currentItems}})',\n  uniqueItems: 'All items must be unique',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n",
    "export const frValidationMessages: any = { // French error messages\n  required: 'Est obligatoire.',\n  minLength: 'Doit avoir minimum {{minimumLength}} caractres (actuellement: {{currentLength}})',\n  maxLength: 'Doit avoir maximum {{maximumLength}} caractres (actuellement: {{currentLength}})',\n  pattern: 'Doit respecter: {{requiredPattern}}',\n  format: function (error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Doit tre une date, tel que \"2000-12-31\"';\n      case 'time':\n        return 'Doit tre une heure, tel que \"16:20\" ou \"03:14:15.9265\"';\n      case 'date-time':\n        return 'Doit tre une date et une heure, tel que \"2000-03-14T01:59\" ou \"2000-03-14T01:59:26.535Z\"';\n      case 'email':\n        return 'Doit tre une adresse e-mail, tel que \"name@example.com\"';\n      case 'hostname':\n        return 'Doit tre un nom de domaine, tel que \"example.com\"';\n      case 'ipv4':\n        return 'Doit tre une adresse IPv4, tel que \"127.0.0.1\"';\n      case 'ipv6':\n        return 'Doit tre une adresse IPv6, tel que \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"';\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Doit tre une URL, tel que \"http://www.example.com/page.html\"';\n      case 'uuid':\n        return 'Doit tre un UUID, tel que \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"';\n      case 'color':\n        return 'Doit tre une couleur, tel que \"#FFFFFF\" or \"rgb(255, 255, 255)\"';\n      case 'json-pointer':\n        return 'Doit tre un JSON Pointer, tel que \"/pointer/to/something\"';\n      case 'relative-json-pointer':\n        return 'Doit tre un relative JSON Pointer, tel que \"2/pointer/to/something\"';\n      case 'regex':\n        return 'Doit tre une expression rgulire, tel que \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"';\n      default:\n        return 'Doit tre avoir le format correct: ' + error.requiredFormat;\n    }\n  },\n  minimum: 'Doit tre suprieur  {{minimumValue}}',\n  exclusiveMinimum: 'Doit avoir minimum {{exclusiveMinimumValue}} charactres',\n  maximum: 'Doit tre infrieur  {{maximumValue}}',\n  exclusiveMaximum: 'Doit avoir maximum {{exclusiveMaximumValue}} charactres',\n  multipleOf: function (error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue);\n      return `Doit comporter ${decimals} ou moins de decimales.`;\n    } else {\n      return `Doit tre un multiple de ${error.multipleOfValue}.`;\n    }\n  },\n  minProperties: 'Doit comporter au minimum {{minimumProperties}} lments',\n  maxProperties: 'Doit comporter au maximum {{maximumProperties}} lments',\n  minItems: 'Doit comporter au minimum {{minimumItems}} lments',\n  maxItems: 'Doit comporter au maximum {{minimumItems}} lments',\n  uniqueItems: 'Tous les lments doivent tre uniques',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n};\n",
    "import { Injectable } from '@angular/core';\nimport { AbstractControl, FormArray, FormGroup } from '@angular/forms';\nimport { filter } from 'rxjs-compat/operators/filter';\nimport { Subject } from 'rxjs-compat/Subject';\n\nimport * as Ajv from 'ajv';\nimport * as _ from 'lodash';\n\nimport {\n  hasValue, isArray, isDefined, isEmpty, isObject, isString\n} from './shared/validator.functions';\nimport {\n  fixTitle, forEach, hasOwn, toTitleCase\n} from './shared/utility.functions';\nimport { JsonPointer } from './shared/jsonpointer.functions';\nimport {\n  buildSchemaFromData, buildSchemaFromLayout, removeRecursiveReferences,\n  resolveSchemaReferences\n} from './shared/json-schema.functions';\nimport {\n  buildFormGroup, buildFormGroupTemplate, formatFormData, getControl\n} from './shared/form-group.functions';\nimport { buildLayout, getLayoutNode } from './shared/layout.functions';\nimport { enValidationMessages } from './locale/en-validation-messages';\nimport { frValidationMessages } from './locale/fr-validation-messages';\n\nexport interface TitleMapItem {\n  name?: string; value?: any; checked?: boolean; group?: string; items?: TitleMapItem[];\n}\nexport interface ErrorMessages {\n  [control_name: string]: { message: string|Function|Object, code: string }[];\n}\n\n\n@Injectable()\nexport class JsonSchemaFormService {\n  JsonFormCompatibility = false;\n  ReactJsonSchemaFormCompatibility = false;\n  AngularSchemaFormCompatibility = false;\n  tpldata: any = {};\n\n  ajvOptions: any = { allErrors: true, jsonPointers: true, unknownFormats: 'ignore' };\n  ajv: any = new Ajv(this.ajvOptions); // AJV: Another JSON Schema Validator\n  validateFormData: any = null; // Compiled AJV function to validate active form's schema\n\n  formValues: any = {}; // Internal form data (may not have correct types)\n  data: any = {}; // Output form data (formValues, formatted with correct data types)\n  schema: any = {}; // Internal JSON Schema\n  layout: any[] = []; // Internal form layout\n  formGroupTemplate: any = {}; // Template used to create formGroup\n  formGroup: any = null; // Angular formGroup, which powers the reactive form\n  framework: any = null; // Active framework component\n  formOptions: any; // Active options, used to configure the form\n\n  validData: any = null; // Valid form data (or null) (=== isValid ? data : null)\n  isValid: boolean = null; // Is current form data valid?\n  ajvErrors: any = null; // Ajv errors for current data\n  validationErrors: any = null; // Any validation errors for current data\n  dataErrors: any = new Map(); //\n  formValueSubscription: any = null; // Subscription to formGroup.valueChanges observable (for un- and re-subscribing)\n  dataChanges: Subject<any> = new Subject(); // Form data observable\n  isValidChanges: Subject<any> = new Subject(); // isValid observable\n  validationErrorChanges: Subject<any> = new Subject(); // validationErrors observable\n\n  arrayMap: Map<string, number> = new Map(); // Maps arrays in data object and number of tuple values\n  dataMap: Map<string, any> = new Map(); // Maps paths in form data to schema and formGroup paths\n  dataRecursiveRefMap: Map<string, string> = new Map(); // Maps recursive reference points in form data\n  schemaRecursiveRefMap: Map<string, string> = new Map(); // Maps recursive reference points in schema\n  schemaRefLibrary: any = {}; // Library of schemas for resolving schema $refs\n  layoutRefLibrary: any = { '': null }; // Library of layout nodes for adding to form\n  templateRefLibrary: any = {}; // Library of formGroup templates for adding to form\n  hasRootReference = false; // Does the form include a recursive reference to itself?\n\n  language = 'en-US'; // Does the form include a recursive reference to itself?\n\n  // Default global form options\n  defaultFormOptions: any = {\n    addSubmit: 'auto', // Add a submit button if layout does not have one?\n      // for addSubmit: true = always, false = never,\n      // 'auto' = only if layout is undefined (form is built from schema alone)\n    debug: false, // Show debugging output?\n    disableInvalidSubmit: true, // Disable submit if form invalid?\n    formDisabled: false, // Set entire form as disabled? (not editable, and disables outputs)\n    formReadonly: false, // Set entire form as read only? (not editable, but outputs still enabled)\n    fieldsRequired: false, // (set automatically) Are there any required fields in the form?\n    framework: 'no-framework', // The framework to load\n    loadExternalAssets: false, // Load external css and JavaScript for framework?\n    pristine: { errors: true, success: true },\n    supressPropertyTitles: false,\n    setSchemaDefaults: 'auto', // Set fefault values from schema?\n      // true = always set (unless overridden by layout default or formValues)\n      // false = never set\n      // 'auto' = set in addable components, and everywhere if formValues not set\n    setLayoutDefaults: 'auto', // Set fefault values from layout?\n      // true = always set (unless overridden by formValues)\n      // false = never set\n      // 'auto' = set in addable components, and everywhere if formValues not set\n    validateOnRender: 'auto', // Validate fields immediately, before they are touched?\n      // true = validate all fields immediately\n      // false = only validate fields after they are touched by user\n      // 'auto' = validate fields with values immediately, empty fields after they are touched\n    widgets: {}, // Any custom widgets to load\n    defautWidgetOptions: { // Default options for form control widgets\n      listItems: 1, // Number of list items to initially add to arrays with no default value\n      addable: true, // Allow adding items to an array or $ref point?\n      orderable: true, // Allow reordering items within an array?\n      removable: true, // Allow removing items from an array or $ref point?\n      enableErrorState: true, // Apply 'has-error' class when field fails validation?\n      // disableErrorState: false, // Don't apply 'has-error' class when field fails validation?\n      enableSuccessState: true, // Apply 'has-success' class when field validates?\n      // disableSuccessState: false, // Don't apply 'has-success' class when field validates?\n      feedback: false, // Show inline feedback icons?\n      feedbackOnRender: false, // Show errorMessage on Render?\n      notitle: false, // Hide title?\n      disabled: false, // Set control as disabled? (not editable, and excluded from output)\n      readonly: false, // Set control as read only? (not editable, but included in output)\n      returnEmptyFields: true, // return values for fields that contain no data?\n      validationMessages: {} // set by setLanguage()\n    },\n  };\n\n  constructor() {\n    this.setLanguage(this.language);\n  }\n\n  setLanguage(language: string = 'en-US') {\n    this.language = language;\n    const validationMessages = language.slice(0, 2) === 'fr' ?\n      frValidationMessages : enValidationMessages;\n    this.defaultFormOptions.defautWidgetOptions.validationMessages =\n      _.cloneDeep(validationMessages);\n  }\n\n  getData() { return this.data; }\n\n  getSchema() { return this.schema; }\n\n  getLayout() { return this.layout; }\n\n  resetAllValues() {\n    this.JsonFormCompatibility = false;\n    this.ReactJsonSchemaFormCompatibility = false;\n    this.AngularSchemaFormCompatibility = false;\n    this.tpldata = {};\n    this.validateFormData = null;\n    this.formValues = {};\n    this.schema = {};\n    this.layout = [];\n    this.formGroupTemplate = {};\n    this.formGroup = null;\n    this.framework = null;\n    this.data = {};\n    this.validData = null;\n    this.isValid = null;\n    this.validationErrors = null;\n    this.arrayMap = new Map();\n    this.dataMap = new Map();\n    this.dataRecursiveRefMap = new Map();\n    this.schemaRecursiveRefMap = new Map();\n    this.layoutRefLibrary = {};\n    this.schemaRefLibrary = {};\n    this.templateRefLibrary = {};\n    this.formOptions = _.cloneDeep(this.defaultFormOptions);\n  }\n\n  /**\n   * 'buildRemoteError' function\n   *\n   * Example errors:\n   * {\n   *   last_name: [ {\n   *     message: 'Last name must by start with capital letter.',\n   *     code: 'capital_letter'\n   *   } ],\n   *   email: [ {\n   *     message: 'Email must be from example.com domain.',\n   *     code: 'special_domain'\n   *   }, {\n   *     message: 'Email must contain an @ symbol.',\n   *     code: 'at_symbol'\n   *   } ]\n   * }\n   * @param {ErrorMessages} errors\n   */\n  buildRemoteError(errors: ErrorMessages) {\n    forEach(errors, (value, key) => {\n      if (key in this.formGroup.controls) {\n        for (const error of value) {\n          const err = {};\n          err[error['code']] = error['message'];\n          this.formGroup.get(key).setErrors(err, { emitEvent: true });\n        }\n      }\n    });\n  }\n\n  validateData(newValue: any, updateSubscriptions = true): void {\n\n    // Format raw form data to correct data types\n    this.data = formatFormData(\n      newValue, this.dataMap, this.dataRecursiveRefMap,\n      this.arrayMap, this.formOptions.returnEmptyFields\n    );\n    this.isValid = this.validateFormData(this.data);\n    this.validData = this.isValid ? this.data : null;\n    const compileErrors = errors => {\n      const compiledErrors = {};\n      (errors || []).forEach(error => {\n        if (!compiledErrors[error.dataPath]) { compiledErrors[error.dataPath] = []; }\n        compiledErrors[error.dataPath].push(error.message);\n      });\n      return compiledErrors;\n    };\n    this.ajvErrors = this.validateFormData.errors;\n    this.validationErrors = compileErrors(this.validateFormData.errors);\n    if (updateSubscriptions) {\n      this.dataChanges.next(this.data);\n      this.isValidChanges.next(this.isValid);\n      this.validationErrorChanges.next(this.ajvErrors);\n    }\n  }\n\n  buildFormGroupTemplate(formValues: any = null, setValues = true) {\n    this.formGroupTemplate = buildFormGroupTemplate(this, formValues, setValues);\n  }\n\n  buildFormGroup() {\n    this.formGroup = <FormGroup>buildFormGroup(this.formGroupTemplate);\n    if (this.formGroup) {\n      this.compileAjvSchema();\n      this.validateData(this.formGroup.value);\n\n      // Set up observables to emit data and validation info when form data changes\n      if (this.formValueSubscription) { this.formValueSubscription.unsubscribe(); }\n      this.formValueSubscription = this.formGroup.valueChanges\n        .subscribe(formValue => this.validateData(formValue));\n    }\n  }\n\n  buildLayout(widgetLibrary: any) {\n    this.layout = buildLayout(this, widgetLibrary);\n  }\n\n  setOptions(newOptions: any) {\n    if (isObject(newOptions)) {\n      const addOptions = _.cloneDeep(newOptions);\n      // Backward compatibility for 'defaultOptions' (renamed 'defautWidgetOptions')\n      if (isObject(addOptions.defaultOptions)) {\n        Object.assign(this.formOptions.defautWidgetOptions, addOptions.defaultOptions);\n        delete addOptions.defaultOptions;\n      }\n      if (isObject(addOptions.defautWidgetOptions)) {\n        Object.assign(this.formOptions.defautWidgetOptions, addOptions.defautWidgetOptions);\n        delete addOptions.defautWidgetOptions;\n      }\n      Object.assign(this.formOptions, addOptions);\n\n      // convert disableErrorState / disableSuccessState to enable...\n      const globalDefaults = this.formOptions.defautWidgetOptions;\n      ['ErrorState', 'SuccessState']\n        .filter(suffix => hasOwn(globalDefaults, 'disable' + suffix))\n        .forEach(suffix => {\n          globalDefaults['enable' + suffix] = !globalDefaults['disable' + suffix];\n          delete globalDefaults['disable' + suffix];\n        });\n    }\n  }\n\n  compileAjvSchema() {\n    if (!this.validateFormData) {\n\n      // if 'ui:order' exists in properties, move it to root before compiling with ajv\n      if (Array.isArray(this.schema.properties['ui:order'])) {\n        this.schema['ui:order'] = this.schema.properties['ui:order'];\n        delete this.schema.properties['ui:order'];\n      }\n      this.ajv.removeSchema(this.schema);\n      this.validateFormData = this.ajv.compile(this.schema);\n    }\n  }\n\n  buildSchemaFromData(data?: any, requireAllFields = false): any {\n    if (data) { return buildSchemaFromData(data, requireAllFields); }\n    this.schema = buildSchemaFromData(this.formValues, requireAllFields);\n  }\n\n  buildSchemaFromLayout(layout?: any): any {\n    if (layout) { return buildSchemaFromLayout(layout); }\n    this.schema = buildSchemaFromLayout(this.layout);\n  }\n\n\n  setTpldata(newTpldata: any = {}): void {\n    this.tpldata = newTpldata;\n  }\n\n  parseText(\n    text = '', value: any = {}, values: any = {}, key: number|string = null\n  ): string {\n    if (!text || !/{{.+?}}/.test(text)) { return text; }\n    return text.replace(/{{(.+?)}}/g, (...a) =>\n      this.parseExpression(a[1], value, values, key, this.tpldata)\n    );\n  }\n\n  parseExpression(\n    expression = '', value: any = {}, values: any = {},\n    key: number|string = null, tpldata: any = null\n  ) {\n    if (typeof expression !== 'string') { return ''; }\n    const index = typeof key === 'number' ? (key + 1) + '' : (key || '');\n    expression = expression.trim();\n    if ((expression[0] === '\\'' || expression[0] === '\"') &&\n      expression[0] === expression[expression.length - 1] &&\n      expression.slice(1, expression.length - 1).indexOf(expression[0]) === -1\n    ) {\n      return expression.slice(1, expression.length - 1);\n    }\n    if (expression === 'idx' || expression === '$index') { return index; }\n    if (expression === 'value' && !hasOwn(values, 'value')) { return value; }\n    if (['\"', '\\'', ' ', '||', '&&', '+'].every(delim => expression.indexOf(delim) === -1)) {\n      const pointer = JsonPointer.parseObjectPath(expression);\n      return pointer[0] === 'value' && JsonPointer.has(value, pointer.slice(1)) ?\n          JsonPointer.get(value, pointer.slice(1)) :\n        pointer[0] === 'values' && JsonPointer.has(values, pointer.slice(1)) ?\n          JsonPointer.get(values, pointer.slice(1)) :\n        pointer[0] === 'tpldata' && JsonPointer.has(tpldata, pointer.slice(1)) ?\n          JsonPointer.get(tpldata, pointer.slice(1)) :\n        JsonPointer.has(values, pointer) ? JsonPointer.get(values, pointer) : '';\n    }\n    if (expression.indexOf('[idx]') > -1) {\n      expression = expression.replace(/\\[idx\\]/g, <string>index);\n    }\n    if (expression.indexOf('[$index]') > -1) {\n      expression = expression.replace(/\\[$index\\]/g, <string>index);\n    }\n    // TODO: Improve expression evaluation by parsing quoted strings first\n    // let expressionArray = expression.match(/([^\"']+|\"[^\"]+\"|'[^']+')/g);\n    if (expression.indexOf('||') > -1) {\n      return expression.split('||').reduce((all, term) =>\n        all || this.parseExpression(term, value, values, key, tpldata), ''\n      );\n    }\n    if (expression.indexOf('&&') > -1) {\n      return expression.split('&&').reduce((all, term) =>\n        all && this.parseExpression(term, value, values, key, tpldata), ' '\n      ).trim();\n    }\n    if (expression.indexOf('+') > -1) {\n      return expression.split('+')\n        .map(term => this.parseExpression(term, value, values, key, tpldata))\n        .join('');\n    }\n    return '';\n  }\n\n  setArrayItemTitle(\n    parentCtx: any = {}, childNode: any = null, index: number = null\n  ): string {\n    const parentNode = parentCtx.layoutNode;\n    const parentValues: any = this.getFormControlValue(parentCtx);\n    const isArrayItem =\n      (parentNode.type || '').slice(-5) === 'array' && isArray(parentValues);\n    const text = JsonPointer.getFirst(\n      isArrayItem && childNode.type !== '$ref' ? [\n        [childNode, '/options/legend'],\n        [childNode, '/options/title'],\n        [parentNode, '/options/title'],\n        [parentNode, '/options/legend'],\n      ] : [\n        [childNode, '/options/title'],\n        [childNode, '/options/legend'],\n        [parentNode, '/options/title'],\n        [parentNode, '/options/legend']\n      ]\n    );\n    if (!text) { return text; }\n    const childValue = isArray(parentValues) && index < parentValues.length ?\n      parentValues[index] : parentValues;\n    return this.parseText(text, childValue, parentValues, index);\n  }\n\n  setItemTitle(ctx: any) {\n    return !ctx.options.title && /^(\\d+|-)$/.test(ctx.layoutNode.name) ?\n      null :\n      this.parseText(\n        ctx.options.title || toTitleCase(ctx.layoutNode.name),\n        this.getFormControlValue(this),\n        (this.getFormControlGroup(this) || <any>{}).value,\n        ctx.dataIndex[ctx.dataIndex.length - 1]\n      );\n  }\n\n  evaluateCondition(layoutNode: any, dataIndex: number[]): boolean {\n    const arrayIndex = dataIndex && dataIndex[dataIndex.length - 1];\n    let result = true;\n    if (hasValue((layoutNode.options || {}).condition)) {\n      if (typeof layoutNode.options.condition === 'string') {\n        let pointer = layoutNode.options.condition;\n        if (hasValue(arrayIndex)) {\n          pointer = pointer.replace('[arrayIndex]', `[${arrayIndex}]`);\n        }\n        pointer = JsonPointer.parseObjectPath(pointer);\n        result = !!JsonPointer.get(this.data, pointer);\n        if (!result && pointer[0] === 'model') {\n          result = !!JsonPointer.get({ model: this.data }, pointer);\n        }\n      } else if (typeof layoutNode.options.condition === 'function') {\n        result = layoutNode.options.condition(this.data);\n      } else if (typeof layoutNode.options.condition.functionBody === 'string') {\n        try {\n          const dynFn = new Function(\n            'model', 'arrayIndices', layoutNode.options.condition.functionBody\n          );\n          result = dynFn(this.data, dataIndex);\n        } catch (e) {\n          result = true;\n          console.error('condition functionBody errored out on evaluation: ' + layoutNode.options.condition.functionBody);\n        }\n      }\n    }\n    return result;\n  }\n\n  initializeControl(ctx: any, bind = true): boolean {\n    if (!isObject(ctx)) { return false; }\n    if (isEmpty(ctx.options)) {\n      ctx.options = !isEmpty((ctx.layoutNode || {}).options) ?\n        ctx.layoutNode.options : _.cloneDeep(this.formOptions);\n    }\n    ctx.formControl = this.getFormControl(ctx);\n    ctx.boundControl = bind && !!ctx.formControl;\n    if (ctx.formControl) {\n      ctx.controlName = this.getFormControlName(ctx);\n      ctx.controlValue = ctx.formControl.value;\n      ctx.controlDisabled = ctx.formControl.disabled;\n      ctx.options.errorMessage = ctx.formControl.status === 'VALID' ? null :\n        this.formatErrors(ctx.formControl.errors, ctx.options.validationMessages);\n      ctx.options.showErrors = this.formOptions.validateOnRender === true ||\n        (this.formOptions.validateOnRender === 'auto' && hasValue(ctx.controlValue));\n      ctx.formControl.statusChanges.subscribe(status =>\n        ctx.options.errorMessage = status === 'VALID' ? null :\n          this.formatErrors(ctx.formControl.errors, ctx.options.validationMessages)\n      );\n      ctx.formControl.valueChanges.subscribe(value => {\n        if (!_.isEqual(ctx.controlValue, value)) { ctx.controlValue = value; }\n      });\n    } else {\n      ctx.controlName = ctx.layoutNode.name;\n      ctx.controlValue = ctx.layoutNode.value || null;\n      const dataPointer = this.getDataPointer(ctx);\n      if (bind && dataPointer) {\n        console.error(`warning: control \"${dataPointer}\" is not bound to the Angular FormGroup.`);\n      }\n    }\n    return ctx.boundControl;\n  }\n\n  formatErrors(errors: any, validationMessages: any = {}): string {\n    if (isEmpty(errors)) { return null; }\n    if (!isObject(validationMessages)) { validationMessages = {}; }\n    const addSpaces = string => string[0].toUpperCase() + (string.slice(1) || '')\n      .replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' ');\n    const formatError = (error) => typeof error === 'object' ?\n      Object.keys(error).map(key =>\n        error[key] === true ? addSpaces(key) :\n        error[key] === false ? 'Not ' + addSpaces(key) :\n        addSpaces(key) + ': ' + formatError(error[key])\n      ).join(', ') :\n      addSpaces(error.toString());\n    const messages = [];\n    return Object.keys(errors)\n      // Hide 'required' error, unless it is the only one\n      .filter(errorKey => errorKey !== 'required' || Object.keys(errors).length === 1)\n      .map(errorKey =>\n        // If validationMessages is a string, return it\n        typeof validationMessages === 'string' ? validationMessages :\n        // If custom error message is a function, return function result\n        typeof validationMessages[errorKey] === 'function' ?\n          validationMessages[errorKey](errors[errorKey]) :\n        // If custom error message is a string, replace placeholders and return\n        typeof validationMessages[errorKey] === 'string' ?\n          // Does error message have any {{property}} placeholders?\n          !/{{.+?}}/.test(validationMessages[errorKey]) ?\n            validationMessages[errorKey] :\n            // Replace {{property}} placeholders with values\n            Object.keys(errors[errorKey])\n              .reduce((errorMessage, errorProperty) => errorMessage.replace(\n                new RegExp('{{' + errorProperty + '}}', 'g'),\n                errors[errorKey][errorProperty]\n              ), validationMessages[errorKey]) :\n          // If no custom error message, return formatted error data instead\n          addSpaces(errorKey) + ' Error: ' + formatError(errors[errorKey])\n      ).join('<br>');\n  }\n\n  updateValue(ctx: any, value: any): void {\n\n    // Set value of current control\n    ctx.controlValue = value;\n    if (ctx.boundControl) {\n      ctx.formControl.setValue(value);\n      ctx.formControl.markAsDirty();\n    }\n    ctx.layoutNode.value = value;\n\n    // Set values of any related controls in copyValueTo array\n    if (isArray(ctx.options.copyValueTo)) {\n      for (const item of ctx.options.copyValueTo) {\n        const targetControl = getControl(this.formGroup, item);\n        if (isObject(targetControl) && typeof targetControl.setValue === 'function') {\n          targetControl.setValue(value);\n          targetControl.markAsDirty();\n        }\n      }\n    }\n  }\n\n  updateArrayCheckboxList(ctx: any, checkboxList: TitleMapItem[]): void {\n    const formArray = <FormArray>this.getFormControl(ctx);\n\n    // Remove all existing items\n    while (formArray.value.length) { formArray.removeAt(0); }\n\n    // Re-add an item for each checked box\n    const refPointer = removeRecursiveReferences(\n      ctx.layoutNode.dataPointer + '/-', this.dataRecursiveRefMap, this.arrayMap\n    );\n    for (const checkboxItem of checkboxList) {\n      if (checkboxItem.checked) {\n        const newFormControl = buildFormGroup(this.templateRefLibrary[refPointer]);\n        newFormControl.setValue(checkboxItem.value);\n        formArray.push(newFormControl);\n      }\n    }\n    formArray.markAsDirty();\n  }\n\n  getFormControl(ctx: any): AbstractControl {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      ctx.layoutNode.type === '$ref'\n    ) { return null; }\n    return getControl(this.formGroup, this.getDataPointer(ctx));\n  }\n\n  getFormControlValue(ctx: any): AbstractControl {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      ctx.layoutNode.type === '$ref'\n    ) { return null; }\n    const control = getControl(this.formGroup, this.getDataPointer(ctx));\n    return control ? control.value : null;\n  }\n\n  getFormControlGroup(ctx: any): FormArray | FormGroup {\n    if (!ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer)) { return null; }\n    return getControl(this.formGroup, this.getDataPointer(ctx), true);\n  }\n\n  getFormControlName(ctx: any): string {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)\n    ) { return null; }\n    return JsonPointer.toKey(this.getDataPointer(ctx));\n  }\n\n  getLayoutArray(ctx: any): any[] {\n    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -1);\n  }\n\n  getParentNode(ctx: any): any {\n    return JsonPointer.get(this.layout, this.getLayoutPointer(ctx), 0, -2);\n  }\n\n  getDataPointer(ctx: any): string {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)\n    ) { return null; }\n    return JsonPointer.toIndexedPointer(\n      ctx.layoutNode.dataPointer, ctx.dataIndex, this.arrayMap\n    );\n  }\n\n  getLayoutPointer(ctx: any): string {\n    if (!hasValue(ctx.layoutIndex)) { return null; }\n    return '/' + ctx.layoutIndex.join('/items/');\n  }\n\n  isControlBound(ctx: any): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) || !hasValue(ctx.dataIndex)\n    ) { return false; }\n    const controlGroup = this.getFormControlGroup(ctx);\n    const name = this.getFormControlName(ctx);\n    return controlGroup ? hasOwn(controlGroup.controls, name) : false;\n  }\n\n  addItem(ctx: any, name?: string): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.$ref) ||\n      !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex)\n    ) { return false; }\n\n    // Create a new Angular form control from a template in templateRefLibrary\n    const newFormGroup = buildFormGroup(this.templateRefLibrary[ctx.layoutNode.$ref]);\n\n    // Add the new form control to the parent formArray or formGroup\n    if (ctx.layoutNode.arrayItem) { // Add new array item to formArray\n      (<FormArray>this.getFormControlGroup(ctx)).push(newFormGroup);\n    } else { // Add new $ref item to formGroup\n      (<FormGroup>this.getFormControlGroup(ctx))\n        .addControl(name || this.getFormControlName(ctx), newFormGroup);\n    }\n\n    // Copy a new layoutNode from layoutRefLibrary\n    const newLayoutNode = getLayoutNode(ctx.layoutNode, this);\n    newLayoutNode.arrayItem = ctx.layoutNode.arrayItem;\n    if (ctx.layoutNode.arrayItemType) {\n      newLayoutNode.arrayItemType = ctx.layoutNode.arrayItemType;\n    } else {\n      delete newLayoutNode.arrayItemType;\n    }\n    if (name) {\n      newLayoutNode.name = name;\n      newLayoutNode.dataPointer += '/' + JsonPointer.escape(name);\n      newLayoutNode.options.title = fixTitle(name);\n    }\n\n    // Add the new layoutNode to the form layout\n    JsonPointer.insert(this.layout, this.getLayoutPointer(ctx), newLayoutNode);\n\n    return true;\n  }\n\n  moveArrayItem(ctx: any, oldIndex: number, newIndex: number): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex) ||\n      !isDefined(oldIndex) || !isDefined(newIndex) || oldIndex === newIndex\n    ) { return false; }\n\n    // Move item in the formArray\n    const formArray = <FormArray>this.getFormControlGroup(ctx);\n    const arrayItem = formArray.at(oldIndex);\n    formArray.removeAt(oldIndex);\n    formArray.insert(newIndex, arrayItem);\n    formArray.updateValueAndValidity();\n\n    // Move layout item\n    const layoutArray = this.getLayoutArray(ctx);\n    layoutArray.splice(newIndex, 0, layoutArray.splice(oldIndex, 1)[0]);\n    return true;\n  }\n\n  removeItem(ctx: any): boolean {\n    if (\n      !ctx.layoutNode || !isDefined(ctx.layoutNode.dataPointer) ||\n      !hasValue(ctx.dataIndex) || !hasValue(ctx.layoutIndex)\n    ) { return false; }\n\n    // Remove the Angular form control from the parent formArray or formGroup\n    if (ctx.layoutNode.arrayItem) { // Remove array item from formArray\n      (<FormArray>this.getFormControlGroup(ctx))\n        .removeAt(ctx.dataIndex[ctx.dataIndex.length - 1]);\n    } else { // Remove $ref item from formGroup\n      (<FormGroup>this.getFormControlGroup(ctx))\n        .removeControl(this.getFormControlName(ctx));\n    }\n\n    // Remove layoutNode from layout\n    JsonPointer.remove(this.layout, this.getLayoutPointer(ctx));\n    return true;\n  }\n}\n",
    "import { Directive, ElementRef, HostListener, Input, NgZone, OnInit } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { JsonPointer } from '../shared/jsonpointer.functions';\n\n/**\n * OrderableDirective\n *\n * Enables array elements to be reordered by dragging and dropping.\n *\n * Only works for arrays that have at least two elements.\n *\n * Also detects arrays-within-arrays, and correctly moves either\n * the child array element or the parent array element,\n * depending on the drop targert.\n *\n * Listeners for movable element being dragged:\n * - dragstart: add 'dragging' class to element, set effectAllowed = 'move'\n * - dragover: set dropEffect = 'move'\n * - dragend: remove 'dragging' class from element\n *\n * Listeners for stationary items being dragged over:\n * - dragenter: add 'drag-target-...' classes to element\n * - dragleave: remove 'drag-target-...' classes from element\n * - drop: remove 'drag-target-...' classes from element, move dropped array item\n */\n@Directive({\n  selector: '[orderable]',\n})\nexport class OrderableDirective implements OnInit {\n  arrayLayoutIndex: string;\n  element: any;\n  overParentElement = false;\n  overChildElement = false;\n  @Input() orderable: boolean;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private elementRef: ElementRef,\n    private jsf: JsonSchemaFormService,\n    private ngZone: NgZone\n  ) { }\n\n  ngOnInit() {\n    if (this.orderable && this.layoutNode && this.layoutIndex && this.dataIndex) {\n      this.element = this.elementRef.nativeElement;\n      this.element.draggable = true;\n      this.arrayLayoutIndex = 'move:' + this.layoutIndex.slice(0, -1).toString();\n\n      this.ngZone.runOutsideAngular(() => {\n\n        // Listeners for movable element being dragged:\n\n        this.element.addEventListener('dragstart', (event) => {\n          event.dataTransfer.effectAllowed = 'move';\n          // Hack to bypass stupid HTML drag-and-drop dataTransfer protection\n          // so drag source info will be available on dragenter\n          const sourceArrayIndex = this.dataIndex[this.dataIndex.length - 1];\n          sessionStorage.setItem(this.arrayLayoutIndex, sourceArrayIndex + '');\n        });\n\n        this.element.addEventListener('dragover', (event) => {\n          if (event.preventDefault) { event.preventDefault(); }\n          event.dataTransfer.dropEffect = 'move';\n          return false;\n        });\n\n        // Listeners for stationary items being dragged over:\n\n        this.element.addEventListener('dragenter', (event) => {\n          // Part 1 of a hack, inspired by Dragster, to simulate mouseover and mouseout\n          // behavior while dragging items - http://bensmithett.github.io/dragster/\n          if (this.overParentElement) {\n            return this.overChildElement = true;\n          } else {\n            this.overParentElement = true;\n          }\n\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          if (sourceArrayIndex !== null) {\n            if (this.dataIndex[this.dataIndex.length - 1] < +sourceArrayIndex) {\n              this.element.classList.add('drag-target-top');\n            } else if (this.dataIndex[this.dataIndex.length - 1] > +sourceArrayIndex) {\n              this.element.classList.add('drag-target-bottom');\n            }\n          }\n        });\n\n        this.element.addEventListener('dragleave', (event) => {\n          // Part 2 of the Dragster hack\n          if (this.overChildElement) {\n            this.overChildElement = false;\n          } else if (this.overParentElement) {\n            this.overParentElement = false;\n          }\n\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          if (!this.overParentElement && !this.overChildElement && sourceArrayIndex !== null) {\n            this.element.classList.remove('drag-target-top');\n            this.element.classList.remove('drag-target-bottom');\n          }\n        });\n\n        this.element.addEventListener('drop', (event) => {\n          this.element.classList.remove('drag-target-top');\n          this.element.classList.remove('drag-target-bottom');\n          // Confirm that drop target is another item in the same array as source item\n          const sourceArrayIndex = sessionStorage.getItem(this.arrayLayoutIndex);\n          const destArrayIndex = this.dataIndex[this.dataIndex.length - 1];\n          if (sourceArrayIndex !== null && +sourceArrayIndex !== destArrayIndex) {\n            // Move array item\n            this.jsf.moveArrayItem(this, +sourceArrayIndex, destArrayIndex);\n          }\n          sessionStorage.removeItem(this.arrayLayoutIndex);\n          return false;\n        });\n\n      });\n    }\n  }\n}\n",
    "import { ChangeDetectionStrategy, Component, Input, OnInit } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'add-reference-widget',\n  template: `\n    <button *ngIf=\"showAddButton\"\n      [class]=\"options?.fieldHtmlClass || ''\"\n      [disabled]=\"options?.readonly\"\n      (click)=\"addItem($event)\">\n      <span *ngIf=\"options?.icon\" [class]=\"options?.icon\"></span>\n      <span *ngIf=\"options?.title\" [innerHTML]=\"buttonText\"></span>\n    </button>`,\n    changeDetection: ChangeDetectionStrategy.Default,\n})\nexport class AddReferenceComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  previousLayoutIndex: number[];\n  previousDataIndex: number[];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n  }\n\n  get showAddButton(): boolean {\n    return !this.layoutNode.arrayItem ||\n      this.layoutIndex[this.layoutIndex.length - 1] < this.options.maxItems;\n  }\n\n  addItem(event) {\n    event.preventDefault();\n    this.jsf.addItem(this);\n  }\n\n  get buttonText(): string {\n    const parent: any = {\n      dataIndex: this.dataIndex.slice(0, -1),\n      layoutIndex: this.layoutIndex.slice(0, -1),\n      layoutNode: this.jsf.getParentNode(this)\n    };\n    return parent.layoutNode.add ||\n      this.jsf.setArrayItemTitle(parent, this.layoutNode, this.itemCount);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'one-of-widget',\n  template: ``,\n})\nexport class OneOfComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'button-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <button\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n        <span *ngIf=\"options?.icon || options?.title\"\n          [class]=\"options?.icon\"\n          [innerHTML]=\"options?.title\"></span>\n      </button>\n    </div>`,\n})\nexport class ButtonComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    if (typeof this.options.onClick === 'function') {\n      this.options.onClick(event);\n    } else {\n      this.jsf.updateValue(this, event.target.value);\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'checkbox-widget',\n  template: `\n    <label\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.itemLabelHtmlClass || ''\">\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        type=\"checkbox\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [checked]=\"isChecked ? 'checked' : null\"\n        [class]=\"(options?.fieldHtmlClass || '') + (isChecked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [value]=\"controlValue\"\n        type=\"checkbox\"\n        (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </label>`,\n})\nexport class CheckboxComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  trueValue: any = true;\n  falseValue: any = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (this.controlValue === null || this.controlValue === undefined) {\n      this.controlValue = this.options.title;\n    }\n  }\n\n  updateValue(event) {\n    event.preventDefault();\n    this.jsf.updateValue(this, event.target.checked ? this.trueValue : this.falseValue);\n  }\n\n  get isChecked() {\n    return this.jsf.getFormControlValue(this) === this.trueValue;\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { FormArray, AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService, TitleMapItem } from '../json-schema-form.service';\nimport { buildTitleMap } from '../shared';\n\n@Component({\n  selector: 'checkboxes-widget',\n  template: `\n    <label *ngIf=\"options?.title\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = checkboxes-inline or checkboxbuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\" [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let checkboxItem of checkboxList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"checkbox\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"checkboxItem.checked\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [name]=\"checkboxItem?.name\"\n          [readonly]=\"options?.readonly ? 'readonly' : null\"\n          [value]=\"checkboxItem.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"checkboxItem.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular checkboxes -->\n    <div *ngIf=\"layoutOrientation === 'vertical'\">\n      <div *ngFor=\"let checkboxItem of checkboxList\" [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + checkboxItem.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') + (checkboxItem.checked ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"checkbox\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"checkboxItem.checked\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"options?.name + '/' + checkboxItem.value\"\n            [name]=\"checkboxItem?.name\"\n            [readonly]=\"options?.readonly ? 'readonly' : null\"\n            [value]=\"checkboxItem.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"checkboxItem?.name\"></span>\n        </label>\n      </div>\n    </div>`,\n})\nexport class CheckboxesComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  layoutOrientation: string;\n  formArray: AbstractControl;\n  checkboxList: TitleMapItem[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.layoutOrientation = (this.layoutNode.type === 'checkboxes-inline' ||\n      this.layoutNode.type === 'checkboxbuttons') ? 'horizontal' : 'vertical';\n    this.jsf.initializeControl(this);\n    this.checkboxList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames, this.options.enum, true\n    );\n    if (this.boundControl) {\n      const formArray = this.jsf.getFormControl(this);\n      this.checkboxList.forEach(checkboxItem =>\n        checkboxItem.checked = formArray.value.includes(checkboxItem.value)\n      );\n    }\n  }\n\n  updateValue(event) {\n    for (const checkboxItem of this.checkboxList) {\n      if (event.target.value === checkboxItem.value) {\n        checkboxItem.checked = event.target.checked;\n      }\n    }\n    if (this.boundControl) {\n      this.jsf.updateArrayCheckboxList(this, this.checkboxList);\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'file-widget',\n  template: ``,\n})\nexport class FileComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'input-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n        <datalist *ngIf=\"options?.typeahead?.source\"\n          [id]=\"'control' + layoutNode?._id + 'Autocomplete'\">\n          <option *ngFor=\"let word of options?.typeahead?.source\" [value]=\"word\">\n        </datalist>\n    </div>`,\n})\nexport class InputComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: string;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  autoCompleteList: string[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'message-widget',\n  template: `\n    <span *ngIf=\"message\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [innerHTML]=\"message\"></span>`,\n})\nexport class MessageComponent implements OnInit {\n  options: any;\n  message: string = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.message = this.options.help || this.options.helpvalue ||\n      this.options.msg || this.options.message;\n  }\n}\n",
    "import { Component, Input } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\n@Component({\n  selector: 'none-widget',\n  template: ``,\n})\nexport class NoneComponent {\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'number-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <input *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\">\n      <input *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.required]=\"options?.required\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [title]=\"lastValidNumber\"\n        [type]=\"layoutNode?.type === 'range' ? 'range' : 'number'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">\n      <span *ngIf=\"layoutNode?.type === 'range'\" [innerHTML]=\"controlValue\"></span>\n    </div>`,\n})\nexport class NumberComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  allowNegative = true;\n  allowDecimal = true;\n  allowExponents = false;\n  lastValidNumber = '';\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (this.layoutNode.dataType === 'integer') { this.allowDecimal = false; }\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { buildTitleMap } from '../shared';\n\n@Component({\n  selector: 'radios-widget',\n  template: `\n    <label *ngIf=\"options?.title\"\n      [attr.for]=\"'control' + layoutNode?._id\"\n      [class]=\"options?.labelHtmlClass || ''\"\n      [style.display]=\"options?.notitle ? 'none' : ''\"\n      [innerHTML]=\"options?.title\"></label>\n\n    <!-- 'horizontal' = radios-inline or radiobuttons -->\n    <div *ngIf=\"layoutOrientation === 'horizontal'\"\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngFor=\"let radioItem of radiosList\"\n        [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n        [class]=\"(options?.itemLabelHtmlClass || '') +\n          ((controlValue + '' === radioItem?.value + '') ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + (options?.style?.unselected || '')))\">\n        <input type=\"radio\"\n          [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n          [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n          [attr.required]=\"options?.required\"\n          [checked]=\"radioItem?.value === controlValue\"\n          [class]=\"options?.fieldHtmlClass || ''\"\n          [disabled]=\"controlDisabled\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [name]=\"controlName\"\n          [value]=\"radioItem?.value\"\n          (change)=\"updateValue($event)\">\n        <span [innerHTML]=\"radioItem?.name\"></span>\n      </label>\n    </div>\n\n    <!-- 'vertical' = regular radios -->\n    <div *ngIf=\"layoutOrientation !== 'horizontal'\">\n      <div *ngFor=\"let radioItem of radiosList\"\n        [class]=\"options?.htmlClass || ''\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n          [class]=\"(options?.itemLabelHtmlClass || '') +\n            ((controlValue + '' === radioItem?.value + '') ?\n            (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n            (' ' + (options?.style?.unselected || '')))\">\n          <input type=\"radio\"\n            [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n            [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n            [attr.required]=\"options?.required\"\n            [checked]=\"radioItem?.value === controlValue\"\n            [class]=\"options?.fieldHtmlClass || ''\"\n            [disabled]=\"controlDisabled\"\n            [id]=\"'control' + layoutNode?._id + '/' + radioItem?.value\"\n            [name]=\"controlName\"\n            [value]=\"radioItem?.value\"\n            (change)=\"updateValue($event)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </label>\n      </div>\n    </div>`,\n})\nexport class RadiosComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  layoutOrientation = 'vertical';\n  radiosList: any[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    if (this.layoutNode.type === 'radios-inline' ||\n      this.layoutNode.type === 'radiobuttons'\n    ) {\n      this.layoutOrientation = 'horizontal';\n    }\n    this.radiosList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, true\n    );\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, Host } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { hasValue, JsonPointer } from '../shared';\n\n@Component({\n  selector: 'root-widget',\n  template: `\n    <div *ngFor=\"let layoutItem of layout; let i = index\"\n      [class.form-flex-item]=\"isFlexItem\"\n      [style.align-self]=\"(layoutItem.options || {})['align-self']\"\n      [style.flex-basis]=\"getFlexAttribute(layoutItem, 'flex-basis')\"\n      [style.flex-grow]=\"getFlexAttribute(layoutItem, 'flex-grow')\"\n      [style.flex-shrink]=\"getFlexAttribute(layoutItem, 'flex-shrink')\"\n      [style.order]=\"(layoutItem.options || {}).order\">\n      <div\n        [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"\n        [orderable]=\"isDraggable(layoutItem)\">\n        <select-framework-widget *ngIf=\"showWidget(layoutItem)\"\n          [dataIndex]=\"layoutItem?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n          [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n          [layoutNode]=\"layoutItem\"></select-framework-widget>\n      </div>\n    </div>`,\n  styles: [`\n    [draggable=true] {\n      transition: all 150ms cubic-bezier(.4, 0, .2, 1);\n    }\n    [draggable=true]:hover {\n      cursor: move;\n      box-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);\n      position: relative; z-index: 10;\n      margin-top: -1px;\n      margin-left: -1px;\n      margin-right: 1px;\n      margin-bottom: 1px;\n    }\n    [draggable=true].drag-target-top {\n      box-shadow: 0 -2px 0 #000;\n      position: relative; z-index: 20;\n    }\n    [draggable=true].drag-target-bottom {\n      box-shadow: 0 2px 0 #000;\n      position: relative; z-index: 20;\n    }\n  `],\n})\nexport class RootComponent {\n  options: any;\n  @Input() dataIndex: number[];\n  @Input() layoutIndex: number[];\n  @Input() layout: any[];\n  @Input() isOrderable: boolean;\n  @Input() isFlexItem = false;\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  isDraggable(node: any): boolean {\n    return node.arrayItem && node.type !== '$ref' &&\n      node.arrayItemType === 'list' && this.isOrderable !== false;\n  }\n\n  // Set attributes for flexbox child\n  // (container attributes are set in section.component)\n  getFlexAttribute(node: any, attribute: string) {\n    const index = ['flex-grow', 'flex-shrink', 'flex-basis'].indexOf(attribute);\n    return ((node.options || {}).flex || '').split(/\\s+/)[index] ||\n      (node.options || {})[attribute] || ['1', '1', 'auto'][index];\n  }\n\n  showWidget(layoutNode: any): boolean {\n    return this.jsf.evaluateCondition(layoutNode, this.dataIndex);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\n\nimport { toTitleCase } from '../shared';\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'section-widget',\n  template: `\n    <div *ngIf=\"containerType === 'div'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <label *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></label>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n    </div>\n    <fieldset *ngIf=\"containerType === 'fieldset'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\"\n      [disabled]=\"options?.readonly\">\n      <legend *ngIf=\"sectionTitle\"\n        class=\"legend\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></legend>\n      <div *ngIf=\"options?.messageLocation !== 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n      <root-widget *ngIf=\"expanded\"\n        [dataIndex]=\"dataIndex\"\n        [layout]=\"layoutNode.items\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [isOrderable]=\"options?.orderable\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"></root-widget>\n      <div *ngIf=\"options?.messageLocation === 'bottom'\">\n        <p *ngIf=\"options?.description\"\n        class=\"help-block\"\n        [class]=\"options?.labelHelpBlockClass || ''\"\n        [innerHTML]=\"options?.description\"></p>\n      </div>\n    </fieldset>`,\n  styles: [`\n    .legend { font-weight: bold; }\n    .expandable > legend:before, .expandable > label:before  { content: ''; padding-right: .3em; }\n    .expanded > legend:before, .expanded > label:before  { content: ''; padding-right: .2em; }\n  `],\n})\nexport class SectionComponent implements OnInit {\n  options: any;\n  expanded = true;\n  containerType: string;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  get sectionTitle() {\n    return this.options.notitle ? null : this.jsf.setItemTitle(this);\n  }\n\n  ngOnInit() {\n    this.jsf.initializeControl(this);\n    this.options = this.layoutNode.options || {};\n    this.expanded = typeof this.options.expanded === 'boolean' ?\n      this.options.expanded : !this.options.expandable;\n    switch (this.layoutNode.type) {\n      case 'fieldset': case 'array': case 'tab': case 'advancedfieldset':\n      case 'authfieldset': case 'optionfieldset': case 'selectfieldset':\n        this.containerType = 'fieldset';\n      break;\n      default: // 'div', 'flex', 'section', 'conditional', 'actions', 'tagsinput'\n        this.containerType = 'div';\n      break;\n    }\n  }\n\n  toggleExpanded() {\n    if (this.options.expandable) { this.expanded = !this.expanded; }\n  }\n\n  // Set attributes for flexbox container\n  // (child attributes are set in root.component)\n  getFlexAttribute(attribute: string) {\n    const flexActive: boolean =\n      this.layoutNode.type === 'flex' ||\n      !!this.options.displayFlex ||\n      this.options.display === 'flex';\n    if (attribute !== 'flex' && !flexActive) { return null; }\n    switch (attribute) {\n      case 'is-flex':\n        return flexActive;\n      case 'display':\n        return flexActive ? 'flex' : 'initial';\n      case 'flex-direction': case 'flex-wrap':\n        const index = ['flex-direction', 'flex-wrap'].indexOf(attribute);\n        return (this.options['flex-flow'] || '').split(/\\s+/)[index] ||\n          this.options[attribute] || ['column', 'nowrap'][index];\n      case 'justify-content': case 'align-items': case 'align-content':\n        return this.options[attribute];\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { buildTitleMap, isArray } from '../shared';\n\n@Component({\n  selector: 'select-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <select *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n      <select *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        (change)=\"updateValue($event)\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <option *ngIf=\"!isArray(selectItem?.items)\"\n            [selected]=\"selectItem?.value === controlValue\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </option>\n          <optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <option *ngFor=\"let subItem of selectItem.items\"\n              [attr.selected]=\"subItem?.value === controlValue\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </option>\n          </optgroup>\n        </ng-template>\n      </select>\n    </div>`,\n})\nexport class SelectComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  selectList: any[] = [];\n  isArray = isArray;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.selectList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, !!this.options.required, !!this.options.flatList\n    );\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'select-framework-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class SelectFrameworkComponent implements OnChanges, OnInit {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (!this.newComponent && this.jsf.framework) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.jsf.framework)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n",
    "import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'select-widget-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class SelectWidgetComponent implements OnChanges, OnInit {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (!this.newComponent && (this.layoutNode || {}).widget) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.layoutNode.widget)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\nimport { hasOwn } from '../shared/utility.functions';\n\n@Component({\n  selector: 'submit-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <input\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n    </div>`,\n})\nexport class SubmitComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (hasOwn(this.options, 'disabled')) {\n      this.controlDisabled = this.options.disabled;\n    } else if (this.jsf.formOptions.disableInvalidSubmit) {\n      this.controlDisabled = !this.jsf.isValid;\n      this.jsf.isValidChanges.subscribe(isValid => this.controlDisabled = !isValid);\n    }\n    if (this.controlValue === null || this.controlValue === undefined) {\n      this.controlValue = this.options.title;\n    }\n  }\n\n  updateValue(event) {\n    if (typeof this.options.onClick === 'function') {\n      this.options.onClick(event);\n    } else {\n      this.jsf.updateValue(this, event.target.value);\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'tabs-widget',\n  template: `\n    <ul\n      [class]=\"options?.labelHtmlClass || ''\">\n      <li *ngFor=\"let item of layoutNode?.items; let i = index\"\n        [class]=\"(options?.itemLabelHtmlClass || '') + (selectedItem === i ?\n          (' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')) :\n          (' ' + options?.style?.unselected))\"\n        role=\"presentation\"\n        data-tabs>\n        <a *ngIf=\"showAddTab || item.type !== '$ref'\"\n           [class]=\"'nav-link' + (selectedItem === i ? (' ' + options?.activeClass + ' ' + options?.style?.selected) :\n            (' ' + options?.style?.unselected))\"\n          [innerHTML]=\"setTabTitle(item, i)\"\n          (click)=\"select(i)\"></a>\n      </li>\n    </ul>\n\n    <div *ngFor=\"let layoutItem of layoutNode?.items; let i = index\"\n      [class]=\"options?.htmlClass || ''\">\n\n      <select-framework-widget *ngIf=\"selectedItem === i\"\n        [class]=\"(options?.fieldHtmlClass || '') +\n          ' ' + (options?.activeClass || '') +\n          ' ' + (options?.style?.selected || '')\"\n        [dataIndex]=\"layoutNode?.dataType === 'array' ? (dataIndex || []).concat(i) : dataIndex\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"></select-framework-widget>\n\n    </div>`,\n  styles: [` a { cursor: pointer; } `],\n})\nexport class TabsComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  selectedItem = 0;\n  showAddTab = true;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.itemCount = this.layoutNode.items.length - 1;\n    this.updateControl();\n  }\n\n  select(index) {\n    if (this.layoutNode.items[index].type === '$ref') {\n      this.itemCount = this.layoutNode.items.length;\n      this.jsf.addItem({\n        layoutNode: this.layoutNode.items[index],\n        layoutIndex: this.layoutIndex.concat(index),\n        dataIndex: this.dataIndex.concat(index)\n      });\n      this.updateControl();\n    }\n    this.selectedItem = index;\n  }\n\n  updateControl() {\n    const lastItem = this.layoutNode.items[this.layoutNode.items.length - 1];\n    if (lastItem.type === '$ref' &&\n      this.itemCount >= (lastItem.options.maxItems || 1000)\n    ) {\n      this.showAddTab = false;\n    }\n  }\n\n  setTabTitle(item: any, index: number): string {\n    return this.jsf.setArrayItemTitle(this, item, index);\n  }\n}\n",
    "import {\n  Component, ComponentFactoryResolver, ComponentRef, Input,\n  OnChanges, OnInit, ViewChild, ViewContainerRef\n} from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'template-widget',\n  template: `<div #widgetContainer></div>`,\n})\nexport class TemplateComponent implements OnInit, OnChanges {\n  newComponent: ComponentRef<any> = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n  @ViewChild('widgetContainer', { read: ViewContainerRef })\n    widgetContainer: ViewContainerRef;\n\n  constructor(\n    private componentFactory: ComponentFactoryResolver,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.updateComponent();\n  }\n\n  ngOnChanges() {\n    this.updateComponent();\n  }\n\n  updateComponent() {\n    if (!this.newComponent && this.layoutNode.options.template) {\n      this.newComponent = this.widgetContainer.createComponent(\n        this.componentFactory.resolveComponentFactory(this.layoutNode.options.template)\n      );\n    }\n    if (this.newComponent) {\n      for (const input of ['layoutNode', 'layoutIndex', 'dataIndex']) {\n        this.newComponent.instance[input] = this[input];\n      }\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'textarea-widget',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\">\n      <label *ngIf=\"options?.title\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <textarea *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"></textarea>\n      <textarea *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [attr.placeholder]=\"options?.placeholder\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [class]=\"options?.fieldHtmlClass || ''\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\">{{controlValue}}</textarea>\n    </div>`,\n})\nexport class TextareaComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { hasOwn } from '../shared/utility.functions';\n\nimport { AddReferenceComponent } from './add-reference.component';\nimport { OneOfComponent } from './one-of.component';\nimport { ButtonComponent } from './button.component';\nimport { CheckboxComponent } from './checkbox.component';\nimport { CheckboxesComponent } from './checkboxes.component';\nimport { FileComponent } from './file.component';\nimport { HiddenComponent } from './hidden.component';\nimport { InputComponent } from './input.component';\nimport { MessageComponent } from './message.component';\nimport { NoneComponent } from './none.component';\nimport { NumberComponent } from './number.component';\nimport { RadiosComponent } from './radios.component';\nimport { RootComponent } from './root.component';\nimport { SectionComponent } from './section.component';\nimport { SelectComponent } from './select.component';\nimport { SelectFrameworkComponent } from './select-framework.component';\nimport { SelectWidgetComponent } from './select-widget.component';\nimport { SubmitComponent } from './submit.component';\nimport { TabComponent } from './tab.component';\nimport { TabsComponent } from './tabs.component';\nimport { TemplateComponent } from './template.component';\nimport { TextareaComponent } from './textarea.component';\n\n@Injectable()\nexport class WidgetLibraryService {\n\n  defaultWidget = 'text';\n  widgetLibrary: any = {\n\n  // Angular JSON Schema Form administrative widgets\n    'none': NoneComponent, // Placeholder, for development - displays nothing\n    'root': RootComponent, // Form root, renders a complete layout\n    'select-framework': SelectFrameworkComponent, // Applies the selected framework to a specified widget\n    'select-widget': SelectWidgetComponent, // Displays a specified widget\n    '$ref': AddReferenceComponent, // Button to add a new array item or $ref element\n\n  // Free-form text HTML 'input' form control widgets <input type=\"...\">\n    'email': 'text',\n    'integer': 'number', // Note: 'integer' is not a recognized HTML input type\n    'number': NumberComponent,\n    'password': 'text',\n    'search': 'text',\n    'tel': 'text',\n    'text': InputComponent,\n    'url': 'text',\n\n  // Controlled text HTML 'input' form control widgets <input type=\"...\">\n    'color': 'text',\n    'date': 'text',\n    'datetime': 'text',\n    'datetime-local': 'text',\n    'month': 'text',\n    'range': 'number',\n    'time': 'text',\n    'week': 'text',\n\n  // Non-text HTML 'input' form control widgets <input type=\"...\">\n    // 'button': <input type=\"button\"> not used, use <button> instead\n    'checkbox': CheckboxComponent, // TODO: Set ternary = true for 3-state ??\n    'file': FileComponent, // TODO: Finish 'file' widget\n    'hidden': 'text',\n    'image': 'text', // TODO: Figure out how to handle these\n    'radio': 'radios',\n    'reset': 'submit', // TODO: Figure out how to handle these\n    'submit': SubmitComponent,\n\n  // Other (non-'input') HTML form control widgets\n    'button': ButtonComponent,\n    'select': SelectComponent,\n    // 'option': automatically generated by select widgets\n    // 'optgroup': automatically generated by select widgets\n    'textarea': TextareaComponent,\n\n  // HTML form control widget sets\n    'checkboxes': CheckboxesComponent, // Grouped list of checkboxes\n    'checkboxes-inline': 'checkboxes', // Checkboxes in one line\n    'checkboxbuttons': 'checkboxes', // Checkboxes as html buttons\n    'radios': RadiosComponent, // Grouped list of radio buttons\n    'radios-inline': 'radios', // Radio controls in one line\n    'radiobuttons': 'radios', // Radio controls as html buttons\n\n  // HTML Layout widgets\n    // 'label': automatically added to data widgets\n    // 'legend': automatically added to fieldsets\n    'section': SectionComponent, // Just a div <div>\n    'div': 'section', // Still just a div <div>\n    'fieldset': 'section', // A fieldset, with an optional legend <fieldset>\n    'flex': 'section', // A flexbox container <div style=\"display: flex\">\n\n  // Non-HTML layout widgets\n    'one-of': OneOfComponent, // A select box that changes another input\n                              // TODO: Finish 'one-of' widget\n    'array': 'section', // A list you can add, remove and reorder <fieldset>\n    'tabarray': 'tabs', // A tabbed version of array\n    'tab': 'section', // A tab group, similar to a fieldset or section <fieldset>\n    'tabs': TabsComponent, // A tabbed set of panels with different controls\n    'message': MessageComponent, // Insert arbitrary html\n    'help': 'message', // Insert arbitrary html\n    'msg': 'message', // Insert arbitrary html\n    'html': 'message', // Insert arbitrary html\n    'template': TemplateComponent, // Insert a custom Angular component\n\n  // Widgets included for compatibility with JSON Form API\n    'advancedfieldset': 'section', // Adds 'Advanced settings' title <fieldset>\n    'authfieldset': 'section', // Adds 'Authentication settings' title <fieldset>\n    'optionfieldset': 'one-of', // Option control, displays selected sub-item <fieldset>\n    'selectfieldset': 'one-of', // Select control, displays selected sub-item <fieldset>\n    'conditional': 'section', // Identical to 'section' (depeciated) <div>\n    'actions': 'section', // Horizontal button list, can only submit, uses buttons as items <div>\n    'tagsinput': 'section', // For entering short text tags <div>\n    // See: http://ulion.github.io/jsonform/playground/?example=fields-checkboxbuttons\n\n  // Widgets included for compatibility with React JSON Schema Form API\n    'updown': 'number',\n    'date-time': 'datetime-local',\n    'alt-datetime': 'datetime-local',\n    'alt-date': 'date',\n\n  // Widgets included for compatibility with Angular Schema Form API\n    'wizard': 'section', // TODO: Sequential panels with \"Next\" and \"Previous\" buttons\n\n  // Widgets included for compatibility with other libraries\n    'textline': 'text',\n\n  // Recommended 3rd-party add-on widgets (TODO: create wrappers for these...)\n    // 'ng2-select': Select control replacement - http://valor-software.com/ng2-select/\n    // 'flatpickr': Flatpickr date picker - https://github.com/chmln/flatpickr\n    // 'pikaday': Pikaday date picker - https://github.com/dbushell/Pikaday\n    // 'spectrum': Spectrum color picker - http://bgrins.github.io/spectrum\n    // 'bootstrap-slider': Bootstrap Slider range control - https://github.com/seiyria/bootstrap-slider\n    // 'ace': ACE code editor - https://ace.c9.io\n    // 'ckeditor': CKEditor HTML / rich text editor - http://ckeditor.com\n    // 'tinymce': TinyMCE HTML / rich text editor - https://www.tinymce.com\n    // 'imageselect': Bootstrap drop-down image selector - http://silviomoreto.github.io/bootstrap-select\n    // 'wysihtml5': HTML editor - http://jhollingworth.github.io/bootstrap-wysihtml5\n    // 'quill': Quill HTML / rich text editor (?) - https://quilljs.com\n  };\n  registeredWidgets: any = { };\n  frameworkWidgets: any = { };\n  activeWidgets: any = { };\n\n  constructor() {\n    this.setActiveWidgets();\n  }\n\n  setActiveWidgets(): boolean {\n    this.activeWidgets = Object.assign(\n      { }, this.widgetLibrary, this.frameworkWidgets, this.registeredWidgets\n    );\n    for (const widgetName of Object.keys(this.activeWidgets)) {\n      let widget: any = this.activeWidgets[widgetName];\n      // Resolve aliases\n      if (typeof widget === 'string') {\n        const usedAliases: string[] = [];\n        while (typeof widget === 'string' && !usedAliases.includes(widget)) {\n          usedAliases.push(widget);\n          widget = this.activeWidgets[widget];\n        }\n        if (typeof widget !== 'string') {\n          this.activeWidgets[widgetName] = widget;\n        }\n      }\n    }\n    return true;\n  }\n\n  setDefaultWidget(type: string): boolean {\n    if (!this.hasWidget(type)) { return false; }\n    this.defaultWidget = type;\n    return true;\n  }\n\n  hasWidget(type: string, widgetSet = 'activeWidgets'): boolean {\n    if (!type || typeof type !== 'string') { return false; }\n    return hasOwn(this[widgetSet], type);\n  }\n\n  hasDefaultWidget(type: string): boolean {\n    return this.hasWidget(type, 'widgetLibrary');\n  }\n\n  registerWidget(type: string, widget: any): boolean {\n    if (!type || !widget || typeof type !== 'string') { return false; }\n    this.registeredWidgets[type] = widget;\n    return this.setActiveWidgets();\n  }\n\n  unRegisterWidget(type: string): boolean {\n    if (!hasOwn(this.registeredWidgets, type)) { return false; }\n    delete this.registeredWidgets[type];\n    return this.setActiveWidgets();\n  }\n\n  unRegisterAllWidgets(unRegisterFrameworkWidgets = true): boolean {\n    this.registeredWidgets = { };\n    if (unRegisterFrameworkWidgets) { this.frameworkWidgets = { }; }\n    return this.setActiveWidgets();\n  }\n\n  registerFrameworkWidgets(widgets: any): boolean {\n    if (widgets === null || typeof widgets !== 'object') { widgets = { }; }\n    this.frameworkWidgets = widgets;\n    return this.setActiveWidgets();\n  }\n\n  unRegisterFrameworkWidgets(): boolean {\n    if (Object.keys(this.frameworkWidgets).length) {\n      this.frameworkWidgets = { };\n      return this.setActiveWidgets();\n    }\n    return false;\n  }\n\n  getWidget(type?: string, widgetSet = 'activeWidgets'): any {\n    if (this.hasWidget(type, widgetSet)) {\n      return this[widgetSet][type];\n    } else if (this.hasWidget(this.defaultWidget, widgetSet)) {\n      return this[widgetSet][this.defaultWidget];\n    } else {\n      return null;\n    }\n  }\n\n  getAllWidgets(): any {\n    return {\n      widgetLibrary: this.widgetLibrary,\n      registeredWidgets: this.registeredWidgets,\n      frameworkWidgets: this.frameworkWidgets,\n      activeWidgets: this.activeWidgets,\n    };\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\n@Injectable()\nexport class Framework {\n  name: string;\n  framework: any;\n  widgets?: { [key: string]: any } = {};\n  stylesheets?: string[] = [];\n  scripts?: string[] = [];\n}\n",
    "import { Inject, Injectable } from '@angular/core';\n\nimport { WidgetLibraryService } from '../widget-library/widget-library.service';\nimport { hasOwn } from '../shared/utility.functions';\n\nimport { Framework } from './framework';\n\n// Possible future frameworks:\n// - Foundation 6:\n//   http://justindavis.co/2017/06/15/using-foundation-6-in-angular-4/\n//   https://github.com/zurb/foundation-sites\n// - Semantic UI:\n//   https://github.com/edcarroll/ng2-semantic-ui\n//   https://github.com/vladotesanovic/ngSemantic\n\n@Injectable()\nexport class FrameworkLibraryService {\n  activeFramework: Framework = null;\n  stylesheets: (HTMLStyleElement|HTMLLinkElement)[];\n  scripts: HTMLScriptElement[];\n  loadExternalAssets = false;\n  defaultFramework: string;\n  frameworkLibrary: { [name: string]: Framework } = {};\n\n  constructor(\n    @Inject(Framework) private frameworks: any[],\n    @Inject(WidgetLibraryService) private widgetLibrary: WidgetLibraryService\n  ) {\n    this.frameworks.forEach(framework =>\n      this.frameworkLibrary[framework.name] = framework\n    );\n    this.defaultFramework = this.frameworks[0].name;\n    this.setFramework(this.defaultFramework);\n  }\n\n  public setLoadExternalAssets(loadExternalAssets = true): void {\n    this.loadExternalAssets = !!loadExternalAssets;\n  }\n\n  public setFramework(\n    framework: string|Framework = this.defaultFramework,\n    loadExternalAssets = this.loadExternalAssets\n  ): boolean {\n    this.activeFramework =\n      typeof framework === 'string' && this.hasFramework(framework) ?\n        this.frameworkLibrary[framework] :\n      typeof framework === 'object' && hasOwn(framework, 'framework') ?\n        framework :\n        this.frameworkLibrary[this.defaultFramework];\n    return this.registerFrameworkWidgets(this.activeFramework);\n  }\n\n  registerFrameworkWidgets(framework: Framework): boolean {\n    return hasOwn(framework, 'widgets') ?\n      this.widgetLibrary.registerFrameworkWidgets(framework.widgets) :\n      this.widgetLibrary.unRegisterFrameworkWidgets();\n  }\n\n  public hasFramework(type: string): boolean {\n    return hasOwn(this.frameworkLibrary, type);\n  }\n\n  public getFramework(): any {\n    if (!this.activeFramework) { this.setFramework('default', true); }\n    return this.activeFramework.framework;\n  }\n\n  public getFrameworkWidgets(): any {\n    return this.activeFramework.widgets || {};\n  }\n\n  public getFrameworkStylesheets(load: boolean = this.loadExternalAssets): string[] {\n    return (load && this.activeFramework.stylesheets) || [];\n  }\n\n  public getFrameworkScripts(load: boolean = this.loadExternalAssets): string[] {\n    return (load && this.activeFramework.scripts) || [];\n  }\n}\n",
    "import {\n  ChangeDetectionStrategy, ChangeDetectorRef, Component, EventEmitter,\n  forwardRef, Input, Output, OnChanges, OnInit\n} from '@angular/core';\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { DomSanitizer, SafeResourceUrl } from '@angular/platform-browser';\n\nimport * as _ from 'lodash';\n\nimport { FrameworkLibraryService } from './framework-library/framework-library.service';\nimport { WidgetLibraryService } from './widget-library/widget-library.service';\nimport { JsonSchemaFormService } from './json-schema-form.service';\nimport { convertSchemaToDraft6 } from './shared/convert-schema-to-draft6.function';\nimport { resolveSchemaReferences } from './shared/json-schema.functions';\nimport {\n  hasValue, inArray, isArray, isEmpty, isNumber, isObject\n} from './shared/validator.functions';\nimport { forEach, hasOwn } from './shared/utility.functions';\nimport { JsonPointer } from './shared/jsonpointer.functions';\n\nexport const JSON_SCHEMA_FORM_VALUE_ACCESSOR: any = {\n  provide: NG_VALUE_ACCESSOR,\n  // tslint:disable-next-line no-use-before-declare\n  useExisting: forwardRef(() => JsonSchemaFormComponent),\n  multi: true,\n};\n\n/**\n * @module 'JsonSchemaFormComponent' - Angular JSON Schema Form\n *\n * Root module of the Angular JSON Schema Form client-side library,\n * an Angular library which generates an HTML form from a JSON schema\n * structured data model and/or a JSON Schema Form layout description.\n *\n * This library also validates input data by the user, using both validators on\n * individual controls to provide real-time feedback while the user is filling\n * out the form, and then validating the entire input against the schema when\n * the form is submitted to make sure the returned JSON data object is valid.\n *\n * This library is similar to, and mostly API compatible with:\n *\n * - JSON Schema Form's Angular Schema Form library for AngularJs\n *   http://schemaform.io\n *   http://schemaform.io/examples/bootstrap-example.html (examples)\n *\n * - Mozilla's react-jsonschema-form library for React\n *   https://github.com/mozilla-services/react-jsonschema-form\n *   https://mozilla-services.github.io/react-jsonschema-form (examples)\n *\n * - Joshfire's JSON Form library for jQuery\n *   https://github.com/joshfire/jsonform\n *   http://ulion.github.io/jsonform/playground (examples)\n *\n * This library depends on:\n *  - Angular (obviously)                  https://angular.io\n *  - lodash, JavaScript utility library   https://github.com/lodash/lodash\n *  - ajv, Another JSON Schema validator   https://github.com/epoberezkin/ajv\n *\n * In addition, the Example Playground also depends on:\n *  - brace, Browserified Ace editor       http://thlorenz.github.io/brace\n */\n@Component({\n  selector: 'json-schema-form',\n  template: `\n    <div *ngFor=\"let stylesheet of stylesheets\">\n      <link rel=\"stylesheet\" [href]=\"stylesheet\">\n    </div>\n    <div *ngFor=\"let script of scripts\">\n      <script type=\"text/javascript\" [src]=\"script\"></script>\n    </div>\n    <form class=\"json-schema-form\" (ngSubmit)=\"submitForm()\">\n      <root-widget [layout]=\"jsf?.layout\"></root-widget>\n    </form>\n    <div *ngIf=\"debug || jsf?.formOptions?.debug\">\n      Debug output: <pre>{{debugOutput}}</pre>\n    </div>`,\n  changeDetection: ChangeDetectionStrategy.OnPush,\n  // Adding 'JsonSchemaFormService' here, instead of in the module,\n  // creates a separate instance of the service for each component\n  providers:  [ JsonSchemaFormService, JSON_SCHEMA_FORM_VALUE_ACCESSOR ],\n})\nexport class JsonSchemaFormComponent implements ControlValueAccessor, OnChanges, OnInit {\n  debugOutput: any; // Debug information, if requested\n  formValueSubscription: any = null;\n  formInitialized = false;\n  objectWrap = false; // Is non-object input schema wrapped in an object?\n\n  formValuesInput: string; // Name of the input providing the form data\n  previousInputs: { // Previous input values, to detect which input triggers onChanges\n    schema: any, layout: any[], data: any, options: any, framework: any|string,\n    widgets: any, form: any, model: any, JSONSchema: any, UISchema: any,\n    formData: any, loadExternalAssets: boolean, debug: boolean,\n  } = {\n    schema: null, layout: null, data: null, options: null, framework: null,\n    widgets: null, form: null, model: null, JSONSchema: null, UISchema: null,\n    formData: null, loadExternalAssets: null, debug: null,\n  };\n\n  // Recommended inputs\n  @Input() schema: any; // The JSON Schema\n  @Input() layout: any[]; // The form layout\n  @Input() data: any; // The form data\n  @Input() options: any; // The global form options\n  @Input() framework: any|string; // The framework to load\n  @Input() widgets: any; // Any custom widgets to load\n\n  // Alternate combined single input\n  @Input() form: any; // For testing, and JSON Schema Form API compatibility\n\n  // Angular Schema Form API compatibility input\n  @Input() model: any; // Alternate input for form data\n\n  // React JSON Schema Form API compatibility inputs\n  @Input() JSONSchema: any; // Alternate input for JSON Schema\n  @Input() UISchema: any; // UI schema - alternate form layout format\n  @Input() formData: any; // Alternate input for form data\n\n  @Input() ngModel: any; // Alternate input for Angular forms\n\n  @Input() language: string; // Language\n\n  // Development inputs, for testing and debugging\n  @Input() loadExternalAssets: boolean; // Load external framework assets?\n  @Input() debug: boolean; // Show debug information?\n\n  @Input()\n  get value(): any {\n    return this.objectWrap ? this.jsf.data['1'] : this.jsf.data;\n  }\n  set value(value: any) {\n    this.setFormValues(value, false);\n  }\n\n  // Outputs\n  // tslint:disable no-output-on-prefix\n  @Output() onChanges = new EventEmitter<any>(); // Live unvalidated internal form data\n  @Output() onSubmit = new EventEmitter<any>(); // Complete validated form data\n  // tslint:enable no-output-on-prefix\n  @Output() isValid = new EventEmitter<boolean>(); // Is current data valid?\n  @Output() validationErrors = new EventEmitter<any>(); // Validation errors (if any)\n  @Output() formSchema = new EventEmitter<any>(); // Final schema used to create form\n  @Output() formLayout = new EventEmitter<any>(); // Final layout used to create form\n\n  // Outputs for possible 2-way data binding\n  // Only the one input providing the initial form data will be bound.\n  // If there is no inital data, input '{}' to activate 2-way data binding.\n  // There is no 2-way binding if inital data is combined inside the 'form' input.\n  @Output() dataChange = new EventEmitter<any>();\n  @Output() modelChange = new EventEmitter<any>();\n  @Output() formDataChange = new EventEmitter<any>();\n  @Output() ngModelChange = new EventEmitter<any>();\n\n  onChange: Function;\n  onTouched: Function;\n\n  constructor(\n    private changeDetector: ChangeDetectorRef,\n    private frameworkLibrary: FrameworkLibraryService,\n    private widgetLibrary: WidgetLibraryService,\n    public jsf: JsonSchemaFormService,\n    private sanitizer: DomSanitizer\n  ) { }\n\n  get stylesheets(): SafeResourceUrl[] {\n    const stylesheets = this.frameworkLibrary.getFrameworkStylesheets();\n    const load = this.sanitizer.bypassSecurityTrustResourceUrl;\n    return stylesheets.map(stylesheet => load(stylesheet));\n  }\n\n  get scripts(): SafeResourceUrl[] {\n    const scripts = this.frameworkLibrary.getFrameworkScripts();\n    const load = this.sanitizer.bypassSecurityTrustResourceUrl;\n    return scripts.map(script => load(script));\n  }\n\n  ngOnInit() {\n    this.updateForm();\n  }\n\n  ngOnChanges() {\n    this.updateForm();\n  }\n\n  writeValue(value: any) {\n    this.setFormValues(value, false);\n    if (!this.formValuesInput) { this.formValuesInput = 'ngModel'; }\n  }\n\n  registerOnChange(fn: Function) {\n    this.onChange = fn;\n  }\n\n  registerOnTouched(fn: Function) {\n    this.onTouched = fn;\n  }\n\n  setDisabledState(isDisabled: boolean) {\n    if (this.jsf.formOptions.formDisabled !== !!isDisabled) {\n      this.jsf.formOptions.formDisabled = !!isDisabled;\n      this.initializeForm();\n    }\n  }\n\n  updateForm() {\n    if (!this.formInitialized || !this.formValuesInput ||\n      (this.language && this.language !== this.jsf.language)\n    ) {\n      this.initializeForm();\n    } else {\n      if (this.language && this.language !== this.jsf.language) {\n        this.jsf.setLanguage(this.language);\n      }\n\n      // Get names of changed inputs\n      let changedInput = Object.keys(this.previousInputs)\n        .filter(input => this.previousInputs[input] !== this[input]);\n      let resetFirst = true;\n      if (changedInput.length === 1 && changedInput[0] === 'form' &&\n        this.formValuesInput.startsWith('form.')\n      ) {\n        // If only 'form' input changed, get names of changed keys\n        changedInput = Object.keys(this.previousInputs.form || {})\n          .filter(key => !_.isEqual(this.previousInputs.form[key], this.form[key]))\n          .map(key => `form.${key}`);\n        resetFirst = false;\n      }\n\n      // If only input values have changed, update the form values\n      if (changedInput.length === 1 && changedInput[0] === this.formValuesInput) {\n        if (this.formValuesInput.indexOf('.') === -1) {\n          this.setFormValues(this[this.formValuesInput], resetFirst);\n        } else {\n          const [input, key] = this.formValuesInput.split('.');\n          this.setFormValues(this[input][key], resetFirst);\n        }\n\n      // If anything else has changed, re-render the entire form\n      } else if (changedInput.length) {\n        this.initializeForm();\n        if (this.onChange) { this.onChange(this.jsf.formValues); }\n        if (this.onTouched) { this.onTouched(this.jsf.formValues); }\n      }\n\n      // Update previous inputs\n      Object.keys(this.previousInputs)\n        .filter(input => this.previousInputs[input] !== this[input])\n        .forEach(input => this.previousInputs[input] = this[input]);\n    }\n  }\n\n  setFormValues(formValues: any, resetFirst = true) {\n    if (formValues) {\n      const newFormValues = this.objectWrap ? formValues['1'] : formValues;\n      if (!this.jsf.formGroup) {\n        this.jsf.formValues = formValues;\n        this.activateForm();\n      } else if (resetFirst) {\n        this.jsf.formGroup.reset();\n      }\n      if (this.jsf.formGroup) {\n        this.jsf.formGroup.patchValue(newFormValues);\n      }\n      if (this.onChange) { this.onChange(newFormValues); }\n      if (this.onTouched) { this.onTouched(newFormValues); }\n    } else {\n      this.jsf.formGroup.reset();\n    }\n  }\n\n  submitForm() {\n    const validData = this.jsf.validData;\n    this.onSubmit.emit(this.objectWrap ? validData['1'] : validData);\n  }\n\n  /**\n   * 'initializeForm' function\n   *\n   * - Update 'schema', 'layout', and 'formValues', from inputs.\n   *\n   * - Create 'schemaRefLibrary' and 'schemaRecursiveRefMap'\n   *   to resolve schema $ref links, including recursive $ref links.\n   *\n   * - Create 'dataRecursiveRefMap' to resolve recursive links in data\n   *   and corectly set output formats for recursively nested values.\n   *\n   * - Create 'layoutRefLibrary' and 'templateRefLibrary' to store\n   *   new layout nodes and formGroup elements to use when dynamically\n   *   adding form components to arrays and recursive $ref points.\n   *\n   * - Create 'dataMap' to map the data to the schema and template.\n   *\n   * - Create the master 'formGroupTemplate' then from it 'formGroup'\n   *   the Angular formGroup used to control the reactive form.\n   */\n  initializeForm() {\n    if (\n      this.schema || this.layout || this.data || this.form || this.model ||\n      this.JSONSchema || this.UISchema || this.formData || this.ngModel ||\n      this.jsf.data\n    ) {\n\n      this.jsf.resetAllValues();  // Reset all form values to defaults\n      this.initializeOptions();   // Update options\n      this.initializeSchema();    // Update schema, schemaRefLibrary,\n                                  // schemaRecursiveRefMap, & dataRecursiveRefMap\n      this.initializeLayout();    // Update layout, layoutRefLibrary,\n      this.initializeData();      // Update formValues\n      this.activateForm();        // Update dataMap, templateRefLibrary,\n                                  // formGroupTemplate, formGroup\n\n      // Uncomment individual lines to output debugging information to console:\n      // (These always work.)\n      // console.log('loading form...');\n      // console.log('schema', this.jsf.schema);\n      // console.log('layout', this.jsf.layout);\n      // console.log('options', this.options);\n      // console.log('formValues', this.jsf.formValues);\n      // console.log('formGroupTemplate', this.jsf.formGroupTemplate);\n      // console.log('formGroup', this.jsf.formGroup);\n      // console.log('formGroup.value', this.jsf.formGroup.value);\n      // console.log('schemaRefLibrary', this.jsf.schemaRefLibrary);\n      // console.log('layoutRefLibrary', this.jsf.layoutRefLibrary);\n      // console.log('templateRefLibrary', this.jsf.templateRefLibrary);\n      // console.log('dataMap', this.jsf.dataMap);\n      // console.log('arrayMap', this.jsf.arrayMap);\n      // console.log('schemaRecursiveRefMap', this.jsf.schemaRecursiveRefMap);\n      // console.log('dataRecursiveRefMap', this.jsf.dataRecursiveRefMap);\n\n      // Uncomment individual lines to output debugging information to browser:\n      // (These only work if the 'debug' option has also been set to 'true'.)\n      if (this.debug || this.jsf.formOptions.debug) {\n        const vars: any[] = [];\n        // vars.push(this.jsf.schema);\n        // vars.push(this.jsf.layout);\n        // vars.push(this.options);\n        // vars.push(this.jsf.formValues);\n        // vars.push(this.jsf.formGroup.value);\n        // vars.push(this.jsf.formGroupTemplate);\n        // vars.push(this.jsf.formGroup);\n        // vars.push(this.jsf.schemaRefLibrary);\n        // vars.push(this.jsf.layoutRefLibrary);\n        // vars.push(this.jsf.templateRefLibrary);\n        // vars.push(this.jsf.dataMap);\n        // vars.push(this.jsf.arrayMap);\n        // vars.push(this.jsf.schemaRecursiveRefMap);\n        // vars.push(this.jsf.dataRecursiveRefMap);\n        this.debugOutput = vars.map(v => JSON.stringify(v, null, 2)).join('\\n');\n      }\n      this.formInitialized = true;\n    }\n  }\n\n  /**\n   * 'initializeOptions' function\n   *\n   * Initialize 'options' (global form options) and set framework\n   * Combine available inputs:\n   * 1. options - recommended\n   * 2. form.options - Single input style\n   */\n  private initializeOptions() {\n    if (this.language && this.language !== this.jsf.language) {\n      this.jsf.setLanguage(this.language);\n    }\n    this.jsf.setOptions({ debug: !!this.debug });\n    let loadExternalAssets: boolean = this.loadExternalAssets || false;\n    let framework: any = this.framework || 'default';\n    if (isObject(this.options)) {\n      this.jsf.setOptions(this.options);\n      loadExternalAssets = this.options.loadExternalAssets || loadExternalAssets;\n      framework = this.options.framework || framework;\n    }\n    if (isObject(this.form) && isObject(this.form.options)) {\n      this.jsf.setOptions(this.form.options);\n      loadExternalAssets = this.form.options.loadExternalAssets || loadExternalAssets;\n      framework = this.form.options.framework || framework;\n    }\n    if (isObject(this.widgets)) {\n      this.jsf.setOptions({ widgets: this.widgets });\n    }\n    this.frameworkLibrary.setLoadExternalAssets(loadExternalAssets);\n    this.frameworkLibrary.setFramework(framework);\n    this.jsf.framework = this.frameworkLibrary.getFramework();\n    if (isObject(this.jsf.formOptions.widgets)) {\n      for (const widget of Object.keys(this.jsf.formOptions.widgets)) {\n        this.widgetLibrary.registerWidget(widget, this.jsf.formOptions.widgets[widget]);\n      }\n    }\n    if (isObject(this.form) && isObject(this.form.tpldata)) {\n      this.jsf.setTpldata(this.form.tpldata);\n    }\n  }\n\n  /**\n   * 'initializeSchema' function\n   *\n   * Initialize 'schema'\n   * Use first available input:\n   * 1. schema - recommended / Angular Schema Form style\n   * 2. form.schema - Single input / JSON Form style\n   * 3. JSONSchema - React JSON Schema Form style\n   * 4. form.JSONSchema - For testing single input React JSON Schema Forms\n   * 5. form - For testing single schema-only inputs\n   *\n   * ... if no schema input found, the 'activateForm' function, below,\n   *     will make two additional attempts to build a schema\n   * 6. If layout input - build schema from layout\n   * 7. If data input - build schema from data\n   */\n  private initializeSchema() {\n\n    // TODO: update to allow non-object schemas\n\n    if (isObject(this.schema)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.schema = _.cloneDeep(this.schema);\n    } else if (hasOwn(this.form, 'schema') && isObject(this.form.schema)) {\n      this.jsf.schema = _.cloneDeep(this.form.schema);\n    } else if (isObject(this.JSONSchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.schema = _.cloneDeep(this.JSONSchema);\n    } else if (hasOwn(this.form, 'JSONSchema') && isObject(this.form.JSONSchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.schema = _.cloneDeep(this.form.JSONSchema);\n    } else if (hasOwn(this.form, 'properties') && isObject(this.form.properties)) {\n      this.jsf.schema = _.cloneDeep(this.form);\n    } else if (isObject(this.form)) {\n      // TODO: Handle other types of form input\n    }\n\n    if (!isEmpty(this.jsf.schema)) {\n\n      // If other types also allowed, render schema as an object\n      if (inArray('object', this.jsf.schema.type)) {\n        this.jsf.schema.type = 'object';\n      }\n\n      // Wrap non-object schemas in object.\n      if (hasOwn(this.jsf.schema, 'type') && this.jsf.schema.type !== 'object') {\n        this.jsf.schema = {\n          'type': 'object',\n          'properties': { 1: this.jsf.schema }\n        };\n        this.objectWrap = true;\n      } else if (!hasOwn(this.jsf.schema, 'type')) {\n\n        // Add type = 'object' if missing\n        if (isObject(this.jsf.schema.properties) ||\n          isObject(this.jsf.schema.patternProperties) ||\n          isObject(this.jsf.schema.additionalProperties)\n        ) {\n          this.jsf.schema.type = 'object';\n\n        // Fix JSON schema shorthand (JSON Form style)\n        } else {\n          this.jsf.JsonFormCompatibility = true;\n          this.jsf.schema = {\n            'type': 'object',\n            'properties': this.jsf.schema\n          };\n        }\n      }\n\n      // If needed, update JSON Schema to draft 6 format, including\n      // draft 3 (JSON Form style) and draft 4 (Angular Schema Form style)\n      this.jsf.schema = convertSchemaToDraft6(this.jsf.schema);\n\n      // Initialize ajv and compile schema\n      this.jsf.compileAjvSchema();\n\n      // Create schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap\n      this.jsf.schema = resolveSchemaReferences(\n        this.jsf.schema, this.jsf.schemaRefLibrary, this.jsf.schemaRecursiveRefMap,\n        this.jsf.dataRecursiveRefMap, this.jsf.arrayMap\n      );\n      if (hasOwn(this.jsf.schemaRefLibrary, '')) {\n        this.jsf.hasRootReference = true;\n      }\n\n      // TODO: (?) Resolve external $ref links\n      // // Create schemaRefLibrary & schemaRecursiveRefMap\n      // this.parser.bundle(this.schema)\n      //   .then(schema => this.schema = resolveSchemaReferences(\n      //     schema, this.jsf.schemaRefLibrary,\n      //     this.jsf.schemaRecursiveRefMap, this.jsf.dataRecursiveRefMap\n      //   ));\n    }\n  }\n\n  /**\n   * 'initializeData' function\n   *\n   * Initialize 'formValues'\n   * defulat or previously submitted values used to populate form\n   * Use first available input:\n   * 1. data - recommended\n   * 2. model - Angular Schema Form style\n   * 3. form.value - JSON Form style\n   * 4. form.data - Single input style\n   * 5. formData - React JSON Schema Form style\n   * 6. form.formData - For easier testing of React JSON Schema Forms\n   * 7. (none) no data - initialize data from schema and layout defaults only\n   */\n  private initializeData() {\n    if (hasValue(this.data)) {\n      this.jsf.formValues = _.cloneDeep(this.data);\n      this.formValuesInput = 'data';\n    } else if (hasValue(this.model)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.model);\n      this.formValuesInput = 'model';\n    } else if (hasValue(this.ngModel)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.ngModel);\n      this.formValuesInput = 'ngModel';\n    } else if (isObject(this.form) && hasValue(this.form.value)) {\n      this.jsf.JsonFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.form.value);\n      this.formValuesInput = 'form.value';\n    } else if (isObject(this.form) && hasValue(this.form.data)) {\n      this.jsf.formValues = _.cloneDeep(this.form.data);\n      this.formValuesInput = 'form.data';\n    } else if (hasValue(this.formData)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.formValuesInput = 'formData';\n    } else if (hasOwn(this.form, 'formData') && hasValue(this.form.formData)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      this.jsf.formValues = _.cloneDeep(this.form.formData);\n      this.formValuesInput = 'form.formData';\n    } else {\n      this.formValuesInput = null;\n    }\n  }\n\n  /**\n   * 'initializeLayout' function\n   *\n   * Initialize 'layout'\n   * Use first available array input:\n   * 1. layout - recommended\n   * 2. form - Angular Schema Form style\n   * 3. form.form - JSON Form style\n   * 4. form.layout - Single input style\n   * 5. (none) no layout - set default layout instead\n   *    (full layout will be built later from the schema)\n   *\n   * Also, if alternate layout formats are available,\n   * import from 'UISchema' or 'customFormItems'\n   * used for React JSON Schema Form and JSON Form API compatibility\n   * Use first available input:\n   * 1. UISchema - React JSON Schema Form style\n   * 2. form.UISchema - For testing single input React JSON Schema Forms\n   * 2. form.customFormItems - JSON Form style\n   * 3. (none) no input - don't import\n   */\n  private initializeLayout() {\n\n    // Rename JSON Form-style 'options' lists to\n    // Angular Schema Form-style 'titleMap' lists.\n    const fixJsonFormOptions = (layout: any): any => {\n      if (isObject(layout) || isArray(layout)) {\n        forEach(layout, (value, key) => {\n          if (hasOwn(value, 'options') && isObject(value.options)) {\n            value.titleMap = value.options;\n            delete value.options;\n          }\n        }, 'top-down');\n      }\n      return layout;\n    };\n\n    // Check for layout inputs and, if found, initialize form layout\n    if (isArray(this.layout)) {\n      this.jsf.layout = _.cloneDeep(this.layout);\n    } else if (isArray(this.form)) {\n      this.jsf.AngularSchemaFormCompatibility = true;\n      this.jsf.layout = _.cloneDeep(this.form);\n    } else if (this.form && isArray(this.form.form)) {\n      this.jsf.JsonFormCompatibility = true;\n      this.jsf.layout = fixJsonFormOptions(_.cloneDeep(this.form.form));\n    } else if (this.form && isArray(this.form.layout)) {\n      this.jsf.layout = _.cloneDeep(this.form.layout);\n    } else {\n      this.jsf.layout = ['*'];\n    }\n\n    // Check for alternate layout inputs\n    let alternateLayout: any = null;\n    if (isObject(this.UISchema)) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = _.cloneDeep(this.UISchema);\n    } else if (hasOwn(this.form, 'UISchema')) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = _.cloneDeep(this.form.UISchema);\n    } else if (hasOwn(this.form, 'uiSchema')) {\n      this.jsf.ReactJsonSchemaFormCompatibility = true;\n      alternateLayout = _.cloneDeep(this.form.uiSchema);\n    } else if (hasOwn(this.form, 'customFormItems')) {\n      this.jsf.JsonFormCompatibility = true;\n      alternateLayout = fixJsonFormOptions(_.cloneDeep(this.form.customFormItems));\n    }\n\n    // if alternate layout found, copy alternate layout options into schema\n    if (alternateLayout) {\n      JsonPointer.forEachDeep(alternateLayout, (value, pointer) => {\n        const schemaPointer = pointer\n          .replace(/\\//g, '/properties/')\n          .replace(/\\/properties\\/items\\/properties\\//g, '/items/properties/')\n          .replace(/\\/properties\\/titleMap\\/properties\\//g, '/titleMap/properties/');\n        if (hasValue(value) && hasValue(pointer)) {\n          let key = JsonPointer.toKey(pointer);\n          const groupPointer = (JsonPointer.parse(schemaPointer) || []).slice(0, -2);\n          let itemPointer: string | string[];\n\n          // If 'ui:order' object found, copy into object schema root\n          if (key.toLowerCase() === 'ui:order') {\n            itemPointer = [...groupPointer, 'ui:order'];\n\n          // Copy other alternate layout options to schema 'x-schema-form',\n          // (like Angular Schema Form options) and remove any 'ui:' prefixes\n          } else {\n            if (key.slice(0, 3).toLowerCase() === 'ui:') { key = key.slice(3); }\n            itemPointer = [...groupPointer, 'x-schema-form', key];\n          }\n          if (JsonPointer.has(this.jsf.schema, groupPointer) &&\n            !JsonPointer.has(this.jsf.schema, itemPointer)\n          ) {\n            JsonPointer.set(this.jsf.schema, itemPointer, value);\n          }\n        }\n      });\n    }\n  }\n\n  /**\n   * 'activateForm' function\n   *\n   * ...continued from 'initializeSchema' function, above\n   * If 'schema' has not been initialized (i.e. no schema input found)\n   * 6. If layout input - build schema from layout input\n   * 7. If data input - build schema from data input\n   *\n   * Create final layout,\n   * build the FormGroup template and the Angular FormGroup,\n   * subscribe to changes,\n   * and activate the form.\n   */\n  private activateForm() {\n\n    // If 'schema' not initialized\n    if (isEmpty(this.jsf.schema)) {\n\n      // TODO: If full layout input (with no '*'), build schema from layout\n      // if (!this.jsf.layout.includes('*')) {\n      //   this.jsf.buildSchemaFromLayout();\n      // } else\n\n      // If data input, build schema from data\n      if (!isEmpty(this.jsf.formValues)) {\n        this.jsf.buildSchemaFromData();\n      }\n    }\n\n    if (!isEmpty(this.jsf.schema)) {\n\n      // If not already initialized, initialize ajv and compile schema\n      this.jsf.compileAjvSchema();\n\n      // Update all layout elements, add values, widgets, and validators,\n      // replace any '*' with a layout built from all schema elements,\n      // and update the FormGroup template with any new validators\n      this.jsf.buildLayout(this.widgetLibrary);\n\n      // Build the Angular FormGroup template from the schema\n      this.jsf.buildFormGroupTemplate(this.jsf.formValues);\n\n      // Build the real Angular FormGroup from the FormGroup template\n      this.jsf.buildFormGroup();\n    }\n\n    if (this.jsf.formGroup) {\n\n      // Reset initial form values\n      if (!isEmpty(this.jsf.formValues) &&\n        this.jsf.formOptions.setSchemaDefaults !== true &&\n        this.jsf.formOptions.setLayoutDefaults !== true\n      ) {\n        this.setFormValues(this.jsf.formValues);\n      }\n\n      // TODO: Figure out how to display calculated values without changing object data\n      // See http://ulion.github.io/jsonform/playground/?example=templating-values\n      // Calculate references to other fields\n      // if (!isEmpty(this.jsf.formGroup.value)) {\n      //   forEach(this.jsf.formGroup.value, (value, key, object, rootObject) => {\n      //     if (typeof value === 'string') {\n      //       object[key] = this.jsf.parseText(value, value, rootObject, key);\n      //     }\n      //   }, 'top-down');\n      // }\n\n      // Subscribe to form changes to output live data, validation, and errors\n      this.jsf.dataChanges.subscribe(data => {\n        this.onChanges.emit(this.objectWrap ? data['1'] : data);\n        if (this.formValuesInput && this.formValuesInput.indexOf('.') === -1) {\n          this[`${this.formValuesInput}Change`].emit(this.objectWrap ? data['1'] : data);\n        }\n      });\n\n      // Trigger change detection on statusChanges to show updated errors\n      this.jsf.formGroup.statusChanges.subscribe(() => this.changeDetector.markForCheck());\n      this.jsf.isValidChanges.subscribe(isValid => this.isValid.emit(isValid));\n      this.jsf.validationErrorChanges.subscribe(err => this.validationErrors.emit(err));\n\n      // Output final schema, final layout, and initial data\n      this.formSchema.emit(this.jsf.schema);\n      this.formLayout.emit(this.jsf.layout);\n      this.onChanges.emit(this.objectWrap ? this.jsf.data['1'] : this.jsf.data);\n\n      // If validateOnRender, output initial validation and any errors\n      const validateOnRender =\n        JsonPointer.get(this.jsf, '/formOptions/validateOnRender');\n      if (validateOnRender) { // validateOnRender === 'auto' || true\n        const touchAll = (control) => {\n          if (validateOnRender === true || hasValue(control.value)) {\n            control.markAsTouched();\n          }\n          Object.keys(control.controls || {})\n            .forEach(key => touchAll(control.controls[key]));\n        };\n        touchAll(this.jsf.formGroup);\n        this.isValid.emit(this.jsf.isValid);\n        this.validationErrors.emit(this.jsf.ajvErrors);\n      }\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'hidden-widget',\n  template: `\n    <input *ngIf=\"boundControl\"\n      [formControl]=\"formControl\"\n      [id]=\"'control' + layoutNode?._id\"\n      [name]=\"controlName\"\n      type=\"hidden\">\n    <input *ngIf=\"!boundControl\"\n      [disabled]=\"controlDisabled\"\n      [name]=\"controlName\"\n      [id]=\"'control' + layoutNode?._id\"\n      type=\"hidden\"\n      [value]=\"controlValue\">`,\n})\nexport class HiddenComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.jsf.initializeControl(this);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\n@Component({\n  selector: 'tab-widget',\n  template: `\n    <div [class]=\"options?.htmlClass || ''\">\n      <root-widget\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [layout]=\"layoutNode.items\"></root-widget>\n    </div>`,\n})\nexport class TabComponent implements OnInit {\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n  }\n}\n",
    "import { AddReferenceComponent } from './add-reference.component';\nimport { OneOfComponent } from './one-of.component';\nimport { ButtonComponent } from './button.component';\nimport { CheckboxComponent } from './checkbox.component';\nimport { CheckboxesComponent } from './checkboxes.component';\nimport { FileComponent } from './file.component';\nimport { HiddenComponent } from './hidden.component';\nimport { InputComponent } from './input.component';\nimport { MessageComponent } from './message.component';\nimport { NoneComponent } from './none.component';\nimport { NumberComponent } from './number.component';\nimport { RadiosComponent } from './radios.component';\nimport { RootComponent } from './root.component';\nimport { SectionComponent } from './section.component';\nimport { SelectComponent } from './select.component';\nimport { SelectFrameworkComponent } from './select-framework.component';\nimport { SelectWidgetComponent } from './select-widget.component';\nimport { SubmitComponent } from './submit.component';\nimport { TabComponent } from './tab.component';\nimport { TabsComponent } from './tabs.component';\nimport { TemplateComponent } from './template.component';\nimport { TextareaComponent } from './textarea.component';\n\nexport const BASIC_WIDGETS = [\n  AddReferenceComponent, OneOfComponent, ButtonComponent, CheckboxComponent,\n  CheckboxesComponent, FileComponent, HiddenComponent, InputComponent,\n  MessageComponent, NoneComponent, NumberComponent, RadiosComponent,\n  RootComponent, SectionComponent, SelectComponent, SelectFrameworkComponent,\n  SelectWidgetComponent, SubmitComponent, TabComponent, TabsComponent,\n  TemplateComponent, TextareaComponent\n];\n\nexport { AddReferenceComponent } from './add-reference.component';\nexport { OneOfComponent } from './one-of.component';\nexport { ButtonComponent } from './button.component';\nexport { CheckboxComponent } from './checkbox.component';\nexport { CheckboxesComponent } from './checkboxes.component';\nexport { FileComponent } from './file.component';\nexport { HiddenComponent } from './hidden.component';\nexport { InputComponent } from './input.component';\nexport { MessageComponent } from './message.component';\nexport { NoneComponent } from './none.component';\nexport { NumberComponent } from './number.component';\nexport { RadiosComponent } from './radios.component';\nexport { RootComponent } from './root.component';\nexport { SectionComponent } from './section.component';\nexport { SelectComponent } from './select.component';\nexport { SelectFrameworkComponent } from './select-framework.component';\nexport { SelectWidgetComponent } from './select-widget.component';\nexport { SubmitComponent } from './submit.component';\nexport { TabComponent } from './tab.component';\nexport { TabsComponent } from './tabs.component';\nexport { TemplateComponent } from './template.component';\nexport { TextareaComponent } from './textarea.component';\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\nimport { OrderableDirective } from '../shared/orderable.directive';\n\nimport { JsonSchemaFormService } from '../json-schema-form.service';\n\nimport { BASIC_WIDGETS } from './index';\n\n@NgModule({\n  imports:         [ CommonModule, FormsModule, ReactiveFormsModule ],\n  declarations:    [ ...BASIC_WIDGETS, OrderableDirective ],\n  exports:         [ ...BASIC_WIDGETS, OrderableDirective ],\n  entryComponents: [ ...BASIC_WIDGETS ],\n  providers:       [ JsonSchemaFormService ]\n})\nexport class WidgetLibraryModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: WidgetLibraryModule,\n      providers: [ JsonSchemaFormService ]\n    };\n  }\n}\n",
    "import { Component, Input } from '@angular/core';\n\n@Component({\n  selector: 'no-framework',\n  template: `\n    <select-widget-widget\n      [dataIndex]=\"dataIndex\"\n      [layoutIndex]=\"layoutIndex\"\n      [layoutNode]=\"layoutNode\"></select-widget-widget>`,\n})\nexport class NoFrameworkComponent {\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { Framework } from '../framework';\n\n// No framework - plain HTML controls (styles from form layout only)\nimport { NoFrameworkComponent } from './no-framework.component';\n\n@Injectable()\nexport class NoFramework extends Framework {\n  name = 'no-framework';\n\n  framework = NoFrameworkComponent;\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { WidgetLibraryModule } from '../../widget-library/widget-library.module';\nimport { Framework } from '../framework';\n// No framework - plain HTML controls (styles from form layout only)\nimport { NoFrameworkComponent } from './no-framework.component';\nimport { NoFramework } from './no.framework';\n\n@NgModule({\n  imports:         [ CommonModule, WidgetLibraryModule ],\n  declarations:    [ NoFrameworkComponent ],\n  exports:         [ NoFrameworkComponent ],\n  entryComponents: [ NoFrameworkComponent ]\n})\nexport class NoFrameworkModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: NoFrameworkModule,\n      providers: [\n        { provide: Framework, useClass: NoFramework, multi: true }\n      ]\n    };\n  }\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\n\nimport { FrameworkLibraryService } from './framework-library/framework-library.service';\nimport { WidgetLibraryModule } from './widget-library/widget-library.module';\nimport { WidgetLibraryService } from './widget-library/widget-library.service';\n\nimport { JsonSchemaFormComponent } from './json-schema-form.component';\n\nimport { JsonSchemaFormService } from './json-schema-form.service';\n\nimport { NoFrameworkComponent } from './framework-library/no-framework/no-framework.component';\nimport { Framework } from './framework-library/framework';\nimport { NoFramework } from './framework-library/no-framework/no.framework';\nimport { NoFrameworkModule } from './framework-library/no-framework/no-framework.module';\n\n@NgModule({\n  imports: [\n    CommonModule, FormsModule, ReactiveFormsModule,\n    WidgetLibraryModule, NoFrameworkModule\n  ],\n  declarations: [ JsonSchemaFormComponent ],\n  exports: [ JsonSchemaFormComponent, WidgetLibraryModule ]\n})\nexport class JsonSchemaFormModule {\n  static forRoot(...frameworks): ModuleWithProviders {\n    const loadFrameworks = frameworks.length ?\n      frameworks.map(framework => framework.forRoot().providers[0]) :\n      [{ provide: Framework, useClass: NoFramework, multi: true }];\n    return {\n      ngModule: JsonSchemaFormModule,\n      providers: [\n        JsonSchemaFormService, FrameworkLibraryService, WidgetLibraryService,\n        ...loadFrameworks\n      ]\n    };\n  }\n}\n",
    "import { ChangeDetectionStrategy, Component, Input } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { hasValue, JsonPointer } from '../../shared';\n\n@Component({\n  selector: 'flex-layout-root-widget',\n  template: `\n    <div *ngFor=\"let layoutNode of layout; let i = index\"\n      [class.form-flex-item]=\"isFlexItem\"\n      [style.flex-grow]=\"getFlexAttribute(layoutNode, 'flex-grow')\"\n      [style.flex-shrink]=\"getFlexAttribute(layoutNode, 'flex-shrink')\"\n      [style.flex-basis]=\"getFlexAttribute(layoutNode, 'flex-basis')\"\n      [style.align-self]=\"(layoutNode?.options || {})['align-self']\"\n      [style.order]=\"layoutNode?.options?.order\"\n      [fxFlex]=\"layoutNode?.options?.fxFlex\"\n      [fxFlexOrder]=\"layoutNode?.options?.fxFlexOrder\"\n      [fxFlexOffset]=\"layoutNode?.options?.fxFlexOffset\"\n      [fxFlexAlign]=\"layoutNode?.options?.fxFlexAlign\">\n      <select-framework-widget *ngIf=\"showWidget(layoutNode)\"\n        [dataIndex]=\"layoutNode?.arrayItem ? (dataIndex || []).concat(i) : (dataIndex || [])\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutNode\"></select-framework-widget>\n    <div>`,\n  changeDetection: ChangeDetectionStrategy.Default,\n})\nexport class FlexLayoutRootComponent {\n  @Input() dataIndex: number[];\n  @Input() layoutIndex: number[];\n  @Input() layout: any[];\n  @Input() isFlexItem = false;\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  removeItem(item) {\n    this.jsf.removeItem(item);\n  }\n\n  // Set attributes for flexbox child\n  // (container attributes are set in flex-layout-section.component)\n  getFlexAttribute(node: any, attribute: string) {\n    const index = ['flex-grow', 'flex-shrink', 'flex-basis'].indexOf(attribute);\n    return ((node.options || {}).flex || '').split(/\\s+/)[index] ||\n      (node.options || {})[attribute] || ['1', '1', 'auto'][index];\n  }\n\n  showWidget(layoutNode: any): boolean {\n    return this.jsf.evaluateCondition(layoutNode, this.dataIndex);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { toTitleCase } from '../../shared';\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n@Component({\n  selector: 'flex-layout-section-widget',\n  template: `\n    <div *ngIf=\"containerType === 'div'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <label *ngIf=\"sectionTitle\"\n        [class]=\"'legend ' + (options?.labelHtmlClass || '')\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></label>\n      <flex-layout-root-widget *ngIf=\"expanded\"\n        [layout]=\"layoutNode.items\"\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [fxLayout]=\"getFlexAttribute('layout')\"\n        [fxLayoutGap]=\"options?.fxLayoutGap\"\n        [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n        [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>\n\n    <fieldset *ngIf=\"containerType === 'fieldset'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\"\n      [disabled]=\"options?.readonly\">\n      <legend *ngIf=\"sectionTitle\"\n        [class]=\"'legend ' + (options?.labelHtmlClass || '')\"\n        [innerHTML]=\"sectionTitle\"\n        (click)=\"toggleExpanded()\"></legend>\n      <flex-layout-root-widget *ngIf=\"expanded\"\n        [layout]=\"layoutNode.items\"\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [isFlexItem]=\"getFlexAttribute('is-flex')\"\n        [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n        [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n        [style.display]=\"getFlexAttribute('display')\"\n        [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n        [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n        [style.justify-content]=\"getFlexAttribute('justify-content')\"\n        [style.align-items]=\"getFlexAttribute('align-items')\"\n        [style.align-content]=\"getFlexAttribute('align-content')\"\n        [fxLayout]=\"getFlexAttribute('layout')\"\n        [fxLayoutGap]=\"options?.fxLayoutGap\"\n        [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n        [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </fieldset>\n\n    <mat-card *ngIf=\"containerType === 'card'\"\n      [class]=\"options?.htmlClass || ''\"\n      [class.expandable]=\"options?.expandable && !expanded\"\n      [class.expanded]=\"options?.expandable && expanded\">\n      <mat-card-header *ngIf=\"sectionTitle\">\n        <legend\n          [class]=\"'legend ' + (options?.labelHtmlClass || '')\"\n          [innerHTML]=\"sectionTitle\"\n          (click)=\"toggleExpanded()\"></legend>\n      </mat-card-header>\n      <mat-card-content *ngIf=\"expanded\">\n        <fieldset [disabled]=\"options?.readonly\">\n          <flex-layout-root-widget *ngIf=\"expanded\"\n            [layout]=\"layoutNode.items\"\n            [dataIndex]=\"dataIndex\"\n            [layoutIndex]=\"layoutIndex\"\n            [isFlexItem]=\"getFlexAttribute('is-flex')\"\n            [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n            [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n            [style.display]=\"getFlexAttribute('display')\"\n            [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n            [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n            [style.justify-content]=\"getFlexAttribute('justify-content')\"\n            [style.align-items]=\"getFlexAttribute('align-items')\"\n            [style.align-content]=\"getFlexAttribute('align-content')\"\n            [fxLayout]=\"getFlexAttribute('layout')\"\n            [fxLayoutGap]=\"options?.fxLayoutGap\"\n            [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n            [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n          </fieldset>\n      </mat-card-content>\n      <mat-card-footer>\n        <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n          [innerHTML]=\"options?.errorMessage\"></mat-error>\n      </mat-card-footer>\n    </mat-card>\n\n    <mat-expansion-panel *ngIf=\"containerType === 'expansion-panel'\"\n      [expanded]=\"expanded\"\n      [hideToggle]=\"!options?.expandable\">\n      <mat-expansion-panel-header>\n        <mat-panel-title>\n          <legend *ngIf=\"sectionTitle\"\n            [class]=\"options?.labelHtmlClass\"\n            [innerHTML]=\"sectionTitle\"\n            (click)=\"toggleExpanded()\"></legend>\n        </mat-panel-title>\n      </mat-expansion-panel-header>\n      <fieldset [disabled]=\"options?.readonly\">\n        <flex-layout-root-widget *ngIf=\"expanded\"\n          [layout]=\"layoutNode.items\"\n          [dataIndex]=\"dataIndex\"\n          [layoutIndex]=\"layoutIndex\"\n          [isFlexItem]=\"getFlexAttribute('is-flex')\"\n          [class.form-flex-column]=\"getFlexAttribute('flex-direction') === 'column'\"\n          [class.form-flex-row]=\"getFlexAttribute('flex-direction') === 'row'\"\n          [style.display]=\"getFlexAttribute('display')\"\n          [style.flex-direction]=\"getFlexAttribute('flex-direction')\"\n          [style.flex-wrap]=\"getFlexAttribute('flex-wrap')\"\n          [style.justify-content]=\"getFlexAttribute('justify-content')\"\n          [style.align-items]=\"getFlexAttribute('align-items')\"\n          [style.align-content]=\"getFlexAttribute('align-content')\"\n          [fxLayout]=\"getFlexAttribute('layout')\"\n          [fxLayoutGap]=\"options?.fxLayoutGap\"\n          [fxLayoutAlign]=\"options?.fxLayoutAlign\"\n          [attr.fxFlexFill]=\"options?.fxLayoutAlign\"></flex-layout-root-widget>\n      </fieldset>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </mat-expansion-panel>`,\n  styles: [`\n    fieldset { border: 0; margin: 0; padding: 0; }\n    .legend { font-weight: bold; }\n    .expandable > .legend:before { content: ''; padding-right: .3em; }\n    .expanded > .legend:before { content: ''; padding-right: .2em; }\n  `],\n})\nexport class FlexLayoutSectionComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  expanded = true;\n  containerType = 'div';\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  get sectionTitle() {\n    return this.options.notitle ? null : this.jsf.setItemTitle(this);\n  }\n\n  ngOnInit() {\n    this.jsf.initializeControl(this);\n    this.options = this.layoutNode.options || {};\n    this.expanded = typeof this.options.expanded === 'boolean' ?\n      this.options.expanded : !this.options.expandable;\n    switch (this.layoutNode.type) {\n      case 'section': case 'array': case 'fieldset': case 'advancedfieldset':\n      case 'authfieldset': case 'optionfieldset': case 'selectfieldset':\n        this.containerType = 'fieldset';\n      break;\n      case 'card':\n        this.containerType = 'card';\n      break;\n      case 'expansion-panel':\n        this.containerType = 'expansion-panel';\n      break;\n      default: // 'div', 'flex', 'tab', 'conditional', 'actions'\n        this.containerType = 'div';\n    }\n  }\n\n  toggleExpanded() {\n    if (this.options.expandable) { this.expanded = !this.expanded; }\n  }\n\n  // Set attributes for flexbox container\n  // (child attributes are set in flex-layout-root.component)\n  getFlexAttribute(attribute: string) {\n    const flexActive: boolean =\n      this.layoutNode.type === 'flex' ||\n      !!this.options.displayFlex ||\n      this.options.display === 'flex';\n    // if (attribute !== 'flex' && !flexActive) { return null; }\n    switch (attribute) {\n      case 'is-flex':\n        return flexActive;\n      case 'display':\n        return flexActive ? 'flex' : 'initial';\n      case 'flex-direction': case 'flex-wrap':\n        const index = ['flex-direction', 'flex-wrap'].indexOf(attribute);\n        return (this.options['flex-flow'] || '').split(/\\s+/)[index] ||\n          this.options[attribute] || ['column', 'nowrap'][index];\n      case 'justify-content': case 'align-items': case 'align-content':\n        return this.options[attribute];\n      case 'layout':\n        return (this.options.fxLayout || 'row') +\n          this.options.fxLayoutWrap ? ' ' + this.options.fxLayoutWrap : '';\n    }\n  }\n}\n",
    "import { ChangeDetectionStrategy, Component, Input, OnInit } from '@angular/core';\nimport { FormGroup } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n@Component({\n  selector: 'material-add-reference-widget',\n  template: `\n    <section [class]=\"options?.htmlClass || ''\" align=\"end\">\n      <button mat-raised-button *ngIf=\"showAddButton\"\n        [color]=\"options?.color || 'accent'\"\n        [disabled]=\"options?.readonly\"\n        (click)=\"addItem($event)\">\n        <span *ngIf=\"options?.icon\" [class]=\"options?.icon\"></span>\n        <span *ngIf=\"options?.title\" [innerHTML]=\"buttonText\"></span>\n      </button>\n    </section>`,\n  changeDetection: ChangeDetectionStrategy.Default,\n})\nexport class MaterialAddReferenceComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  previousLayoutIndex: number[];\n  previousDataIndex: number[];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n  }\n\n  get showAddButton(): boolean {\n    return !this.layoutNode.arrayItem ||\n      this.layoutIndex[this.layoutIndex.length - 1] < this.options.maxItems;\n  }\n\n  addItem(event) {\n    event.preventDefault();\n    this.jsf.addItem(this);\n  }\n\n  get buttonText(): string {\n    const parent: any = {\n      dataIndex: this.dataIndex.slice(0, -1),\n      layoutIndex: this.layoutIndex.slice(0, -1),\n      layoutNode: this.jsf.getParentNode(this),\n    };\n    return parent.layoutNode.add ||\n      this.jsf.setArrayItemTitle(parent, this.layoutNode, this.itemCount);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'material-one-of-widget',\n  template: ``,\n})\nexport class MaterialOneOfComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { hasOwn } from '../../shared/utility.functions';\n\n@Component({\n  selector: 'material-button-widget',\n  template: `\n    <div class=\"button-row\" [class]=\"options?.htmlClass || ''\">\n      <button mat-raised-button\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [color]=\"options?.color || 'primary'\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (click)=\"updateValue($event)\">\n        <mat-icon *ngIf=\"options?.icon\" class=\"mat-24\">{{options?.icon}}</mat-icon>\n        <span *ngIf=\"options?.title\" [innerHTML]=\"options?.title\"></span>\n      </button>\n    </div>`,\n    styles: [` button { margin-top: 10px; } `],\n})\nexport class MaterialButtonComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (hasOwn(this.options, 'disabled')) {\n      this.controlDisabled = this.options.disabled;\n    } else if (this.jsf.formOptions.disableInvalidSubmit) {\n      this.controlDisabled = !this.jsf.isValid;\n      this.jsf.isValidChanges.subscribe(isValid => this.controlDisabled = !isValid);\n    }\n  }\n\n  updateValue(event) {\n    if (typeof this.options.onClick === 'function') {\n      this.options.onClick(event);\n    } else {\n      this.jsf.updateValue(this, event.target.value);\n    }\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { buildTitleMap } from '../../shared';\n\n@Component({\n  selector: 'material-button-group-widget',\n  template: `\n    <div>\n      <div *ngIf=\"options?.title\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id\"\n          [class]=\"options?.labelHtmlClass || ''\"\n          [style.display]=\"options?.notitle ? 'none' : ''\"\n          [innerHTML]=\"options?.title\"></label>\n      </div>\n      <mat-button-toggle-group\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\"\n        [vertical]=\"!!options.vertical\">\n        <mat-button-toggle *ngFor=\"let radioItem of radiosList\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.name\"\n          [value]=\"radioItem?.value\"\n          (click)=\"updateValue(radioItem?.value)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </mat-button-toggle>\n      </mat-button-toggle-group>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>`,\n    styles: [` mat-error { font-size: 75%; } `],\n})\nexport class MaterialButtonGroupComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  radiosList: any[] = [];\n  vertical = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.radiosList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, true\n    );\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(value) {\n    this.options.showErrors = true;\n    this.jsf.updateValue(this, value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { hasOwn } from './../../shared/utility.functions';\n\n@Component({\n  selector: 'material-checkbox-widget',\n  template: `\n    <mat-checkbox *ngIf=\"boundControl && !showSlideToggle\"\n      [formControl]=\"formControl\"\n      labelPosition=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      (blur)=\"options.showErrors = true\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-checkbox>\n    <mat-checkbox *ngIf=\"!boundControl && !showSlideToggle\"\n      labelPosition=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [disabled]=\"controlDisabled || options?.readonly\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      [checked]=\"isChecked\"\n      (blur)=\"options.showErrors = true\"\n      (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-checkbox>\n    <mat-slide-toggle *ngIf=\"boundControl && showSlideToggle\"\n      [formControl]=\"formControl\"\n      align=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      (blur)=\"options.showErrors = true\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-slide-toggle>\n    <mat-slide-toggle *ngIf=\"!boundControl && showSlideToggle\"\n      align=\"left\"\n      [color]=\"options?.color || 'primary'\"\n      [disabled]=\"controlDisabled || options?.readonly\"\n      [id]=\"'control' + layoutNode?._id\"\n      labelPosition=\"after\"\n      [name]=\"controlName\"\n      [checked]=\"isChecked\"\n      (blur)=\"options.showErrors = true\"\n      (change)=\"updateValue($event)\">\n      <span *ngIf=\"options?.title\"\n        class=\"checkbox-name\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></span>\n    </mat-slide-toggle>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>`,\n  styles: [`\n    .checkbox-name { white-space: nowrap; }\n    mat-error { font-size: 75%; }\n  `],\n})\nexport class MaterialCheckboxComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  trueValue: any = true;\n  falseValue: any = false;\n  showSlideToggle = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this, !this.options.readonly);\n    if (this.controlValue === null || this.controlValue === undefined) {\n      this.controlValue = false;\n      this.jsf.updateValue(this, this.falseValue);\n    }\n    if (this.layoutNode.type === 'slide-toggle' ||\n      this.layoutNode.format === 'slide-toggle'\n    ) {\n      this.showSlideToggle = true;\n    }\n  }\n\n  updateValue(event) {\n    this.options.showErrors = true;\n    this.jsf.updateValue(this, event.checked ? this.trueValue : this.falseValue);\n  }\n\n  get isChecked() {\n    return this.jsf.getFormControlValue(this) === this.trueValue;\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { FormArray, AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService, TitleMapItem } from '../../json-schema-form.service';\nimport { buildFormGroup, buildTitleMap, hasOwn, JsonPointer } from '../../shared';\n\n// TODO: Change this to use a Selection List instead?\n// https://material.angular.io/components/list/overview\n\n@Component({\n  selector: 'material-checkboxes-widget',\n  template: `\n    <div>\n      <mat-checkbox type=\"checkbox\"\n        [checked]=\"allChecked\"\n        [color]=\"options?.color || 'primary'\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [indeterminate]=\"someChecked\"\n        [name]=\"options?.name\"\n        (blur)=\"options.showErrors = true\"\n        (change)=\"updateAllValues($event)\">\n        <span class=\"checkbox-name\" [innerHTML]=\"options?.name\"></span>\n      </mat-checkbox>\n      <label *ngIf=\"options?.title\"\n        class=\"title\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [style.display]=\"options?.notitle ? 'none' : ''\"\n        [innerHTML]=\"options?.title\"></label>\n      <ul class=\"checkbox-list\" [class.horizontal-list]=\"horizontalList\">\n        <li *ngFor=\"let checkboxItem of checkboxList\"\n          [class]=\"options?.htmlClass || ''\">\n          <mat-checkbox type=\"checkbox\"\n            [(ngModel)]=\"checkboxItem.checked\"\n            [color]=\"options?.color || 'primary'\"\n            [disabled]=\"controlDisabled || options?.readonly\"\n            [name]=\"checkboxItem?.name\"\n            (blur)=\"options.showErrors = true\"\n            (change)=\"updateValue()\">\n            <span class=\"checkbox-name\" [innerHTML]=\"checkboxItem?.name\"></span>\n          </mat-checkbox>\n        </li>\n      </ul>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>`,\n  styles: [`\n    .title { font-weight: bold; }\n    .checkbox-list { list-style-type: none; }\n    .horizontal-list > li { display: inline-block; margin-right: 10px; zoom: 1; }\n    .checkbox-name { white-space: nowrap; }\n    mat-error { font-size: 75%; }\n  `],\n})\nexport class MaterialCheckboxesComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  horizontalList = false;\n  formArray: AbstractControl;\n  checkboxList: TitleMapItem[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.horizontalList = this.layoutNode.type === 'checkboxes-inline' ||\n      this.layoutNode.type === 'checkboxbuttons';\n    this.jsf.initializeControl(this);\n    this.checkboxList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames, this.options.enum, true\n    );\n    if (this.boundControl) {\n      const formArray = this.jsf.getFormControl(this);\n      for (const checkboxItem of this.checkboxList) {\n        checkboxItem.checked = formArray.value.includes(checkboxItem.value);\n      }\n    }\n  }\n\n  get allChecked(): boolean {\n    return this.checkboxList.filter(t => t.checked).length === this.checkboxList.length;\n  }\n\n  get someChecked(): boolean {\n    const checkedItems = this.checkboxList.filter(t => t.checked).length;\n    return checkedItems > 0 && checkedItems < this.checkboxList.length;\n  }\n\n  updateValue() {\n    this.options.showErrors = true;\n    if (this.boundControl) {\n      this.jsf.updateArrayCheckboxList(this, this.checkboxList);\n    }\n  }\n\n  updateAllValues(event: any) {\n    this.options.showErrors = true;\n    this.checkboxList.forEach(t => t.checked = event.checked);\n    this.updateValue();\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'material-chip-list-widget',\n  template: ``,\n})\nexport class MaterialChipListComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit, OnChanges } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { dateToString, hasOwn, stringToDate } from '../../shared';\n\n@Component({\n  selector: 'material-datepicker-widget',\n  template: `\n    <mat-form-field [style.width]=\"'100%'\">\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <input matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [id]=\"'control' + layoutNode?._id\"\n        [max]=\"options?.maximum\"\n        [matDatepicker]=\"picker\"\n        [min]=\"options?.minimum\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        (blur)=\"options.showErrors = true\">\n      <input matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [id]=\"'control' + layoutNode?._id\"\n        [max]=\"options?.maximum\"\n        [matDatepicker]=\"picker\"\n        [min]=\"options?.minimum\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [value]=\"dateValue\"\n        (blur)=\"options.showErrors = true\"\n        (change)=\"updateValue($event)\"\n        (input)=\"updateValue($event)\">\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n      <mat-datepicker-toggle matSuffix [for]=\"picker\"></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #picker></mat-datepicker>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>`,\n  styles: [`\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  `],\n})\nexport class MaterialDatepickerComponent implements OnInit, OnChanges {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  dateValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  autoCompleteList: string[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this, !this.options.readonly);\n    this.setControlDate(this.controlValue);\n    if (!this.options.notitle && !this.options.description && this.options.placeholder) {\n      this.options.description = this.options.placeholder;\n    }\n  }\n\n  ngOnChanges() {\n    this.setControlDate(this.controlValue);\n  }\n\n  setControlDate(dateString: string) {\n    this.dateValue = stringToDate(dateString);\n  }\n\n  updateValue(event) {\n    this.options.showErrors = true;\n    this.jsf.updateValue(this, dateToString(event, this.options));\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'material-file-widget',\n  template: ``,\n})\nexport class MaterialFileComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n@Component({\n  selector: 'material-input-widget',\n  template: `\n    <mat-form-field\n      [class]=\"options?.htmlClass || ''\"\n      [floatLabel]=\"options?.floatPlaceholder || (options?.notitle ? 'never' : 'auto')\"\n      [style.width]=\"'100%'\">\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <input matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"layoutNode?.type\"\n        (blur)=\"options.showErrors = true\">\n      <input matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"layoutNode?.type\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\"\n        (blur)=\"options.showErrors = true\">\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n      <mat-autocomplete *ngIf=\"options?.typeahead?.source\">\n        <mat-option *ngFor=\"let word of options?.typeahead?.source\"\n          [value]=\"word\">{{word}}</mat-option>\n      </mat-autocomplete>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>`,\n  styles: [`\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  `],\n})\nexport class MaterialInputComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: string;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  autoCompleteList: string[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (!this.options.notitle && !this.options.description && this.options.placeholder) {\n      this.options.description = this.options.placeholder;\n    }\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n@Component({\n  selector: 'material-number-widget',\n  template: `\n    <mat-form-field\n      [class]=\"options?.htmlClass || ''\"\n      [floatLabel]=\"options?.floatPlaceholder || (options?.notitle ? 'never' : 'auto')\"\n      [style.width]=\"'100%'\">\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <input matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"'number'\"\n        (blur)=\"options.showErrors = true\">\n      <input matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.max]=\"options?.maximum\"\n        [attr.min]=\"options?.minimum\"\n        [attr.step]=\"options?.multipleOf || options?.step || 'any'\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [type]=\"'number'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\"\n        (blur)=\"options.showErrors = true\">\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"layoutNode?.type === 'range'\" align=\"start\"\n        [innerHTML]=\"controlValue\"></mat-hint>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>`,\n  styles: [`\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  `],\n})\nexport class MaterialNumberComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  allowNegative = true;\n  allowDecimal = true;\n  allowExponents = false;\n  lastValidNumber = '';\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (this.layoutNode.dataType === 'integer') { this.allowDecimal = false; }\n    if (!this.options.notitle && !this.options.description && this.options.placeholder) {\n      this.options.description = this.options.placeholder;\n    }\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { buildTitleMap } from '../../shared';\n\n@Component({\n  selector: 'material-radios-widget',\n  template: `\n    <div>\n      <div *ngIf=\"options?.title\">\n        <label\n          [attr.for]=\"'control' + layoutNode?._id\"\n          [class]=\"options?.labelHtmlClass || ''\"\n          [style.display]=\"options?.notitle ? 'none' : ''\"\n          [innerHTML]=\"options?.title\"></label>\n      </div>\n      <mat-radio-group *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [style.flex-direction]=\"flexDirection\"\n        [name]=\"controlName\"\n        (blur)=\"options.showErrors = true\">\n        <mat-radio-button *ngFor=\"let radioItem of radiosList\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.name\"\n          [value]=\"radioItem?.value\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </mat-radio-button>\n      </mat-radio-group>\n      <mat-radio-group *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.readonly]=\"options?.readonly ? 'readonly' : null\"\n        [attr.required]=\"options?.required\"\n        [style.flex-direction]=\"flexDirection\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [name]=\"controlName\"\n        [value]=\"controlValue\">\n        <mat-radio-button *ngFor=\"let radioItem of radiosList\"\n          [id]=\"'control' + layoutNode?._id + '/' + radioItem?.name\"\n          [value]=\"radioItem?.value\"\n          (click)=\"updateValue(radioItem?.value)\">\n          <span [innerHTML]=\"radioItem?.name\"></span>\n        </mat-radio-button>\n      </mat-radio-group>\n      <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n        [innerHTML]=\"options?.errorMessage\"></mat-error>\n    </div>`,\n  styles: [`\n    mat-radio-group { display: inline-flex; }\n    mat-radio-button { margin: 2px; }\n    mat-error { font-size: 75%; }\n  `]\n})\nexport class MaterialRadiosComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  flexDirection = 'column';\n  radiosList: any[] = [];\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    if (this.layoutNode.type === 'radios-inline') {\n      this.flexDirection = 'row';\n    }\n    this.radiosList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, true\n    );\n    this.jsf.initializeControl(this, !this.options.readonly);\n  }\n\n  updateValue(value) {\n    this.options.showErrors = true;\n    this.jsf.updateValue(this, value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { buildTitleMap, isArray } from '../../shared';\n\n@Component({\n  selector: 'material-select-widget',\n  template: `\n    <mat-form-field\n      [class]=\"options?.htmlClass || ''\"\n      [floatLabel]=\"options?.floatPlaceholder || (options?.notitle ? 'never' : 'auto')\"\n      [style.width]=\"'100%'\">\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <mat-select *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.name]=\"controlName\"\n        [id]=\"'control' + layoutNode?._id\"\n        [multiple]=\"options?.multiple\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        (blur)=\"options.showErrors = true\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <mat-option *ngIf=\"!isArray(selectItem?.items)\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </mat-option>\n          <mat-optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <mat-option *ngFor=\"let subItem of selectItem.items\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </mat-option>\n          </mat-optgroup>\n        </ng-template>\n      </mat-select>\n      <mat-select *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.name]=\"controlName\"\n        [disabled]=\"controlDisabled || options?.readonly\"\n        [id]=\"'control' + layoutNode?._id\"\n        [multiple]=\"options?.multiple\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [required]=\"options?.required\"\n        [style.width]=\"'100%'\"\n        [value]=\"controlValue\"\n        (blur)=\"options.showErrors = true\"\n        (selectionChange)=\"updateValue($event)\">\n        <ng-template ngFor let-selectItem [ngForOf]=\"selectList\">\n          <mat-option *ngIf=\"!isArray(selectItem?.items)\"\n            [attr.selected]=\"selectItem?.value === controlValue\"\n            [value]=\"selectItem?.value\">\n            <span [innerHTML]=\"selectItem?.name\"></span>\n          </mat-option>\n          <mat-optgroup *ngIf=\"isArray(selectItem?.items)\"\n            [label]=\"selectItem?.group\">\n            <mat-option *ngFor=\"let subItem of selectItem.items\"\n              [attr.selected]=\"subItem?.value === controlValue\"\n              [value]=\"subItem?.value\">\n              <span [innerHTML]=\"subItem?.name\"></span>\n            </mat-option>\n          </mat-optgroup>\n        </ng-template>\n      </mat-select>\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>`,\n  styles: [`\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  `],\n})\nexport class MaterialSelectComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  selectList: any[] = [];\n  isArray = isArray;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.selectList = buildTitleMap(\n      this.options.titleMap || this.options.enumNames,\n      this.options.enum, !!this.options.required, !!this.options.flatList\n    );\n    this.jsf.initializeControl(this, !this.options.readonly);\n    if (!this.options.notitle && !this.options.description && this.options.placeholder) {\n      this.options.description = this.options.placeholder;\n    }\n  }\n\n  updateValue(event) {\n    this.options.showErrors = true;\n    this.jsf.updateValue(this, event.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n@Component({\n  selector: 'material-slider-widget',\n  template: `\n    <mat-slider thumbLabel *ngIf=\"boundControl\"\n      [formControl]=\"formControl\"\n      [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n      [id]=\"'control' + layoutNode?._id\"\n      [max]=\"options?.maximum\"\n      [min]=\"options?.minimum\"\n      [step]=\"options?.multipleOf || options?.step || 'any'\"\n      [style.width]=\"'100%'\"\n      (blur)=\"options.showErrors = true\"></mat-slider>\n    <mat-slider thumbLabel *ngIf=\"!boundControl\"\n      [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n      [disabled]=\"controlDisabled || options?.readonly\"\n      [id]=\"'control' + layoutNode?._id\"\n      [max]=\"options?.maximum\"\n      [min]=\"options?.minimum\"\n      [step]=\"options?.multipleOf || options?.step || 'any'\"\n      [style.width]=\"'100%'\"\n      [value]=\"controlValue\"\n      (blur)=\"options.showErrors = true\"\n      (change)=\"updateValue($event)\"></mat-slider>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>`,\n    styles: [` mat-error { font-size: 75%; } `],\n})\nexport class MaterialSliderComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  allowNegative = true;\n  allowDecimal = true;\n  allowExponents = false;\n  lastValidNumber = '';\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this, !this.options.readonly);\n  }\n\n  updateValue(event) {\n    this.options.showErrors = true;\n    this.jsf.updateValue(this, event.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n// TODO: Add this control\n\n@Component({\n  selector: 'material-stepper-widget',\n  template: ``,\n})\nexport class MaterialStepperComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n@Component({\n  selector: 'material-tabs-widget',\n  template: `\n    <nav mat-tab-nav-bar\n      [attr.aria-label]=\"options?.label || options?.title || ''\"\n      [style.width]=\"'100%'\">\n        <a mat-tab-link *ngFor=\"let item of layoutNode?.items; let i = index\"\n          [active]=\"selectedItem === i\"\n          (click)=\"select(i)\">\n          <span *ngIf=\"showAddTab || item.type !== '$ref'\"\n            [innerHTML]=\"setTabTitle(item, i)\"></span>\n        </a>\n    </nav>\n    <div *ngFor=\"let layoutItem of layoutNode?.items; let i = index\"\n      [class]=\"options?.htmlClass || ''\">\n      <select-framework-widget *ngIf=\"selectedItem === i\"\n        [class]=\"(options?.fieldHtmlClass || '') + ' ' + (options?.activeClass || '') + ' ' + (options?.style?.selected || '')\"\n        [dataIndex]=\"layoutNode?.dataType === 'array' ? (dataIndex || []).concat(i) : dataIndex\"\n        [layoutIndex]=\"(layoutIndex || []).concat(i)\"\n        [layoutNode]=\"layoutItem\"></select-framework-widget>\n    </div>`,\n  styles: [` a { cursor: pointer; } `],\n})\nexport class MaterialTabsComponent implements OnInit {\n  options: any;\n  itemCount: number;\n  selectedItem = 0;\n  showAddTab = true;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.itemCount = this.layoutNode.items.length - 1;\n    this.updateControl();\n  }\n\n  select(index) {\n    if (this.layoutNode.items[index].type === '$ref') {\n      this.jsf.addItem({\n        layoutNode: this.layoutNode.items[index],\n        layoutIndex: this.layoutIndex.concat(index),\n        dataIndex: this.dataIndex.concat(index)\n      });\n      this.updateControl();\n    }\n    this.selectedItem = index;\n  }\n\n  updateControl() {\n    this.itemCount = this.layoutNode.items.length - 1;\n    const lastItem = this.layoutNode.items[this.layoutNode.items.length - 1];\n    this.showAddTab = lastItem.type === '$ref' &&\n      this.itemCount < (lastItem.options.maxItems || 1000);\n  }\n\n  setTabTitle(item: any, index: number): string {\n    return this.jsf.setArrayItemTitle(this, item, index);\n  }\n}\n",
    "import { Component, Input, OnInit } from '@angular/core';\nimport { AbstractControl } from '@angular/forms';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\n\n@Component({\n  selector: 'material-textarea-widget',\n  template: `\n    <mat-form-field\n      [class]=\"options?.htmlClass || ''\"\n      [floatLabel]=\"options?.floatPlaceholder || (options?.notitle ? 'never' : 'auto')\"\n      [style.width]=\"'100%'\">\n      <span matPrefix *ngIf=\"options?.prefix || options?.fieldAddonLeft\"\n        [innerHTML]=\"options?.prefix || options?.fieldAddonLeft\"></span>\n      <textarea matInput *ngIf=\"boundControl\"\n        [formControl]=\"formControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [required]=\"options?.required\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [style.width]=\"'100%'\"\n        (blur)=\"options.showErrors = true\"></textarea>\n      <textarea matInput *ngIf=\"!boundControl\"\n        [attr.aria-describedby]=\"'control' + layoutNode?._id + 'Status'\"\n        [attr.list]=\"'control' + layoutNode?._id + 'Autocomplete'\"\n        [attr.maxlength]=\"options?.maxLength\"\n        [attr.minlength]=\"options?.minLength\"\n        [attr.pattern]=\"options?.pattern\"\n        [required]=\"options?.required\"\n        [disabled]=\"controlDisabled\"\n        [id]=\"'control' + layoutNode?._id\"\n        [name]=\"controlName\"\n        [placeholder]=\"options?.notitle ? options?.placeholder : options?.title\"\n        [readonly]=\"options?.readonly ? 'readonly' : null\"\n        [style.width]=\"'100%'\"\n        [value]=\"controlValue\"\n        (input)=\"updateValue($event)\"\n        (blur)=\"options.showErrors = true\"></textarea>\n      <span matSuffix *ngIf=\"options?.suffix || options?.fieldAddonRight\"\n        [innerHTML]=\"options?.suffix || options?.fieldAddonRight\"></span>\n      <mat-hint *ngIf=\"options?.description && (!options?.showErrors || !options?.errorMessage)\"\n        align=\"end\" [innerHTML]=\"options?.description\"></mat-hint>\n    </mat-form-field>\n    <mat-error *ngIf=\"options?.showErrors && options?.errorMessage\"\n      [innerHTML]=\"options?.errorMessage\"></mat-error>`,\n  styles: [`\n    mat-error { font-size: 75%; margin-top: -1rem; margin-bottom: 0.5rem; }\n    ::ng-deep mat-form-field .mat-form-field-wrapper .mat-form-field-flex\n      .mat-form-field-infix { width: initial; }\n  `],\n})\nexport class MaterialTextareaComponent implements OnInit {\n  formControl: AbstractControl;\n  controlName: string;\n  controlValue: any;\n  controlDisabled = false;\n  boundControl = false;\n  options: any;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  ngOnInit() {\n    this.options = this.layoutNode.options || {};\n    this.jsf.initializeControl(this);\n    if (!this.options.notitle && !this.options.description && this.options.placeholder) {\n      this.options.description = this.options.placeholder;\n    }\n  }\n\n  updateValue(event) {\n    this.jsf.updateValue(this, event.target.value);\n  }\n}\n",
    "import { ChangeDetectorRef, Component, Input, OnChanges, OnInit } from '@angular/core';\n\nimport * as _ from 'lodash';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { hasOwn, isArray, isDefined, toTitleCase } from '../../shared';\n\n@Component({\n  selector: 'material-design-framework',\n  template: `\n    <div\n      [class.array-item]=\"widgetLayoutNode?.arrayItem && widgetLayoutNode?.type !== '$ref'\"\n      [orderable]=\"isOrderable\"\n      [dataIndex]=\"dataIndex\"\n      [layoutIndex]=\"layoutIndex\"\n      [layoutNode]=\"widgetLayoutNode\">\n      <svg *ngIf=\"showRemoveButton\"\n        xmlns=\"http://www.w3.org/2000/svg\"\n        height=\"18\" width=\"18\" viewBox=\"0 0 24 24\"\n        class=\"close-button\"\n        (click)=\"removeItem()\">\n        <path d=\"M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z\"/>\n      </svg>\n      <select-widget-widget\n        [dataIndex]=\"dataIndex\"\n        [layoutIndex]=\"layoutIndex\"\n        [layoutNode]=\"widgetLayoutNode\"></select-widget-widget>\n    </div>\n    <div class=\"spacer\" *ngIf=\"widgetLayoutNode?.arrayItem && widgetLayoutNode?.type !== '$ref'\"></div>`,\n  styles: [`\n    .array-item {\n      border-radius: 2px;\n      box-shadow: 0 3px 1px -2px rgba(0,0,0,.2),\n                  0 2px 2px  0   rgba(0,0,0,.14),\n                  0 1px 5px  0   rgba(0,0,0,.12);\n      padding: 6px;\n      position: relative;\n      transition: all 280ms cubic-bezier(.4, 0, .2, 1);\n    }\n    .close-button {\n      cursor: pointer;\n      position: absolute;\n      top: 6px;\n      right: 6px;\n      fill: rgba(0,0,0,.4);\n      visibility: hidden;\n      z-index: 500;\n    }\n    .close-button:hover { fill: rgba(0,0,0,.8); }\n    .array-item:hover > .close-button { visibility: visible; }\n    .spacer { margin: 6px 0; }\n    [draggable=true]:hover {\n      box-shadow: 0 5px 5px -3px rgba(0,0,0,.2),\n                  0 8px 10px 1px rgba(0,0,0,.14),\n                  0 3px 14px 2px rgba(0,0,0,.12);\n      cursor: move;\n      z-index: 10;\n    }\n    [draggable=true].drag-target-top {\n      box-shadow: 0 -2px 0 #000;\n      position: relative; z-index: 20;\n    }\n    [draggable=true].drag-target-bottom {\n      box-shadow: 0 2px 0 #000;\n      position: relative; z-index: 20;\n    }\n  `],\n})\nexport class MaterialDesignFrameworkComponent implements OnInit, OnChanges {\n  frameworkInitialized = false;\n  inputType: string;\n  options: any; // Options used in this framework\n  widgetLayoutNode: any; // layoutNode passed to child widget\n  widgetOptions: any; // Options passed to child widget\n  formControl: any = null;\n  parentArray: any = null;\n  isOrderable = false;\n  dynamicTitle: string = null;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    private changeDetector: ChangeDetectorRef,\n    private jsf: JsonSchemaFormService\n  ) { }\n\n  get showRemoveButton(): boolean {\n    if (!this.layoutNode || !this.widgetOptions.removable ||\n      this.widgetOptions.readonly || this.layoutNode.type === '$ref'\n    ) { return false; }\n    if (this.layoutNode.recursiveReference) { return true; }\n    if (!this.layoutNode.arrayItem || !this.parentArray) { return false; }\n    // If array length <= minItems, don't allow removing any items\n    return this.parentArray.items.length - 1 <= this.parentArray.options.minItems ? false :\n      // For removable list items, allow removing any item\n      this.layoutNode.arrayItemType === 'list' ? true :\n      // For removable tuple items, only allow removing last item in list\n      this.layoutIndex[this.layoutIndex.length - 1] === this.parentArray.items.length - 2;\n  }\n\n  ngOnInit() {\n    this.initializeFramework();\n  }\n\n  ngOnChanges() {\n    if (!this.frameworkInitialized) { this.initializeFramework(); }\n    if (this.dynamicTitle) { this.updateTitle(); }\n  }\n\n  initializeFramework() {\n    if (this.layoutNode) {\n      this.options = _.cloneDeep(this.layoutNode.options || {});\n      this.widgetLayoutNode = {\n        ...this.layoutNode,\n        options: _.cloneDeep(this.layoutNode.options || {})\n      };\n      this.widgetOptions = this.widgetLayoutNode.options;\n      this.formControl = this.jsf.getFormControl(this);\n\n      if (\n        isDefined(this.widgetOptions.minimum) &&\n        isDefined(this.widgetOptions.maximum) &&\n        this.widgetOptions.multipleOf >= 1\n      ) {\n        this.layoutNode.type = 'range';\n      }\n\n      if (\n        !['$ref', 'advancedfieldset', 'authfieldset', 'button', 'card',\n          'checkbox', 'expansion-panel', 'help', 'message', 'msg', 'section',\n          'submit', 'tabarray', 'tabs'].includes(this.layoutNode.type) &&\n        /{{.+?}}/.test(this.widgetOptions.title || '')\n      ) {\n        this.dynamicTitle = this.widgetOptions.title;\n        this.updateTitle();\n      }\n\n      if (this.layoutNode.arrayItem && this.layoutNode.type !== '$ref') {\n        this.parentArray = this.jsf.getParentNode(this);\n        if (this.parentArray) {\n          this.isOrderable =\n            this.parentArray.type.slice(0, 3) !== 'tab' &&\n            this.layoutNode.arrayItemType === 'list' &&\n            !this.widgetOptions.readonly &&\n            this.parentArray.options.orderable;\n        }\n      }\n\n      this.frameworkInitialized = true;\n    } else {\n      this.options = {};\n    }\n  }\n\n  updateTitle() {\n    this.widgetLayoutNode.options.title = this.jsf.parseText(\n      this.dynamicTitle,\n      this.jsf.getFormControlValue(this),\n      this.jsf.getFormControlGroup(this).value,\n      this.dataIndex[this.dataIndex.length - 1]\n    );\n  }\n\n  removeItem() {\n    this.jsf.removeItem(this);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { Framework } from '../framework';\n\n// Material Design Framework\n// https://github.com/angular/material2\nimport { FlexLayoutRootComponent } from './flex-layout-root.component';\nimport { FlexLayoutSectionComponent } from './flex-layout-section.component';\nimport { MaterialAddReferenceComponent } from './material-add-reference.component';\nimport { MaterialOneOfComponent } from './material-one-of.component';\nimport { MaterialButtonComponent } from './material-button.component';\nimport { MaterialButtonGroupComponent } from './material-button-group.component';\nimport { MaterialCheckboxComponent } from './material-checkbox.component';\nimport { MaterialCheckboxesComponent } from './material-checkboxes.component';\nimport { MaterialChipListComponent } from './material-chip-list.component';\nimport { MaterialDatepickerComponent } from './material-datepicker.component';\nimport { MaterialFileComponent } from './material-file.component';\nimport { MaterialInputComponent } from './material-input.component';\nimport { MaterialNumberComponent } from './material-number.component';\nimport { MaterialRadiosComponent } from './material-radios.component';\nimport { MaterialSelectComponent } from './material-select.component';\nimport { MaterialSliderComponent } from './material-slider.component';\nimport { MaterialStepperComponent } from './material-stepper.component';\nimport { MaterialTabsComponent } from './material-tabs.component';\nimport { MaterialTextareaComponent } from './material-textarea.component';\nimport { MaterialDesignFrameworkComponent } from './material-design-framework.component';\n\n@Injectable()\nexport class MaterialDesignFramework extends Framework {\n  name = 'material-design';\n\n  framework = MaterialDesignFrameworkComponent;\n\n  stylesheets = [\n    '//fonts.googleapis.com/icon?family=Material+Icons',\n    '//fonts.googleapis.com/css?family=Roboto:300,400,500,700',\n  ];\n\n  widgets = {\n    'root':            FlexLayoutRootComponent,\n    'section':         FlexLayoutSectionComponent,\n    '$ref':            MaterialAddReferenceComponent,\n    'button':          MaterialButtonComponent,\n    'button-group':    MaterialButtonGroupComponent,\n    'checkbox':        MaterialCheckboxComponent,\n    'checkboxes':      MaterialCheckboxesComponent,\n    'chip-list':       MaterialChipListComponent,\n    'date':            MaterialDatepickerComponent,\n    'file':            MaterialFileComponent,\n    'number':          MaterialNumberComponent,\n    'one-of':          MaterialOneOfComponent,\n    'radios':          MaterialRadiosComponent,\n    'select':          MaterialSelectComponent,\n    'slider':          MaterialSliderComponent,\n    'stepper':         MaterialStepperComponent,\n    'tabs':            MaterialTabsComponent,\n    'text':            MaterialInputComponent,\n    'textarea':        MaterialTextareaComponent,\n    'alt-date':        'date',\n    'any-of':          'one-of',\n    'card':            'section',\n    'color':           'text',\n    'expansion-panel': 'section',\n    'hidden':          'none',\n    'image':           'none',\n    'integer':         'number',\n    'radiobuttons':    'button-group',\n    'range':           'slider',\n    'submit':          'button',\n    'tagsinput':       'chip-list',\n    'wizard':          'stepper',\n  };\n}\n",
    "import { FlexLayoutRootComponent } from './flex-layout-root.component';\nimport { FlexLayoutSectionComponent } from './flex-layout-section.component';\nimport { MaterialAddReferenceComponent } from './material-add-reference.component';\nimport { MaterialOneOfComponent } from './material-one-of.component';\nimport { MaterialButtonComponent } from './material-button.component';\nimport { MaterialButtonGroupComponent } from './material-button-group.component';\nimport { MaterialCheckboxComponent } from './material-checkbox.component';\nimport { MaterialCheckboxesComponent } from './material-checkboxes.component';\nimport { MaterialChipListComponent } from './material-chip-list.component';\nimport { MaterialDatepickerComponent } from './material-datepicker.component';\nimport { MaterialFileComponent } from './material-file.component';\nimport { MaterialInputComponent } from './material-input.component';\nimport { MaterialNumberComponent } from './material-number.component';\nimport { MaterialRadiosComponent } from './material-radios.component';\nimport { MaterialSelectComponent } from './material-select.component';\nimport { MaterialSliderComponent } from './material-slider.component';\nimport { MaterialStepperComponent } from './material-stepper.component';\nimport { MaterialTabsComponent } from './material-tabs.component';\nimport { MaterialTextareaComponent } from './material-textarea.component';\n\nimport { MaterialDesignFrameworkComponent } from './material-design-framework.component';\n\nexport const MATERIAL_FRAMEWORK_COMPONENTS = [\n  FlexLayoutRootComponent, FlexLayoutSectionComponent,\n  MaterialAddReferenceComponent, MaterialOneOfComponent,\n  MaterialButtonComponent, MaterialButtonGroupComponent,\n  MaterialCheckboxComponent, MaterialCheckboxesComponent,\n  MaterialChipListComponent, MaterialDatepickerComponent,\n  MaterialFileComponent, MaterialInputComponent, MaterialNumberComponent,\n  MaterialRadiosComponent, MaterialSelectComponent, MaterialSliderComponent,\n  MaterialStepperComponent, MaterialTabsComponent, MaterialTextareaComponent,\n  MaterialDesignFrameworkComponent\n];\n\nexport { FlexLayoutRootComponent } from './flex-layout-root.component';\nexport { FlexLayoutSectionComponent } from './flex-layout-section.component';\nexport { MaterialAddReferenceComponent } from './material-add-reference.component';\nexport { MaterialOneOfComponent } from './material-one-of.component';\nexport { MaterialButtonComponent } from './material-button.component';\nexport { MaterialButtonGroupComponent } from './material-button-group.component';\nexport { MaterialCheckboxComponent } from './material-checkbox.component';\nexport { MaterialCheckboxesComponent } from './material-checkboxes.component';\nexport { MaterialChipListComponent } from './material-chip-list.component';\nexport { MaterialDatepickerComponent } from './material-datepicker.component';\nexport { MaterialFileComponent } from './material-file.component';\nexport { MaterialInputComponent } from './material-input.component';\nexport { MaterialNumberComponent } from './material-number.component';\nexport { MaterialRadiosComponent } from './material-radios.component';\nexport { MaterialSelectComponent } from './material-select.component';\nexport { MaterialSliderComponent } from './material-slider.component';\nexport { MaterialStepperComponent } from './material-stepper.component';\nexport { MaterialTabsComponent } from './material-tabs.component';\nexport { MaterialTextareaComponent } from './material-textarea.component';\n\nexport { MaterialDesignFrameworkComponent } from './material-design-framework.component';\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule, ReactiveFormsModule } from '@angular/forms';\nimport { FlexLayoutModule } from '@angular/flex-layout';\nimport {\n  MatAutocompleteModule, MatButtonModule, MatButtonToggleModule, MatCardModule,\n  MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatExpansionModule,\n  MatFormFieldModule, MatIconModule, MatInputModule, MatNativeDateModule,\n  MatRadioModule, MatSelectModule, MatSliderModule, MatSlideToggleModule,\n  MatStepperModule, MatTabsModule, MatTooltipModule,\n} from '@angular/material';\nexport const ANGULAR_MATERIAL_MODULES = [\n  MatAutocompleteModule, MatButtonModule, MatButtonToggleModule, MatCardModule,\n  MatCheckboxModule, MatChipsModule, MatDatepickerModule, MatExpansionModule,\n  MatFormFieldModule, MatIconModule, MatInputModule, MatNativeDateModule,\n  MatRadioModule, MatSelectModule, MatSliderModule, MatSlideToggleModule,\n  MatStepperModule, MatTabsModule, MatTooltipModule,\n];\n/**\n * unused @angular/material modules:\n * MatDialogModule, MatGridListModule, MatListModule, MatMenuModule,\n * MatPaginatorModule, MatProgressBarModule, MatProgressSpinnerModule,\n * MatSidenavModule, MatSnackBarModule, MatSortModule, MatTableModule,\n * MatToolbarModule,\n */\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { WidgetLibraryModule } from '../../widget-library/widget-library.module';\nimport { Framework } from '../framework';\nimport { MATERIAL_FRAMEWORK_COMPONENTS } from './index';\nimport { MaterialDesignFramework } from './material-design.framework';\n\n@NgModule({\n  imports: [\n    CommonModule, FormsModule, ReactiveFormsModule, FlexLayoutModule,\n    ...ANGULAR_MATERIAL_MODULES, WidgetLibraryModule\n  ],\n  declarations:    [ ...MATERIAL_FRAMEWORK_COMPONENTS ],\n  exports:         [ ...MATERIAL_FRAMEWORK_COMPONENTS ],\n  entryComponents: [ ...MATERIAL_FRAMEWORK_COMPONENTS ]\n})\nexport class MaterialDesignFrameworkModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: MaterialDesignFrameworkModule,\n      providers: [\n        { provide: Framework, useClass: MaterialDesignFramework, multi: true }\n      ]\n    };\n  }\n}\n",
    "import { ChangeDetectorRef, Component, Input, OnChanges, OnInit } from '@angular/core';\n\nimport * as _ from 'lodash';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport {\n  addClasses, hasOwn, inArray, isArray, JsonPointer, toTitleCase\n} from '../../shared';\n\n/**\n * Bootstrap 3 framework for Angular JSON Schema Form.\n *\n */\n@Component({\n  selector: 'bootstrap-3-framework',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\"\n      [class.has-feedback]=\"options?.feedback && options?.isInputWidget &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-error]=\"options?.enableErrorState && formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-success]=\"options?.enableSuccessState && !formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\">\n\n      <button *ngIf=\"showRemoveButton\"\n        class=\"close pull-right\"\n        type=\"button\"\n        (click)=\"removeItem()\">\n        <span aria-hidden=\"true\">&times;</span>\n        <span class=\"sr-only\">Close</span>\n      </button>\n      <div *ngIf=\"options?.messageLocation === 'top'\">\n          <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n\n      <label *ngIf=\"options?.title && layoutNode?.type !== 'tab'\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [class.sr-only]=\"options?.notitle\"\n        [innerHTML]=\"options?.title\"></label>\n      <p *ngIf=\"layoutNode?.type === 'submit' && jsf?.formOptions?.fieldsRequired\">\n        <strong class=\"text-danger\">*</strong> = required fields\n      </p>\n      <div [class.input-group]=\"options?.fieldAddonLeft || options?.fieldAddonRight\">\n        <span *ngIf=\"options?.fieldAddonLeft\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonLeft\"></span>\n\n        <select-widget-widget\n          [layoutNode]=\"widgetLayoutNode\"\n          [dataIndex]=\"dataIndex\"\n          [layoutIndex]=\"layoutIndex\"></select-widget-widget>\n\n        <span *ngIf=\"options?.fieldAddonRight\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonRight\"></span>\n      </div>\n\n      <span *ngIf=\"options?.feedback && options?.isInputWidget &&\n          !options?.fieldAddonRight && !layoutNode.arrayItem &&\n          (formControl?.dirty || options?.feedbackOnRender)\"\n        [class.glyphicon-ok]=\"options?.enableSuccessState && !formControl?.errors\"\n        [class.glyphicon-remove]=\"options?.enableErrorState && formControl?.errors\"\n        aria-hidden=\"true\"\n        class=\"form-control-feedback glyphicon\"></span>\n      <div *ngIf=\"options?.messageLocation !== 'top'\">\n        <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n    </div>\n\n    <div *ngIf=\"debug && debugOutput\">debug: <pre>{{debugOutput}}</pre></div>\n  `,\n  styles: [`\n    :host /deep/ .list-group-item .form-control-feedback { top: 40; }\n    :host /deep/ .checkbox,\n    :host /deep/ .radio { margin-top: 0; margin-bottom: 0; }\n    :host /deep/ .checkbox-inline,\n    :host /deep/ .checkbox-inline + .checkbox-inline,\n    :host /deep/ .checkbox-inline + .radio-inline,\n    :host /deep/ .radio-inline,\n    :host /deep/ .radio-inline + .radio-inline,\n    :host /deep/ .radio-inline + .checkbox-inline { margin-left: 0; margin-right: 10px; }\n    :host /deep/ .checkbox-inline:last-child,\n    :host /deep/ .radio-inline:last-child { margin-right: 0; }\n    :host /deep/ .ng-invalid.ng-touched { border: 1px solid #f44336; }\n  `],\n})\nexport class Bootstrap3FrameworkComponent implements OnInit, OnChanges {\n  frameworkInitialized = false;\n  widgetOptions: any; // Options passed to child widget\n  widgetLayoutNode: any; // layoutNode passed to child widget\n  options: any; // Options used in this framework\n  formControl: any = null;\n  debugOutput: any = '';\n  debug: any = '';\n  parentArray: any = null;\n  isOrderable = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    public changeDetector: ChangeDetectorRef,\n    public jsf: JsonSchemaFormService\n  ) { }\n\n  get showRemoveButton(): boolean {\n    if (!this.options.removable || this.options.readonly ||\n      this.layoutNode.type === '$ref'\n    ) { return false; }\n    if (this.layoutNode.recursiveReference) { return true; }\n    if (!this.layoutNode.arrayItem || !this.parentArray) { return false; }\n    // If array length <= minItems, don't allow removing any items\n    return this.parentArray.items.length - 1 <= this.parentArray.options.minItems ? false :\n      // For removable list items, allow removing any item\n      this.layoutNode.arrayItemType === 'list' ? true :\n      // For removable tuple items, only allow removing last item in list\n      this.layoutIndex[this.layoutIndex.length - 1] === this.parentArray.items.length - 2;\n  }\n\n  ngOnInit() {\n    this.initializeFramework();\n    if (this.layoutNode.arrayItem && this.layoutNode.type !== '$ref') {\n      this.parentArray = this.jsf.getParentNode(this);\n      if (this.parentArray) {\n        this.isOrderable = this.layoutNode.arrayItemType === 'list' &&\n          !this.options.readonly && this.parentArray.options.orderable;\n      }\n    }\n  }\n\n  ngOnChanges() {\n    if (!this.frameworkInitialized) { this.initializeFramework(); }\n  }\n\n  initializeFramework() {\n    if (this.layoutNode) {\n      this.options = _.cloneDeep(this.layoutNode.options);\n      this.widgetLayoutNode = {\n        ...this.layoutNode,\n        options: _.cloneDeep(this.layoutNode.options)\n      };\n      this.widgetOptions = this.widgetLayoutNode.options;\n      this.formControl = this.jsf.getFormControl(this);\n\n      this.options.isInputWidget = inArray(this.layoutNode.type, [\n        'button', 'checkbox', 'checkboxes-inline', 'checkboxes', 'color',\n        'date', 'datetime-local', 'datetime', 'email', 'file', 'hidden',\n        'image', 'integer', 'month', 'number', 'password', 'radio',\n        'radiobuttons', 'radios-inline', 'radios', 'range', 'reset', 'search',\n        'select', 'submit', 'tel', 'text', 'textarea', 'time', 'url', 'week'\n      ]);\n\n      this.options.title = this.setTitle();\n\n      this.options.htmlClass =\n        addClasses(this.options.htmlClass, 'schema-form-' + this.layoutNode.type);\n      if (this.layoutNode.type !== 'flex')  {\n          this.options.htmlClass =\n            this.layoutNode.type === 'array' ?\n              addClasses(this.options.htmlClass, 'list-group') :\n            this.layoutNode.arrayItem && this.layoutNode.type !== '$ref' ?\n              addClasses(this.options.htmlClass, 'list-group-item') :\n              addClasses(this.options.htmlClass, 'form-group');\n      }\n      this.widgetOptions.htmlClass = '';\n      this.options.labelHtmlClass =\n        addClasses(this.options.labelHtmlClass, 'control-label');\n      this.widgetOptions.activeClass =\n        addClasses(this.widgetOptions.activeClass, 'active');\n      this.options.fieldAddonLeft =\n        this.options.fieldAddonLeft || this.options.prepend;\n      this.options.fieldAddonRight =\n        this.options.fieldAddonRight || this.options.append;\n\n      // Add asterisk to titles if required\n      if (this.options.title && this.layoutNode.type !== 'tab' &&\n        !this.options.notitle && this.options.required  &&\n        !this.options.title.includes('*')\n      ) {\n        this.options.title += ' <strong class=\"text-danger\">*</strong>';\n      }\n      // Set miscelaneous styles and settings for each control type\n      switch (this.layoutNode.type) {\n        // Checkbox controls\n        case 'checkbox': case 'checkboxes':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'checkbox');\n        break;\n        case 'checkboxes-inline':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'checkbox');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, 'checkbox-inline');\n        break;\n        // Radio controls\n        case 'radio': case 'radios':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'radio');\n        break;\n        case 'radios-inline':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'radio');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, 'radio-inline');\n        break;\n        // Button sets - checkboxbuttons and radiobuttons\n        case 'checkboxbuttons': case 'radiobuttons':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'btn-group');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, 'btn');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, this.options.style || 'btn-default');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'sr-only');\n        break;\n        // Single button controls\n        case 'button': case 'submit':\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'btn');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-info');\n        break;\n        // Containers - arrays and fieldsets\n        case 'array': case 'fieldset': case 'section': case 'conditional':\n        case 'advancedfieldset': case 'authfieldset':\n        case 'selectfieldset': case 'optionfieldset':\n          this.options.messageLocation = 'top';\n        break;\n        case 'tabarray': case 'tabs':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'tab-content');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'tab-pane');\n          this.widgetOptions.labelHtmlClass = addClasses(\n            this.widgetOptions.labelHtmlClass, 'nav nav-tabs');\n        break;\n        // 'Add' buttons - references\n        case '$ref':\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'btn pull-right');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-default');\n          this.options.icon = 'glyphicon glyphicon-plus';\n        break;\n        // Default - including regular inputs\n        default:\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'form-control');\n      }\n\n      if (this.formControl) {\n        this.updateHelpBlock(this.formControl.status);\n        this.formControl.statusChanges.subscribe(status => this.updateHelpBlock(status));\n\n        if (this.options.debug) {\n          const vars: any[] = [];\n          this.debugOutput = _.map(vars, thisVar => JSON.stringify(thisVar, null, 2)).join('\\n');\n        }\n      }\n      this.frameworkInitialized = true;\n    }\n\n  }\n\n  updateHelpBlock(status) {\n    this.options.helpBlock = status === 'INVALID' &&\n      this.options.enableErrorState && this.formControl.errors &&\n      (this.formControl.dirty || this.options.feedbackOnRender) ?\n        this.jsf.formatErrors(this.formControl.errors, this.options.validationMessages) :\n        this.options.description || this.options.help || null;\n  }\n\n  setTitle(): string {\n    switch (this.layoutNode.type) {\n      case 'button': case 'checkbox': case 'section': case 'help': case 'msg':\n      case 'submit': case 'message': case 'tabarray': case 'tabs': case '$ref':\n        return null;\n      case 'advancedfieldset':\n        this.widgetOptions.expandable = true;\n        this.widgetOptions.title = 'Advanced options';\n        return null;\n      case 'authfieldset':\n        this.widgetOptions.expandable = true;\n        this.widgetOptions.title = 'Authentication settings';\n        return null;\n      case 'fieldset':\n        this.widgetOptions.title = this.options.title;\n        return null;\n      default:\n        this.widgetOptions.title = null;\n        return this.jsf.setItemTitle(this);\n    }\n  }\n\n  removeItem() {\n    this.jsf.removeItem(this);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { Framework } from '../framework';\n\n// Bootstrap 3 Framework\n// https://github.com/valor-software/ng2-bootstrap\nimport { Bootstrap3FrameworkComponent } from './bootstrap-3-framework.component';\n\n@Injectable()\nexport class Bootstrap3Framework extends Framework {\n  name = 'bootstrap-3';\n\n  framework = Bootstrap3FrameworkComponent;\n\n  stylesheets = [\n    '//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css',\n    '//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap-theme.min.css',\n  ];\n\n  scripts = [\n    '//ajax.googleapis.com/ajax/libs/jquery/2.2.4/jquery.min.js',\n    '//ajax.googleapis.com/ajax/libs/jqueryui/1.12.1/jquery-ui.min.js',\n    '//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js',\n  ];\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { WidgetLibraryModule } from '../../widget-library/widget-library.module';\nimport { Framework } from '../framework';\nimport { Bootstrap3FrameworkComponent } from './bootstrap-3-framework.component';\nimport { Bootstrap3Framework } from './bootstrap-3.framework';\n\n@NgModule({\n  imports:         [ CommonModule, WidgetLibraryModule ],\n  declarations:    [ Bootstrap3FrameworkComponent ],\n  exports:         [ Bootstrap3FrameworkComponent ],\n  entryComponents: [ Bootstrap3FrameworkComponent ]\n})\nexport class Bootstrap3FrameworkModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: Bootstrap3FrameworkModule,\n      providers: [\n        { provide: Framework, useClass: Bootstrap3Framework, multi: true }\n      ]\n    };\n  }\n}\n",
    "import { ChangeDetectorRef, Component, Input, OnChanges, OnInit } from '@angular/core';\n\nimport * as _ from 'lodash';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport {\n  addClasses, hasOwn, inArray, isArray, JsonPointer, toTitleCase\n} from '../../shared';\n\n/**\n * Bootstrap 4 framework for Angular JSON Schema Form.\n *\n */\n@Component({\n  selector: 'bootstrap-4-framework',\n  template: `\n    <div\n      [class]=\"options?.htmlClass || ''\"\n      [class.has-feedback]=\"options?.feedback && options?.isInputWidget &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-error]=\"options?.enableErrorState && formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\"\n      [class.has-success]=\"options?.enableSuccessState && !formControl?.errors &&\n        (formControl?.dirty || options?.feedbackOnRender)\">\n\n      <button *ngIf=\"showRemoveButton\"\n        class=\"close pull-right\"\n        type=\"button\"\n        (click)=\"removeItem()\">\n        <span aria-hidden=\"true\">&times;</span>\n        <span class=\"sr-only\">Close</span>\n      </button>\n      <div *ngIf=\"options?.messageLocation === 'top'\">\n        <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n\n      <label *ngIf=\"options?.title && layoutNode?.type !== 'tab'\"\n        [attr.for]=\"'control' + layoutNode?._id\"\n        [class]=\"options?.labelHtmlClass || ''\"\n        [class.sr-only]=\"options?.notitle\"\n        [innerHTML]=\"options?.title\"></label>\n      <p *ngIf=\"layoutNode?.type === 'submit' && jsf?.formOptions?.fieldsRequired\">\n        <strong class=\"text-danger\">*</strong> = required fields\n      </p>\n      <div [class.input-group]=\"options?.fieldAddonLeft || options?.fieldAddonRight\">\n        <span *ngIf=\"options?.fieldAddonLeft\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonLeft\"></span>\n\n        <select-widget-widget\n          [layoutNode]=\"widgetLayoutNode\"\n          [dataIndex]=\"dataIndex\"\n          [layoutIndex]=\"layoutIndex\"></select-widget-widget>\n\n        <span *ngIf=\"options?.fieldAddonRight\"\n          class=\"input-group-addon\"\n          [innerHTML]=\"options?.fieldAddonRight\"></span>\n      </div>\n\n      <span *ngIf=\"options?.feedback && options?.isInputWidget &&\n          !options?.fieldAddonRight && !layoutNode.arrayItem &&\n          (formControl?.dirty || options?.feedbackOnRender)\"\n        [class.glyphicon-ok]=\"options?.enableSuccessState && !formControl?.errors\"\n        [class.glyphicon-remove]=\"options?.enableErrorState && formControl?.errors\"\n        aria-hidden=\"true\"\n        class=\"form-control-feedback glyphicon\"></span>\n      <div *ngIf=\"options?.messageLocation !== 'top'\">\n        <p *ngIf=\"options?.helpBlock\"\n          class=\"help-block\"\n          [innerHTML]=\"options?.helpBlock\"></p>\n      </div>\n    </div>\n\n    <div *ngIf=\"debug && debugOutput\">debug: <pre>{{debugOutput}}</pre></div>\n  `,\n  styles: [`\n    :host /deep/ .list-group-item .form-control-feedback { top: 40px; }\n    :host /deep/ .checkbox,\n    :host /deep/ .radio { margin-top: 0; margin-bottom: 0; }\n    :host /deep/ .checkbox-inline,\n    :host /deep/ .checkbox-inline + .checkbox-inline,\n    :host /deep/ .checkbox-inline + .radio-inline,\n    :host /deep/ .radio-inline,\n    :host /deep/ .radio-inline + .radio-inline,\n    :host /deep/ .radio-inline + .checkbox-inline { margin-left: 0; margin-right: 10px; }\n    :host /deep/ .checkbox-inline:last-child,\n    :host /deep/ .radio-inline:last-child { margin-right: 0; }\n    :host /deep/ .ng-invalid.ng-touched { border: 1px solid #f44336; }\n  `],\n})\nexport class Bootstrap4FrameworkComponent implements OnInit, OnChanges {\n  frameworkInitialized = false;\n  widgetOptions: any; // Options passed to child widget\n  widgetLayoutNode: any; // layoutNode passed to child widget\n  options: any; // Options used in this framework\n  formControl: any = null;\n  debugOutput: any = '';\n  debug: any = '';\n  parentArray: any = null;\n  isOrderable = false;\n  @Input() layoutNode: any;\n  @Input() layoutIndex: number[];\n  @Input() dataIndex: number[];\n\n  constructor(\n    public changeDetector: ChangeDetectorRef,\n    public jsf: JsonSchemaFormService\n  ) { }\n\n  get showRemoveButton(): boolean {\n    if (!this.options.removable || this.options.readonly ||\n      this.layoutNode.type === '$ref'\n    ) { return false; }\n    if (this.layoutNode.recursiveReference) { return true; }\n    if (!this.layoutNode.arrayItem || !this.parentArray) { return false; }\n    // If array length <= minItems, don't allow removing any items\n    return this.parentArray.items.length - 1 <= this.parentArray.options.minItems ? false :\n      // For removable list items, allow removing any item\n      this.layoutNode.arrayItemType === 'list' ? true :\n        // For removable tuple items, only allow removing last item in list\n        this.layoutIndex[this.layoutIndex.length - 1] === this.parentArray.items.length - 2;\n  }\n\n  ngOnInit() {\n    this.initializeFramework();\n    if (this.layoutNode.arrayItem && this.layoutNode.type !== '$ref') {\n      this.parentArray = this.jsf.getParentNode(this);\n      if (this.parentArray) {\n        this.isOrderable = this.layoutNode.arrayItemType === 'list' &&\n          !this.options.readonly && this.parentArray.options.orderable;\n      }\n    }\n  }\n\n  ngOnChanges() {\n    if (!this.frameworkInitialized) { this.initializeFramework(); }\n  }\n\n  initializeFramework() {\n    if (this.layoutNode) {\n      this.options = _.cloneDeep(this.layoutNode.options);\n      this.widgetLayoutNode = {\n        ...this.layoutNode,\n        options: _.cloneDeep(this.layoutNode.options)\n      };\n      this.widgetOptions = this.widgetLayoutNode.options;\n      this.formControl = this.jsf.getFormControl(this);\n\n      this.options.isInputWidget = inArray(this.layoutNode.type, [\n        'button', 'checkbox', 'checkboxes-inline', 'checkboxes', 'color',\n        'date', 'datetime-local', 'datetime', 'email', 'file', 'hidden',\n        'image', 'integer', 'month', 'number', 'password', 'radio',\n        'radiobuttons', 'radios-inline', 'radios', 'range', 'reset', 'search',\n        'select', 'submit', 'tel', 'text', 'textarea', 'time', 'url', 'week'\n      ]);\n\n      this.options.title = this.setTitle();\n\n      this.options.htmlClass =\n        addClasses(this.options.htmlClass, 'schema-form-' + this.layoutNode.type);\n      this.options.htmlClass =\n        this.layoutNode.type === 'array' ?\n          addClasses(this.options.htmlClass, 'list-group') :\n          this.layoutNode.arrayItem && this.layoutNode.type !== '$ref' ?\n            addClasses(this.options.htmlClass, 'list-group-item') :\n            addClasses(this.options.htmlClass, 'form-group');\n      this.widgetOptions.htmlClass = '';\n      this.options.labelHtmlClass =\n        addClasses(this.options.labelHtmlClass, 'control-label');\n      this.widgetOptions.activeClass =\n        addClasses(this.widgetOptions.activeClass, 'active');\n      this.options.fieldAddonLeft =\n        this.options.fieldAddonLeft || this.options.prepend;\n      this.options.fieldAddonRight =\n        this.options.fieldAddonRight || this.options.append;\n\n      // Add asterisk to titles if required\n      if (this.options.title && this.layoutNode.type !== 'tab' &&\n        !this.options.notitle && this.options.required  &&\n        !this.options.title.includes('*')\n      ) {\n        this.options.title += ' <strong class=\"text-danger\">*</strong>';\n      }\n      // Set miscelaneous styles and settings for each control type\n      switch (this.layoutNode.type) {\n        // Checkbox controls\n        case 'checkbox': case 'checkboxes':\n        this.widgetOptions.htmlClass = addClasses(\n          this.widgetOptions.htmlClass, 'checkbox');\n        break;\n        case 'checkboxes-inline':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'checkbox');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, 'checkbox-inline');\n          break;\n        // Radio controls\n        case 'radio': case 'radios':\n        this.widgetOptions.htmlClass = addClasses(\n          this.widgetOptions.htmlClass, 'radio');\n        break;\n        case 'radios-inline':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'radio');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, 'radio-inline');\n          break;\n        // Button sets - checkboxbuttons and radiobuttons\n        case 'checkboxbuttons': case 'radiobuttons':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'btn-group');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, 'btn');\n          this.widgetOptions.itemLabelHtmlClass = addClasses(\n            this.widgetOptions.itemLabelHtmlClass, this.options.style || 'btn-default');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'sr-only');\n        break;\n        // Single button controls\n        case 'button': case 'submit':\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'btn');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-info');\n        break;\n        // Containers - arrays and fieldsets\n        case 'array': case 'fieldset': case 'section': case 'conditional':\n        case 'advancedfieldset': case 'authfieldset':\n        case 'selectfieldset': case 'optionfieldset':\n          this.options.messageLocation = 'top';\n        break;\n        case 'tabarray': case 'tabs':\n          this.widgetOptions.htmlClass = addClasses(\n            this.widgetOptions.htmlClass, 'tab-content');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'tab-pane');\n          this.widgetOptions.labelHtmlClass = addClasses(\n            this.widgetOptions.labelHtmlClass, 'nav nav-tabs');\n        break;\n        // 'Add' buttons - references\n        case '$ref':\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'btn pull-right');\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, this.options.style || 'btn-default');\n          this.options.icon = 'glyphicon glyphicon-plus';\n        break;\n        // Default - including regular inputs\n        default:\n          this.widgetOptions.fieldHtmlClass = addClasses(\n            this.widgetOptions.fieldHtmlClass, 'form-control');\n      }\n\n      if (this.formControl) {\n        this.updateHelpBlock(this.formControl.status);\n        this.formControl.statusChanges.subscribe(status => this.updateHelpBlock(status));\n\n        if (this.options.debug) {\n          const vars: any[] = [];\n          this.debugOutput = _.map(vars, thisVar => JSON.stringify(thisVar, null, 2)).join('\\n');\n        }\n      }\n      this.frameworkInitialized = true;\n    }\n\n  }\n\n  updateHelpBlock(status) {\n    this.options.helpBlock = status === 'INVALID' &&\n      this.options.enableErrorState && this.formControl.errors &&\n      (this.formControl.dirty || this.options.feedbackOnRender) ?\n        this.jsf.formatErrors(this.formControl.errors, this.options.validationMessages) :\n        this.options.description || this.options.help || null;\n  }\n\n  setTitle(): string {\n    switch (this.layoutNode.type) {\n      case 'button': case 'checkbox': case 'section': case 'help': case 'msg':\n      case 'submit': case 'message': case 'tabarray': case 'tabs': case '$ref':\n        return null;\n      case 'advancedfieldset':\n        this.widgetOptions.expandable = true;\n        this.widgetOptions.title = 'Advanced options';\n        return null;\n      case 'authfieldset':\n        this.widgetOptions.expandable = true;\n        this.widgetOptions.title = 'Authentication settings';\n        return null;\n      case 'fieldset':\n        this.widgetOptions.title = this.options.title;\n        return null;\n      default:\n        this.widgetOptions.title = null;\n        return this.jsf.setItemTitle(this);\n    }\n  }\n\n  removeItem() {\n    this.jsf.removeItem(this);\n  }\n}\n",
    "import { Injectable } from '@angular/core';\n\nimport { Framework } from '../framework';\n\n// Bootstrap 4 Framework\n// https://github.com/ng-bootstrap/ng-bootstrap\nimport { Bootstrap4FrameworkComponent } from './bootstrap-4-framework.component';\n\n\n@Injectable()\nexport class Bootstrap4Framework extends Framework {\n  name = 'bootstrap-4';\n\n  framework = Bootstrap4FrameworkComponent;\n\n  stylesheets = [\n    '//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/css/bootstrap.min.css'\n  ];\n\n  scripts = [\n    '//code.jquery.com/jquery-3.2.1.slim.min.js',\n    '//cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.3/umd/popper.min.js',\n    '//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-beta.2/js/bootstrap.min.js',\n  ];\n}\n",
    "import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { JsonSchemaFormService } from '../../json-schema-form.service';\nimport { WidgetLibraryModule } from '../../widget-library/widget-library.module';\nimport { Framework } from '../framework';\nimport { Bootstrap4FrameworkComponent } from './bootstrap-4-framework.component';\nimport { Bootstrap4Framework } from './bootstrap-4.framework';\n\n@NgModule({\n  imports:         [ CommonModule, WidgetLibraryModule ],\n  declarations:    [ Bootstrap4FrameworkComponent ],\n  exports:         [ Bootstrap4FrameworkComponent ],\n  entryComponents: [ Bootstrap4FrameworkComponent ]\n})\nexport class Bootstrap4FrameworkModule {\n  static forRoot(): ModuleWithProviders {\n    return {\n      ngModule: Bootstrap4FrameworkModule,\n      providers: [\n        { provide: Framework, useClass: Bootstrap4Framework, multi: true }\n      ]\n    };\n  }\n}\n"
  ],
  "names": [
    "_executeValidators",
    "control",
    "validators",
    "invert",
    "_executeAsyncValidators",
    "_mergeObjects",
    "objects",
    "_i",
    "arguments",
    "length",
    "mergedObject",
    "objects_1",
    "tslib_1.__values",
    "objects_1_1",
    "next",
    "done",
    "currentObject",
    "value",
    "isObject",
    "_a",
    "Object",
    "keys",
    "_b",
    "key",
    "currentValue",
    "mergedValue",
    "_c",
    "return",
    "call",
    "e_2",
    "error",
    "_mergeErrors",
    "arrayOfErrors",
    "mergedErrors",
    "apply",
    "tslib_1.__spread",
    "isEmpty",
    "isDefined",
    "undefined",
    "hasValue",
    "isArray",
    "isString",
    "isNaN",
    "isInteger",
    "strict",
    "isBoolean",
    "option",
    "isNumber",
    "toJavaScriptType",
    "types",
    "strictIntegers",
    "inArray",
    "parseInt",
    "toSchemaType",
    "includes",
    "testValue",
    "isPromise",
    "object",
    "then",
    "addClasses",
    "oldClasses",
    "newClasses",
    "badType",
    "i",
    "isSet",
    "toSet",
    "Set",
    "split",
    "combinedSet",
    "forEach",
    "c",
    "add",
    "Array",
    "from",
    "join",
    "copy",
    "errors",
    "isMap",
    "Map",
    "assign",
    "console",
    "fn",
    "recurse",
    "rootObject",
    "e_1_1",
    "e_1",
    "forEachCopy",
    "newObject",
    "has",
    "property",
    "hasOwnProperty",
    "mergeFilteredObject",
    "targetObject",
    "sourceObject",
    "excludeKeys",
    "keyFn",
    "valFn",
    "val",
    "e_3_1",
    "e_3",
    "e_4",
    "items_1_1",
    "items_1",
    "returnItems",
    "commonItems",
    "arrays",
    "e_5",
    "_loop_1",
    "array",
    "filter",
    "item",
    "arrays_1",
    "arrays_1_1",
    "state_1",
    "e_5_1",
    "JsonPointer",
    "get",
    "pointer",
    "startSlice",
    "endSlice",
    "getBoolean",
    "keyArray",
    "this",
    "parse",
    "subObject",
    "slice",
    "keyArray_1",
    "keyArray_1_1",
    "hasOwn",
    "getCopy",
    "objectToCopy",
    "forEachDeepCopy",
    "getFirst",
    "items",
    "defaultValue",
    "items_2_1",
    "items_2",
    "getFirstCopy",
    "match",
    "lastKey",
    "push",
    "insert",
    "splice",
    "set",
    "remove",
    "dict",
    "results",
    "forEachDeep",
    "bottomUp",
    "v",
    "newPointer",
    "escape",
    "toString",
    "replace",
    "map",
    "unescape",
    "compile",
    "_this",
    "isJsonPointer",
    "toKey",
    "isSubPointer",
    "shortPointer",
    "longPointer",
    "trueIfMatching",
    "invalid",
    "toIndexedPointer",
    "genericPointer",
    "indexArray",
    "arrayMap",
    "indexedPointer_1",
    "arrayIndex_1",
    "stringIndex",
    "indexArray_1",
    "indexArray_1_1",
    "pointerIndex",
    "e_6_1",
    "e_6",
    "toGenericPointer",
    "indexedPointer",
    "pointerArray",
    "subPointer",
    "e_7",
    "controlPointerArray",
    "subGroup",
    "controlMustExist",
    "dataPointer",
    "formGroup",
    "controls",
    "e_7_1",
    "dataPointerArray_1_1",
    "dataPointerArray_1",
    "toSchemaPointer",
    "schema",
    "type",
    "firstKey",
    "arrayItem",
    "additionalItems",
    "toDataPointer",
    "schemaPointer",
    "shift",
    "pointerSuffix",
    "secondKey",
    "jsonSchemaFormatTests",
    "date",
    "time",
    "date-time",
    "email",
    "hostname",
    "ipv4",
    "ipv6",
    "uri",
    "uri-reference",
    "uri-template",
    "url",
    "uuid",
    "color",
    "json-pointer",
    "relative-json-pointer",
    "regex",
    "str",
    "test",
    "e",
    "JsonValidators",
    "required",
    "input",
    "nullValidator",
    "requiredType",
    "some",
    "isType",
    "enum",
    "allowedValues",
    "isEqual",
    "enumValue",
    "inputValue",
    "_.isEqual",
    "const",
    "requiredValue",
    "constValue",
    "minLength",
    "minimumLength",
    "maxLength",
    "maximumLength",
    "pattern",
    "wholeString",
    "requiredPattern",
    "RegExp",
    "format",
    "requiredFormat",
    "isValid",
    "formatTest",
    "minimum",
    "minimumValue",
    "exclusiveMinimum",
    "exclusiveMinimumValue",
    "maximum",
    "maximumValue",
    "xor",
    "exclusiveMaximumValue",
    "exclusiveMaximum",
    "multipleOfValue",
    "multipleOf",
    "currentProperties",
    "minimumProperties",
    "minProperties",
    "maximumProperties",
    "maxProperties",
    "dependencies",
    "getType",
    "requiringField",
    "requiredFields",
    "requiringFieldErrors",
    "properties",
    "requiredFields_1",
    "requiredFields_1_1",
    "requiredField",
    "requirements",
    "requiredFieldErrors",
    "requirement",
    "parameter",
    "validator",
    "exclusive",
    "minItems",
    "minimumItems",
    "currentItems",
    "maxItems",
    "maximumItems",
    "uniqueItems",
    "unique",
    "sorted",
    "sort",
    "duplicateItems",
    "contains",
    "requiredItem",
    "composeAnyOf",
    "presentValidators",
    "composeOneOf",
    "composeAllOf",
    "combinedErrors",
    "allOf",
    "composeNot",
    "compose",
    "composeAsync",
    "min",
    "parseFloat",
    "mergeSchemas",
    "schemas",
    "combinedSchema",
    "schemas_1",
    "schemas_1_1",
    "x",
    "y",
    "combinedValue",
    "schemaValue",
    "item1",
    "findIndex",
    "item2",
    "combinedObject",
    "subKey",
    "_d",
    "_e",
    "combinedDependency",
    "schemaDependency",
    "e_2_1",
    "_f",
    "gcd_1",
    "Math",
    "max",
    "notAnyOf",
    "reduce",
    "notAnyOfArray",
    "notSchema",
    "anyOf",
    "not",
    "_g",
    "_h",
    "patternProperties",
    "combinedObject_1",
    "combinedKey",
    "nonMatchingKey",
    "additionalProperties",
    "_k",
    "_l",
    "e_4_1",
    "_m",
    "buildSchemaFromLayout",
    "layout",
    "buildSchemaFromData",
    "data",
    "requireAllFields",
    "isRoot",
    "newSchema",
    "getFieldType",
    "fieldType",
    "integer",
    "null",
    "buildSubSchema",
    "$schema",
    "getFromSchema",
    "returnType",
    "dataPointerArray",
    "subSchema",
    "subSchemaFound",
    "removeRecursiveReferences",
    "recursiveRefMap",
    "indexOf",
    "fromPointer",
    "layoutNode",
    "controlType",
    "checkInlineType",
    "schemaType",
    "getTitleMapFromOneOf",
    "isInputRequired",
    "listPointerArray",
    "parentSchema",
    "keyName",
    "updateInputOptions",
    "jsf",
    "options",
    "newOptions",
    "fixUiKeys",
    "toLowerCase",
    "formOptions",
    "defautWidgetOptions",
    "tslib_1.__read",
    "newTitleMap",
    "flatList",
    "titleMap",
    "enumNames",
    "typeahead",
    "autocomplete",
    "tagsinput",
    "validateOnly",
    "oneOf",
    "every",
    "title",
    "name",
    "newTitleMap_1",
    "group",
    "index",
    "getControlValidators",
    "prop",
    "ucLimit",
    "eLimit",
    "limit",
    "resolveSchemaReferences",
    "schemaRefLibrary",
    "schemaRecursiveRefMap",
    "dataRecursiveRefMap",
    "refLinks",
    "refMapSet",
    "refMap",
    "refLibrary",
    "refPointer",
    "subSchemaPointer",
    "ref",
    "getSubSchema",
    "checkRefLinks",
    "fromRef2",
    "toRef2",
    "toRef1",
    "fromRef1",
    "refLink",
    "fromRef",
    "toRef",
    "compiledSchema",
    "definitions",
    "$ref",
    "fromDataRef",
    "toDataRef",
    "tupleItems",
    "usedPointers",
    "_.cloneDeep",
    "refSchema",
    "extraKeys",
    "combineAllOf",
    "convertSchemaToDraft6",
    "draft",
    "changed",
    "simpleTypes",
    "contentEncoding",
    "media",
    "binaryEncoding",
    "extends",
    "disallow",
    "maxDecimal",
    "pow",
    "divisibleBy",
    "minimumCanEqual",
    "maximumCanEqual",
    "properties_1",
    "optional",
    "requiredKeys_1",
    "size",
    "requires",
    "dependencies_1",
    "id",
    "$id",
    "addToDescription",
    "description",
    "arrayKeys",
    "numberKeys",
    "objectKeys",
    "stringKeys",
    "filterKeys_1",
    "number",
    "string",
    "all",
    "newType",
    "typeSchema",
    "newKey_1",
    "buildFormGroupTemplate",
    "nodeValue",
    "setValues",
    "templatePointer",
    "setSchemaDefaults",
    "formValues",
    "shortDataPointer",
    "dataMap",
    "nodeOptions",
    "propertyKeys_1",
    "unnamedKeys",
    "fieldsRequired",
    "setRequiredFields",
    "additionalItemsPointer",
    "schemaRefPointer",
    "itemRecursive",
    "itemRefPointer",
    "templateRefLibrary",
    "itemOptions",
    "arrayLength",
    "schemaRef",
    "newTemplate",
    "isPrimitive",
    "disabled",
    "buildFormGroup",
    "template",
    "validatorFns",
    "validatorFn",
    "parameters",
    "groupControls_1",
    "newControl",
    "FormGroup",
    "FormArray",
    "_.filter",
    "_.map",
    "formControlTemplate",
    "requiredArray",
    "formatFormData",
    "formData",
    "returnEmptyFields",
    "fixErrors",
    "formattedData",
    "isDate",
    "genericPointer_1",
    "newValue",
    "getControl",
    "returnGroup",
    "formControl",
    "buildLayout",
    "widgetLibrary",
    "hasSubmitButton",
    "formLayout",
    "mapLayout",
    "layoutItem",
    "layoutPointer",
    "newNode",
    "_id",
    "_.uniqueId",
    "widget",
    "legend",
    "validationMessages",
    "errorMessages",
    "validationMessage",
    "code",
    "newKey",
    "parseObjectPath",
    "findDataPointer_1",
    "searchItem",
    "childDataPointer",
    "lastIndexOf",
    "buildLayoutFromSchema",
    "LastKey",
    "recursive_1",
    "nodeDataMap",
    "nodeSchema",
    "hasWidget",
    "oldWidgetType",
    "getInputType",
    "dataType",
    "listItems",
    "fixTitle",
    "copyValueTo",
    "getWidget",
    "itemRefPointer_1",
    "arrayItemGroup",
    "subItem",
    "unshift",
    "arrayItemType",
    "removable",
    "orderable",
    "arrayListItems",
    "layoutRefLibrary",
    "recursiveReference",
    "getLayoutNode",
    "addable",
    "buttonText",
    "fieldStyle",
    "style",
    "parentType",
    "hasRootReference",
    "fullLayout",
    "pop",
    "forRefLibrary",
    "dataPointerPrefix",
    "newNodeType",
    "lastDataKey",
    "newSection_1",
    "innerItem",
    "keySchemaPointer",
    "additionalItemsSchemaPointer",
    "newItem",
    "itemSchemaPointer",
    "prefix",
    "dataRef",
    "rootLayout",
    "indexPad",
    "newLayout",
    "realIndex",
    "newLayoutPointer",
    "itemsArray",
    "tabs",
    "concat",
    "refNode",
    "newLayoutNode",
    "subNode",
    "buildTitleMap",
    "enumList",
    "fieldRequired",
    "hasEmptyValue",
    "name_1",
    "name_2",
    "name_3",
    "name_4",
    "_j",
    "name_5",
    "dateToString",
    "stringToDate",
    "prototype",
    "dateFormat",
    "getFullYear",
    "getMonth",
    "getDay",
    "getDate",
    "last",
    "1",
    "2",
    "3",
    "ordinal",
    "dateString",
    "findDate",
    "dateParts",
    "year",
    "thisYear",
    "Date",
    "text",
    "foundDate",
    "enValidationMessages",
    "log10",
    "frValidationMessages",
    "JsonSchemaFormService",
    "JsonFormCompatibility",
    "ReactJsonSchemaFormCompatibility",
    "AngularSchemaFormCompatibility",
    "tpldata",
    "ajvOptions",
    "allErrors",
    "jsonPointers",
    "unknownFormats",
    "ajv",
    "Ajv",
    "validateFormData",
    "formGroupTemplate",
    "framework",
    "validData",
    "ajvErrors",
    "validationErrors",
    "dataErrors",
    "formValueSubscription",
    "dataChanges",
    "Subject",
    "isValidChanges",
    "validationErrorChanges",
    "defaultFormOptions",
    "pristine",
    "success",
    "supressPropertyTitles",
    "setLanguage",
    "language",
    "getData",
    "getSchema",
    "getLayout",
    "resetAllValues",
    "buildRemoteError",
    "value_1",
    "value_1_1",
    "err",
    "setErrors",
    "emitEvent",
    "validateData",
    "updateSubscriptions",
    "compiledErrors",
    "dataPath",
    "message",
    "compileAjvSchema",
    "unsubscribe",
    "valueChanges",
    "subscribe",
    "formValue",
    "setOptions",
    "addOptions",
    "defaultOptions",
    "globalDefaults_1",
    "suffix",
    "removeSchema",
    "setTpldata",
    "newTpldata",
    "parseText",
    "values",
    "a",
    "parseExpression",
    "expression",
    "trim",
    "delim",
    "term",
    "setArrayItemTitle",
    "parentCtx",
    "childNode",
    "parentNode",
    "parentValues",
    "getFormControlValue",
    "isArrayItem",
    "childValue",
    "setItemTitle",
    "ctx",
    "toTitleCase",
    "getFormControlGroup",
    "dataIndex",
    "evaluateCondition",
    "arrayIndex",
    "result",
    "condition",
    "model",
    "functionBody",
    "Function",
    "dynFn",
    "initializeControl",
    "bind",
    "getFormControl",
    "boundControl",
    "controlName",
    "getFormControlName",
    "controlDisabled",
    "formatErrors",
    "showErrors",
    "validateOnRender",
    "statusChanges",
    "status",
    "errorMessage",
    "controlValue",
    "addSpaces",
    "toUpperCase",
    "formatError",
    "errorKey",
    "errorProperty",
    "updateValue",
    "setValue",
    "markAsDirty",
    "targetControl",
    "updateArrayCheckboxList",
    "checkboxList",
    "formArray",
    "removeAt",
    "checkboxList_1",
    "checkboxList_1_1",
    "checkboxItem",
    "checked",
    "newFormControl",
    "getDataPointer",
    "getLayoutArray",
    "getParentNode",
    "getLayoutPointer",
    "layoutIndex",
    "isControlBound",
    "controlGroup",
    "addItem",
    "OrderableDirective",
    "elementRef",
    "ngZone",
    "overParentElement",
    "overChildElement",
    "ngOnInit",
    "element",
    "nativeElement",
    "draggable",
    "arrayLayoutIndex",
    "addEventListener",
    "event",
    "sourceArrayIndex",
    "sessionStorage",
    "setItem",
    "preventDefault",
    "dataTransfer",
    "dropEffect",
    "getItem",
    "classList",
    "destArrayIndex",
    "moveArrayItem",
    "removeItem",
    "decorators",
    "ctorParameters",
    "NgZone",
    "propDecorators",
    "Input",
    "AddReferenceComponent",
    "defineProperty",
    "enumerable",
    "configurable",
    "parent",
    "itemCount",
    "Component",
    "args",
    "selector",
    "OneOfComponent",
    "target",
    "ButtonComponent",
    "onClick",
    "CheckboxComponent",
    "trueValue",
    "falseValue",
    "CheckboxesComponent",
    "layoutOrientation",
    "formArray_1",
    "FileComponent",
    "InputComponent",
    "autoCompleteList",
    "MessageComponent",
    "help",
    "helpvalue",
    "msg",
    "NoneComponent",
    "NumberComponent",
    "allowNegative",
    "allowDecimal",
    "allowExponents",
    "lastValidNumber",
    "RadiosComponent",
    "radiosList",
    "RootComponent",
    "isFlexItem",
    "isDraggable",
    "node",
    "isOrderable",
    "getFlexAttribute",
    "attribute",
    "flex",
    "showWidget",
    "SectionComponent",
    "expanded",
    "notitle",
    "expandable",
    "containerType",
    "toggleExpanded",
    "flexActive",
    "displayFlex",
    "display",
    "SelectComponent",
    "selectList",
    "SelectFrameworkComponent",
    "componentFactory",
    "newComponent",
    "updateComponent",
    "ngOnChanges",
    "widgetContainer",
    "createComponent",
    "resolveComponentFactory",
    "instance",
    "SelectWidgetComponent",
    "SubmitComponent",
    "disableInvalidSubmit",
    "TabsComponent",
    "selectedItem",
    "showAddTab",
    "updateControl",
    "select",
    "lastItem",
    "setTabTitle",
    "TemplateComponent",
    "TextareaComponent",
    "WidgetLibraryService",
    "defaultWidget",
    "password",
    "search",
    "tel",
    "datetime",
    "datetime-local",
    "month",
    "range",
    "hidden",
    "radio",
    "button",
    "updown",
    "alt-datetime",
    "textline",
    "registeredWidgets",
    "frameworkWidgets",
    "activeWidgets",
    "setActiveWidgets",
    "widgetName",
    "usedAliases",
    "setDefaultWidget",
    "widgetSet",
    "hasDefaultWidget",
    "registerWidget",
    "unRegisterWidget",
    "unRegisterAllWidgets",
    "unRegisterFrameworkWidgets",
    "registerFrameworkWidgets",
    "widgets",
    "Framework",
    "stylesheets",
    "scripts",
    "FrameworkLibraryService",
    "frameworks",
    "activeFramework",
    "loadExternalAssets",
    "frameworkLibrary",
    "defaultFramework",
    "setFramework",
    "setLoadExternalAssets",
    "hasFramework",
    "getFramework",
    "getFrameworkWidgets",
    "getFrameworkStylesheets",
    "load",
    "getFrameworkScripts",
    "JSON_SCHEMA_FORM_VALUE_ACCESSOR",
    "useExisting",
    "forwardRef",
    "JsonSchemaFormComponent",
    "multi",
    "changeDetector",
    "sanitizer",
    "formInitialized",
    "objectWrap",
    "previousInputs",
    "form",
    "JSONSchema",
    "UISchema",
    "debug",
    "onChanges",
    "EventEmitter",
    "formSchema",
    "dataChange",
    "modelChange",
    "formDataChange",
    "ngModelChange",
    "setFormValues",
    "bypassSecurityTrustResourceUrl",
    "stylesheet",
    "script",
    "updateForm",
    "writeValue",
    "formValuesInput",
    "registerOnChange",
    "onChange",
    "registerOnTouched",
    "onTouched",
    "setDisabledState",
    "isDisabled",
    "formDisabled",
    "initializeForm",
    "changedInput",
    "resetFirst",
    "startsWith",
    "newFormValues",
    "reset",
    "activateForm",
    "patchValue",
    "debugOutput",
    "JSON",
    "stringify",
    "initializeOptions",
    "initializeSchema",
    "initializeData",
    "ngModel",
    "initializeLayout",
    "fixJsonFormOptions",
    "alternateLayout",
    "uiSchema",
    "customFormItems",
    "itemPointer",
    "emit",
    "markForCheck",
    "validateOnRender_1",
    "markAsTouched",
    "touchAll_1",
    "changeDetection",
    "ChangeDetectionStrategy",
    "OnPush",
    "providers",
    "ChangeDetectorRef",
    "DomSanitizer",
    "HiddenComponent",
    "TabComponent",
    "BASIC_WIDGETS",
    "WidgetLibraryModule",
    "forRoot",
    "ngModule",
    "NgModule",
    "imports",
    "CommonModule",
    "FormsModule",
    "ReactiveFormsModule",
    "NoFrameworkComponent",
    "NoFramework",
    "_super",
    "NoFrameworkModule",
    "provide",
    "useClass",
    "JsonSchemaFormModule",
    "loadFrameworks",
    "FlexLayoutRootComponent",
    "FlexLayoutSectionComponent",
    "MaterialAddReferenceComponent",
    "Default",
    "MaterialOneOfComponent",
    "MaterialButtonComponent",
    "MaterialButtonGroupComponent",
    "vertical",
    "MaterialCheckboxComponent",
    "showSlideToggle",
    "readonly",
    "MaterialCheckboxesComponent",
    "horizontalList",
    "t",
    "checkedItems",
    "MaterialChipListComponent",
    "MaterialDatepickerComponent",
    "setControlDate",
    "placeholder",
    "dateValue",
    "MaterialFileComponent",
    "MaterialInputComponent",
    "MaterialNumberComponent",
    "MaterialRadiosComponent",
    "flexDirection",
    "MaterialSelectComponent",
    "MaterialSliderComponent",
    "MaterialStepperComponent",
    "MaterialTabsComponent",
    "MaterialTextareaComponent",
    "MaterialDesignFrameworkComponent",
    "frameworkInitialized",
    "parentArray",
    "dynamicTitle",
    "widgetOptions",
    "initializeFramework",
    "updateTitle",
    "widgetLayoutNode",
    "MaterialDesignFramework",
    "root",
    "section",
    "button-group",
    "checkbox",
    "checkboxes",
    "chip-list",
    "file",
    "one-of",
    "radios",
    "slider",
    "stepper",
    "textarea",
    "alt-date",
    "any-of",
    "card",
    "expansion-panel",
    "image",
    "radiobuttons",
    "submit",
    "MATERIAL_FRAMEWORK_COMPONENTS",
    "ANGULAR_MATERIAL_MODULES",
    "MatAutocompleteModule",
    "MatButtonModule",
    "MatButtonToggleModule",
    "MatCardModule",
    "MatCheckboxModule",
    "MatChipsModule",
    "MatDatepickerModule",
    "MatExpansionModule",
    "MatFormFieldModule",
    "MatIconModule",
    "MatInputModule",
    "MatNativeDateModule",
    "MatRadioModule",
    "MatSelectModule",
    "MatSliderModule",
    "MatSlideToggleModule",
    "MatStepperModule",
    "MatTabsModule",
    "MatTooltipModule",
    "MaterialDesignFrameworkModule",
    "FlexLayoutModule",
    "Bootstrap3FrameworkComponent",
    "isInputWidget",
    "setTitle",
    "htmlClass",
    "labelHtmlClass",
    "activeClass",
    "fieldAddonLeft",
    "prepend",
    "fieldAddonRight",
    "append",
    "itemLabelHtmlClass",
    "fieldHtmlClass",
    "messageLocation",
    "icon",
    "updateHelpBlock",
    "thisVar",
    "helpBlock",
    "enableErrorState",
    "dirty",
    "feedbackOnRender",
    "Bootstrap3Framework",
    "Bootstrap3FrameworkModule",
    "Bootstrap4FrameworkComponent",
    "Bootstrap4Framework",
    "Bootstrap4FrameworkModule",
    "toPromise"
  ],
  "mappings": "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"
}
