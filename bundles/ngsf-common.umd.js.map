{"version":3,"file":"ngsf-common.umd.js","sources":["ng://@ngsf/common/lib/functions/validator/executeAsyncValidators.ts","ng://@ngsf/common/lib/functions/validator/executeValidators.ts","ng://@ngsf/common/lib/functions/validator/isArray.ts","ng://@ngsf/common/lib/functions/validator/isObject.ts","ng://@ngsf/common/lib/functions/validator/isBoolean.ts","ng://@ngsf/common/lib/functions/validator/isInteger.ts","ng://@ngsf/common/lib/functions/validator/isNumber.ts","ng://@ngsf/common/lib/functions/validator/isString.ts","ng://@ngsf/common/lib/functions/validator/isDate.ts","ng://@ngsf/common/lib/functions/validator/isDefined.ts","ng://@ngsf/common/lib/functions/validator/getType.ts","ng://@ngsf/common/lib/functions/validator/hasValue.ts","ng://@ngsf/common/lib/functions/validator/inArray.ts","ng://@ngsf/common/lib/functions/validator/isEmpty.ts","ng://@ngsf/common/lib/functions/validator/isFunction.ts","ng://@ngsf/common/lib/functions/validator/isMap.ts","ng://@ngsf/common/lib/functions/validator/isObservable.ts","ng://@ngsf/common/lib/functions/validator/isPrimitive.ts","ng://@ngsf/common/lib/functions/validator/isPromise.ts","ng://@ngsf/common/lib/functions/validator/isSet.ts","ng://@ngsf/common/lib/functions/validator/isSymbol.ts","ng://@ngsf/common/lib/functions/validator/isType.ts","ng://@ngsf/common/lib/functions/validator/xor.ts","ng://@ngsf/common/lib/functions/validator/mergeObjects.ts","ng://@ngsf/common/lib/functions/validator/mergeErrors.ts","ng://@ngsf/common/lib/functions/validator/toJavascriptType.ts","ng://@ngsf/common/lib/functions/validator/toObservable.ts","ng://@ngsf/common/lib/functions/validator/toPromise.ts","ng://@ngsf/common/lib/functions/validator/toSchemaType.ts","ng://@ngsf/common/lib/functions/utility/addClasses.ts","ng://@ngsf/common/lib/functions/utility/commonItems.ts","ng://@ngsf/common/lib/functions/utility/copy.ts","ng://@ngsf/common/lib/functions/utility/toTitleCase.ts","ng://@ngsf/common/lib/functions/utility/fixTitle.ts","ng://@ngsf/common/lib/functions/utility/forEach.ts","ng://@ngsf/common/lib/functions/utility/forEachCopy.ts","ng://@ngsf/common/lib/functions/utility/hasOwn.ts","ng://@ngsf/common/lib/functions/utility/mergeFilteredObject.ts","ng://@ngsf/common/lib/functions/utility/uniqueItems.ts","ng://@ngsf/common/lib/functions/jsonpointer.functions.ts","ng://@ngsf/common/lib/constants/format-regex.constants.ts","ng://@ngsf/common/lib/json.validators.ts","ng://@ngsf/common/lib/functions/json-schema/buildSchemaFromData.ts","ng://@ngsf/common/lib/functions/json-schema/buildSchemaFromLayout.ts","ng://@ngsf/common/lib/functions/json-schema/checkInlineType.ts","ng://@ngsf/common/lib/functions/merge-schemas/mergeSchemas.ts","ng://@ngsf/common/lib/functions/json-schema/combineAllOf.ts","ng://@ngsf/common/lib/functions/json-schema/fixRequiredArrayProperties.ts","ng://@ngsf/common/lib/functions/json-schema/getControlValidators.ts","ng://@ngsf/common/lib/functions/json-schema/getFromSchema.ts","ng://@ngsf/common/lib/functions/json-schema/getTitleMapFromOneOf.ts","ng://@ngsf/common/lib/functions/json-schema/getInputType.ts","ng://@ngsf/common/lib/functions/json-schema/removeRecursiveReferences.ts","ng://@ngsf/common/lib/functions/json-schema/getSubSchema.ts","ng://@ngsf/common/lib/functions/json-schema/isInputRequired.ts","ng://@ngsf/common/lib/functions/json-schema/resolveSchemaReferences.ts","ng://@ngsf/common/lib/functions/json-schema/updateInputOptions.ts","ng://@ngsf/common/lib/functions/convert-schema-to-draft6.function.ts","ng://@ngsf/common/lib/functions/form-group/buildFormGroup.ts","ng://@ngsf/common/lib/functions/form-group/setRequiredFields.ts","ng://@ngsf/common/lib/functions/form-group/buildFormGroupTemplate.ts","ng://@ngsf/common/lib/functions/form-group/formatFormData.ts","ng://@ngsf/common/lib/functions/form-group/getControl.ts","ng://@ngsf/common/lib/functions/form-group/mergeValues.ts","ng://@ngsf/common/lib/functions/layout/buildLayoutFromSchema.ts","ng://@ngsf/common/lib/functions/layout/mapLayout.ts","ng://@ngsf/common/lib/functions/layout/buildLayout.ts","ng://@ngsf/common/lib/functions/date/ordinal.ts","ng://@ngsf/common/lib/functions/date/findDate.ts","ng://@ngsf/common/lib/functions/date/stringToDate.ts","ng://@ngsf/common/lib/functions/date/dateToString.ts","ng://@ngsf/common/lib/framework.ts","ng://@ngsf/common/lib/locale/en-validation-messages.ts","ng://@ngsf/common/lib/locale/fr-validation-messages.ts"],"sourcesContent":["/**\n * 'executeAsyncValidators' utility function\n *\n * Validates a control against an array of async validators, and returns\n * an array of observabe results of the same length containing a combination of\n * error messages (from invalid validators) and null values (from valid ones)\n *\n * @param  { AbstractControl } control - control to validate\n * @param  { AsyncIValidatorFn[] } validators - array of async validators\n * @param  { boolean } invert - invert?\n * @return array of observable nulls and error message\n */\nimport {AbstractControl} from '@angular/forms'\nimport {AsyncIValidatorFn} from './types'\n\nexport function executeAsyncValidators(\n  control: AbstractControl,\n  validators: AsyncIValidatorFn[],\n  invert = false\n) {\n  return validators.map(validator => validator(control, invert))\n}\n","import {AbstractControl} from '@angular/forms'\nimport {IValidatorFn, PlainObject} from './types'\n\n/**\n * 'executeValidators' utility function\n *\n * Validates a control against an array of validators, and returns\n * an array of the same length containing a combination of error messages\n * (from invalid validators) and null values (from valid validators)\n *\n * @param control to validate\n * @param validators - array of validators\n * @param invert - invert?\n * @return array of nulls and error message\n */\nexport function executeValidators(\n  control: AbstractControl,\n  validators: IValidatorFn[],\n  invert = false\n): PlainObject[] {\n  return validators.map(validator => validator(control, invert))\n}\n","export function isArray(item: any): boolean {\n  return Array.isArray(item) ||\n    Object.prototype.toString.call(item) === '[object Array]'\n}\n","export function isObject(item: any): boolean {\n  return item !== null && typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Object]'\n}\n","/**\n * 'isBoolean' utility function\n *\n * Checks if a value is a boolean.\n *\n * @param value - the value to check\n * @param option - if 'strict', also checks JavaScript type\n *                              if TRUE or FALSE, checks only for that value\n * @return true if boolean, false if not\n */\nexport function isBoolean(value: any, option: any = null): boolean {\n  if (option === 'strict') {\n    return value === true || value === false\n  }\n  if (option === true) {\n    return value === true || value === 1 || value === 'true' || value === '1'\n  }\n  if (option === false) {\n    return value === false || value === 0 || value === 'false' || value === '0'\n  }\n  return value === true || value === 1 || value === 'true' || value === '1' ||\n    value === false || value === 0 || value === 'false' || value === '0'\n}\n","/**\n * 'isInteger' utility function\n *\n * Checks if a value is an integer.\n *\n * @param value - the value to check\n * @param strict - if truthy, also checks JavaScript tyoe\n * @return true if number, false if not\n */\nexport function isInteger(value: any, strict: any = false): boolean {\n  if (strict && typeof value !== 'number') {\n    return false\n  }\n  return !isNaN(value) && value !== value / 0 && value % 1 === 0\n}\n","/**\n * 'isNumber' utility function\n *\n * Checks if a value is a regular number, numeric string, or JavaScript Date.\n *\n * @param value - the value to check\n * @param strict - if truthy, also checks JavaScript tyoe\n * @return true if number, false if not\n */\nexport function isNumber(value: any, strict: any = false): boolean {\n  if (strict && typeof value !== 'number') {\n    return false\n  }\n  return !isNaN(value) && value !== value / 0\n}\n","/**\n * 'isString' utility function\n *\n * Checks if a value is a string.\n *\n * @param value - the value to check\n * @return true if string, false if not\n */\nexport function isString(value: any): boolean {\n  return typeof value === 'string'\n}\n","export function isDate(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Date]'\n}\n","/**\n * 'isDefined' utility function\n *\n * Checks if a variable contains a value of any type.\n * Returns true even for otherwise 'falsey' values of 0, '', and false.\n *\n * @param value - the value to check\n * @return false if undefined or null, otherwise true\n */\nexport function isDefined(value: any): boolean {\n  return value !== undefined && value !== null\n}\n","import {isArray} from './isArray'\nimport {isObject} from './isObject'\nimport {isBoolean} from './isBoolean'\nimport {isInteger} from './isInteger'\nimport {isNumber} from './isNumber'\nimport {isString} from './isString'\nimport {isDate} from './isDate'\nimport {isDefined} from './isDefined'\n/**\n * 'getType' function\n *\n * Detects the JSON Schema Type of a value.\n * By default, detects numbers and integers even if formatted as strings.\n * (So all integers are also numbers, and any number may also be a string.)\n * However, it only detects true boolean values (to detect boolean values\n * in non-boolean formats, use isBoolean() instead).\n *\n * If passed a second optional parameter of 'strict', it will only detect\n * numbers and integers if they are formatted as JavaScript numbers.\n *\n * Examples:\n * getType('10.5') = 'number'\n * getType(10.5) = 'number'\n * getType('10') = 'integer'\n * getType(10) = 'integer'\n * getType('true') = 'string'\n * getType(true) = 'boolean'\n * getType(null) = 'null'\n * getType({ }) = 'object'\n * getType([]) = 'array'\n *\n * getType('10.5', 'strict') = 'string'\n * getType(10.5, 'strict') = 'number'\n * getType('10', 'strict') = 'string'\n * getType(10, 'strict') = 'integer'\n * getType('true', 'strict') = 'string'\n * getType(true, 'strict') = 'boolean'\n *\n * @param value - value to check\n * @param strict - if truthy, also checks JavaScript tyoe\n */\n\nexport function getType(value: any, strict: any = false) {\n  if (!isDefined(value)) {\n    return 'null'\n  }\n  if (isArray(value)) {\n    return 'array'\n  }\n  if (isObject(value)) {\n    return 'object'\n  }\n  if (isBoolean(value, 'strict')) {\n    return 'boolean'\n  }\n  if (isInteger(value, strict)) {\n    return 'integer'\n  }\n  if (isNumber(value, strict)) {\n    return 'number'\n  }\n  if (isString(value) || (!strict && isDate(value))) {\n    return 'string'\n  }\n  return null\n}\n","/**\n * 'hasValue' utility function\n *\n * Checks if a variable contains a value.\n * Returs false for null, undefined, or a zero-length strng, '',\n * otherwise returns true.\n * (Stricter than 'isDefined' because it also returns false for '',\n * though it stil returns true for otherwise 'falsey' values 0 and false.)\n *\n * @param value - the value to check\n * @return false if undefined, null, or '', otherwise true\n */\nexport function hasValue(value: any): boolean {\n  return value !== undefined && value !== null && value !== ''\n}\n","import {isDefined} from './isDefined'\nimport {isArray} from './isArray'\n\n/**\n * 'inArray' function\n *\n * Searches an array for an item, or one of a list of items, and returns true\n * as soon as a match is found, or false if no match.\n *\n * If the optional third parameter allIn is set to TRUE, and the item to find\n * is an array, then the function returns true only if all elements from item\n * are found in the array list, and false if any element is not found. If the\n * item to find is not an array, setting allIn to TRUE has no effect.\n *\n * @param item - the item to search for\n * @param array - the array to search\n * @param allIn - if TRUE, all items must be in array\n * @return true if item(s) in array, false otherwise\n */\nexport function inArray<T>(\n  item: any | any[],\n  array: T[],\n  allIn = false\n): boolean {\n  if (!isDefined(item) || !isArray(array)) {\n    return false\n  }\n  return isArray(item) ?\n    item[allIn ? 'every' : 'some'](subItem => array.includes(subItem)) :\n    array.includes(item)\n}\n","import {isArray} from './isArray'\nimport {isObject} from './isObject'\n\n/**\n * 'isEmpty' utility function\n *\n * Similar to !hasValue, but also returns true for empty arrays and objects.\n *\n * @param value - the value to check\n * @return false if undefined, null, or '', otherwise true\n */\nexport function isEmpty(value: any): boolean {\n  if (isArray(value)) {\n    return !value.length\n  }\n  if (isObject(value)) {\n    return !Object.keys(value).length\n  }\n  return value === undefined || value === null || value === ''\n}\n","export function isFunction(item: any): boolean {\n  return typeof item === 'function'\n}\n","export function isMap(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Map]'\n}\n","import {Observable} from 'rxjs'\n\n/**\n * 'isObservable' function\n */\nexport function isObservable(object: any): object is Observable<any> {\n  return !!object && typeof object.subscribe === 'function'\n}\n","import {isString} from './isString'\nimport {isNumber} from './isNumber'\nimport {isBoolean} from './isBoolean'\n\n/**\n * 'isPrimitive' function\n *\n * Checks whether an input value is a JavaScript primitive type:\n * string, number, boolean, or null.\n *\n * @param value - value to check\n */\nexport function isPrimitive(value: any): boolean {\n  return (isString(value) || isNumber(value) ||\n    isBoolean(value, 'strict') || value === null)\n}\n","/**\n * 'isPromise' function\n */\nexport function isPromise(object: any): object is Promise<any> {\n  return !!object && typeof object.then === 'function'\n}\n","export function isSet(item: any): boolean {\n  return typeof item === 'object' &&\n    Object.prototype.toString.call(item) === '[object Set]'\n}\n","export function isSymbol(item: any): boolean {\n  return typeof item === 'symbol'\n}\n","import {isString} from './isString'\nimport {isDate} from './isDate'\nimport {isNumber} from './isNumber'\nimport {isInteger} from './isInteger'\nimport {isBoolean} from './isBoolean'\nimport {hasValue} from './hasValue'\nimport {PrimitiveValue, SchemaPrimitiveType} from './types'\n\n/**\n * 'isType' function\n *\n * Checks whether an input (probably string) value contains data of\n * a specified JSON Schema type\n *\n * @param value - value to check\n * @param type - type to check\n */\nexport function isType(value: PrimitiveValue, type: SchemaPrimitiveType): boolean {\n  switch (type) {\n    case 'string':\n      return isString(value) || isDate(value)\n    case 'number':\n      return isNumber(value)\n    case 'integer':\n      return isInteger(value)\n    case 'boolean':\n      return isBoolean(value)\n    case 'null':\n      return !hasValue(value)\n    default:\n      console.error(`isType error: \"${type}\" is not a recognized type.`)\n      return null\n  }\n}\n","/**\n * 'xor' utility function - exclusive or\n *\n * Returns true if exactly one of two values is truthy.\n *\n * @param value1 - first value to check\n * @param value2 - second value to check\n * @return true if exactly one input value is truthy, false if not\n */\nexport function xor(value1: any, value2: any): boolean {\n  return (!!value1 && !value2) || (!value1 && !!value2)\n}\n","import {PlainObject} from './types'\nimport {isObject} from './isObject'\nimport {isDefined} from './isDefined'\nimport {isBoolean} from './isBoolean'\nimport {getType} from './getType'\nimport {xor} from './xor'\n\n/**\n * 'mergeObjects' utility function\n *\n * Recursively Merges one or more objects into a single object with combined keys.\n * Automatically detects and ignores null and undefined inputs.\n * Also detects duplicated boolean 'not' keys and XORs their values.\n *\n * @param objects - one or more objects to merge\n * @return merged object\n */\nexport function mergeObjects(...objects: PlainObject[]): PlainObject {\n  const mergedObject: PlainObject = {}\n  for (const currentObject of objects) {\n    if (isObject(currentObject)) {\n      for (const key of Object.keys(currentObject)) {\n        const currentValue = currentObject[key]\n        const mergedValue = mergedObject[key]\n        mergedObject[key] = !isDefined(mergedValue) ? currentValue :\n          key === 'not' && isBoolean(mergedValue, 'strict') &&\n          isBoolean(currentValue, 'strict') ? xor(mergedValue, currentValue) :\n            getType(mergedValue) === 'object' && getType(currentValue) === 'object' ?\n              mergeObjects(mergedValue, currentValue) :\n              currentValue\n      }\n    }\n  }\n  return mergedObject\n}\n","import {mergeObjects} from './mergeObjects'\nimport {isEmpty} from './isEmpty'\nimport {PlainObject} from './types'\n\n/**\n * 'mergeErrors' utility function\n *\n * Merges an array of objects.\n * Used for combining the validator errors returned from 'executeValidators'\n *\n * @param arrayOfErrors - array of objects\n * @return merged object, or null if no usable input objects\n */\nexport function mergeErrors(arrayOfErrors: any): PlainObject {\n  const mergedErrors = mergeObjects(...arrayOfErrors)\n  return isEmpty(mergedErrors) ? null : mergedErrors\n}\n","import {isDefined} from './isDefined'\nimport {isString} from './isString'\nimport {isInteger} from './isInteger'\nimport {isNumber} from './isNumber'\nimport {isDate} from './isDate'\nimport {isBoolean} from './isBoolean'\nimport {inArray} from './inArray'\nimport {PrimitiveValue, SchemaPrimitiveType} from './types'\n\n/**\n * 'toJavaScriptType' function\n *\n * Converts an input (probably string) value to a JavaScript primitive type -\n * 'string', 'number', 'boolean', or 'null' - before storing in a JSON object.\n *\n * Does not coerce values (other than null), and only converts the types\n * of values that would otherwise be valid.\n *\n * If the optional third parameter 'strictIntegers' is TRUE, and the\n * JSON Schema type 'integer' is specified, it also verifies the input value\n * is an integer and, if it is, returns it as a JaveScript number.\n * If 'strictIntegers' is FALSE (or not set) the type 'integer' is treated\n * exactly the same as 'number', and allows decimals.\n *\n * Valid Examples:\n * toJavaScriptType('10',   'number' ) = 10   // '10'   is a number\n * toJavaScriptType('10',   'integer') = 10   // '10'   is also an integer\n * toJavaScriptType( 10,    'integer') = 10   //  10    is still an integer\n * toJavaScriptType( 10,    'string' ) = '10' //  10    can be made into a string\n * toJavaScriptType('10.5', 'number' ) = 10.5 // '10.5' is a number\n *\n * Invalid Examples:\n * toJavaScriptType('10.5', 'integer') = null // '10.5' is not an integer\n * toJavaScriptType( 10.5,  'integer') = null //  10.5  is still not an integer\n *\n * @param value to convert\n * @param types - types to convert to\n * @param strictIntegers - if FALSE, treat integers as numbers\n */\nexport function toJavaScriptType(\n  value: PrimitiveValue,\n  types: SchemaPrimitiveType | SchemaPrimitiveType[],\n  strictIntegers = true\n): PrimitiveValue {\n  if (!isDefined(value)) {\n    return null\n  }\n  types = typeof types === 'string' ? [types] as SchemaPrimitiveType[] : types\n\n  if (strictIntegers && inArray<SchemaPrimitiveType>('integer', types)) {\n    if (isInteger(value, 'strict')) {\n      return value\n    }\n    if (isInteger(value)) {\n      return parseInt(value as string, 10)\n    }\n  }\n  if (inArray('number', types) || (!strictIntegers && inArray('integer', types))) {\n    if (isNumber(value, 'strict')) {\n      return value\n    }\n    if (isNumber(value)) {\n      return parseFloat(value as string)\n    }\n  }\n  if (inArray('string', types)) {\n    if (isString(value)) {\n      return value\n    }\n    // If value is a date, and types includes 'string',\n    // convert the date to a string\n    if (isDate(value)) {\n      return (value as any).toISOString().slice(0, 10)\n    }\n    if (isNumber(value)) {\n      return value.toString()\n    }\n  }\n  // If value is a date, and types includes 'integer' or 'number',\n  // but not 'string', convert the date to a number\n  if (isDate(value) && (inArray('integer', types) || inArray('number', types))) {\n    return (value as any).getTime()\n  }\n  if (inArray('boolean', types)) {\n    if (isBoolean(value, true)) {\n      return true\n    }\n    if (isBoolean(value, false)) {\n      return false\n    }\n  }\n  return null\n}\n","import {isObservable, Observable} from 'rxjs'\nimport {fromPromise} from 'rxjs-compat/observable/fromPromise'\nimport {isPromise} from './isPromise'\n\n/**\n * 'toObservable' function\n *\n */\nexport function toObservable(object: object): Observable<any> {\n  const observable = isPromise(object) ? fromPromise(object) : object\n  if (isObservable(observable)) {\n    return observable\n  }\n  console.error('toObservable error: Expected validator to return Promise or Observable.')\n  return new Observable()\n}\n","import {isPromise} from './isPromise'\n\n/**\n * 'toPromise' function\n */\nexport function toPromise(object: object): Promise<any> {\n  return isPromise(object) ? object : toPromise.call(object)\n}\n","import {PrimitiveValue, SchemaPrimitiveType} from './types'\nimport {isArray} from './isArray'\nimport {toJavaScriptType} from './toJavascriptType'\nimport {isNumber} from './isNumber'\nimport {isString} from './isString'\nimport {isBoolean} from './isBoolean'\nimport {hasValue} from './hasValue'\n\n/**\n * 'toSchemaType' function\n *\n * Converts an input (probably string) value to the \"best\" JavaScript\n * equivalent available from an allowed list of JSON Schema types, which may\n * contain 'string', 'number', 'integer', 'boolean', and/or 'null'.\n * If necessary, it does progressively aggressive type coersion.\n * It will not return null unless null is in the list of allowed types.\n *\n * Number conversion examples:\n * toSchemaType('10', ['number','integer','string']) = 10 // integer\n * toSchemaType('10', ['number','string']) = 10 // number\n * toSchemaType('10', ['string']) = '10' // string\n * toSchemaType('10.5', ['number','integer','string']) = 10.5 // number\n * toSchemaType('10.5', ['integer','string']) = '10.5' // string\n * toSchemaType('10.5', ['integer']) = 10 // integer\n * toSchemaType(10.5, ['null','boolean','string']) = '10.5' // string\n * toSchemaType(10.5, ['null','boolean']) = true // boolean\n *\n * String conversion examples:\n * toSchemaType('1.5x', ['boolean','number','integer','string']) = '1.5x' // string\n * toSchemaType('1.5x', ['boolean','number','integer']) = '1.5' // number\n * toSchemaType('1.5x', ['boolean','integer']) = '1' // integer\n * toSchemaType('1.5x', ['boolean']) = true // boolean\n * toSchemaType('xyz', ['number','integer','boolean','null']) = true // boolean\n * toSchemaType('xyz', ['number','integer','null']) = null // null\n * toSchemaType('xyz', ['number','integer']) = 0 // number\n *\n * Boolean conversion examples:\n * toSchemaType('1', ['integer','number','string','boolean']) = 1 // integer\n * toSchemaType('1', ['number','string','boolean']) = 1 // number\n * toSchemaType('1', ['string','boolean']) = '1' // string\n * toSchemaType('1', ['boolean']) = true // boolean\n * toSchemaType('true', ['number','string','boolean']) = 'true' // string\n * toSchemaType('true', ['boolean']) = true // boolean\n * toSchemaType('true', ['number']) = 0 // number\n * toSchemaType(true, ['number','string','boolean']) = true // boolean\n * toSchemaType(true, ['number','string']) = 'true' // string\n * toSchemaType(true, ['number']) = 1 // number\n *\n * @param value - value to convert\n * @param type - allowed types to convert to\n */\nexport function toSchemaType(\n  value: PrimitiveValue,\n  type: SchemaPrimitiveType | SchemaPrimitiveType[]\n) {\n  const types = isArray(type) ? type : [type]\n\n  if (types.includes('null') && !hasValue(value)) {\n    return null\n  }\n  if (types.includes('boolean') && !isBoolean(value, 'strict')) {\n    return value\n  }\n  if (types.includes('integer')) {\n    const testValue = toJavaScriptType(value, 'integer')\n    if (testValue !== null) {\n      return +testValue\n    }\n  }\n  if (types.includes('number')) {\n    const testValue = toJavaScriptType(value, 'number')\n    if (testValue !== null) {\n      return +testValue\n    }\n  }\n  if (\n    (isString(value) || isNumber(value, 'strict')) &&\n    types.includes('string')\n  ) { // Convert number to string\n    return toJavaScriptType(value, 'string')\n  }\n  if (types.includes('boolean') && isBoolean(value)) {\n    return toJavaScriptType(value, 'boolean')\n  }\n  if (types.includes('string')) { // Convert null & boolean to string\n    if (value === null) {\n      return ''\n    }\n    const testValue = toJavaScriptType(value, 'string')\n    if (testValue !== null) {\n      return testValue\n    }\n  }\n  if (\n    types.includes('number') ||\n    types.includes('integer')\n  ) {\n    if (value === true) {\n      return 1\n    } // Convert boolean & null to number\n    if (value === false || value === null || value === '') {\n      return 0\n    }\n  }\n  if (types.includes('number')) { // Convert mixed string to number\n    const testValue = parseFloat(value as string)\n    if (!!testValue) {\n      return testValue\n    }\n  }\n  if (types.includes('integer')) { // Convert string or number to integer\n    const testValue = parseInt(value as string, 10)\n    if (!!testValue) {\n      return testValue\n    }\n  }\n  if (types.includes('boolean')) { // Convert anything to boolean\n    return !!value\n  }\n  if ((\n    types.includes('number') ||\n    types.includes('integer')\n  ) && !types.includes('null')\n  ) {\n    return 0 // If null not allowed, return 0 for non-convertable values\n  }\n}\n","import {isArray, isSet, isString} from '../validator'\n\n/**\n * 'addClasses' function\n *\n * Merges two space-delimited lists of CSS classes and removes duplicates.\n */\nexport function addClasses(\n  oldClasses: string | string[] | Set<string>,\n  newClasses: string | string[] | Set<string>\n): string | string[] | Set<string> {\n  const badType = i => !isSet(i) && !isArray(i) && !isString(i)\n  if (badType(newClasses)) {\n    return oldClasses\n  }\n  if (badType(oldClasses)) {\n    oldClasses = ''\n  }\n  const toSet = i => isSet(i) ? i : isArray(i) ? new Set(i) : new Set(i.split(' '))\n  const combinedSet: Set<any> = toSet(oldClasses)\n  const newSet: Set<any> = toSet(newClasses)\n  newSet.forEach(c => combinedSet.add(c))\n  if (isSet(oldClasses)) {\n    return combinedSet\n  }\n  if (isArray(oldClasses)) {\n    return Array.from(combinedSet)\n  }\n  return Array.from(combinedSet).join(' ')\n}\n","/**\n * 'commonItems' function\n *\n * Accepts any number of strings or arrays of string values,\n * and returns a single array containing only values present in all inputs.\n */\nexport function commonItems(...arrays: string[]): string[] {\n  let returnItems = null\n  for (const value of arrays) {\n    const array = typeof value === 'string' ? [value] : value\n\n    returnItems = returnItems === null ? [...array] :\n      returnItems.filter(item => array.includes(item))\n    if (!returnItems.length) {\n      return []\n    }\n  }\n  return returnItems\n}\n","import {isArray, isMap, isObject, isSet} from '../validator'\n\n/**\n * 'copy' function\n *\n * Makes a shallow copy of a JavaScript object, array, Map, or Set.\n * If passed a JavaScript primitive value (string, number, boolean, or null),\n * it returns the value.\n *\n * @param object - The object to copy\n * @param errors - Show errors?\n * @return The copied object\n */\nexport function copy(\n  object: any,\n  errors: boolean = false\n) {\n  if (typeof object !== 'object' || object === null) {\n    return object\n  }\n  if (isMap(object)) {\n    return new Map(object)\n  }\n  if (isSet(object)) {\n    return new Set(object)\n  }\n  if (isArray(object)) {\n    return [...object]\n  }\n  if (isObject(object)) {\n    return {...object}\n  }\n  if (errors) {\n    console.error('copy error: Object to copy must be a JavaScript object or value.')\n  }\n  return object\n}\n","import {isArray, isString} from '../validator'\n\n/**\n * 'toTitleCase' function\n *\n * Intelligently converts an input string to Title Case.\n *\n * Accepts an optional second parameter with a list of additional\n * words and abbreviations to force into a particular case.\n *\n * This function is built on prior work by John Gruber and David Gouch:\n * http://daringfireball.net/2008/08/title_case_update\n * https://github.com/gouch/to-title-case\n */\nexport function toTitleCase(input: string, forceWords?: string | string[]): string {\n  if (!isString(input)) {\n    return input\n  }\n  let forceArray: string[] = ['a', 'an', 'and', 'as', 'at', 'but', 'by', 'en',\n    'for', 'if', 'in', 'nor', 'of', 'on', 'or', 'per', 'the', 'to', 'v', 'v.',\n    'vs', 'vs.', 'via']\n  if (isString(forceWords)) {\n    forceWords = (forceWords as string).split('|')\n  }\n  if (isArray(forceWords)) {\n    forceArray = forceArray.concat(forceWords)\n  }\n  const forceArrayLower: string[] = forceArray.map(w => w.toLowerCase())\n  const noInitialCase: boolean =\n    input === input.toUpperCase() || input === input.toLowerCase()\n  let prevLastChar = ''\n  input = input.trim()\n  return input.replace(/[A-Za-z0-9\\u00C0-\\u00FF]+[^\\s-]*/g, (word, idx) => {\n    if (!noInitialCase && word.slice(1).search(/[A-Z]|\\../) !== -1) {\n      return word\n    } else {\n      let newWord: string\n      const forceWord: string =\n        forceArray[forceArrayLower.indexOf(word.toLowerCase())]\n      if (!forceWord) {\n        if (noInitialCase) {\n          if (word.slice(1).search(/\\../) !== -1) {\n            newWord = word.toLowerCase()\n          } else {\n            newWord = word[0].toUpperCase() + word.slice(1).toLowerCase()\n          }\n        } else {\n          newWord = word[0].toUpperCase() + word.slice(1)\n        }\n      } else if (\n        forceWord === forceWord.toLowerCase() && (\n          idx === 0 || idx + word.length === input.length ||\n          prevLastChar === ':' || input[idx - 1].search(/[^\\s-]/) !== -1 ||\n          (input[idx - 1] !== '-' && input[idx + word.length] === '-')\n        )\n      ) {\n        newWord = forceWord[0].toUpperCase() + forceWord.slice(1)\n      } else {\n        newWord = forceWord\n      }\n      prevLastChar = word.slice(-1)\n      return newWord\n    }\n  })\n}\n","import {toTitleCase} from './toTitleCase'\n\n/**\n * 'fixTitle' function\n */\nexport function fixTitle(name: string): string {\n  return name && toTitleCase(name.replace(/([a-z])([A-Z])/g, '$1 $2').replace(/_/g, ' '))\n}\n","import {isArray, isEmpty, isObject} from '../validator'\n\n/**\n * 'forEach' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator function on each item.\n *\n * The iterator function is called with four values:\n * 1. The current item's value\n * 2. The current item's key\n * 3. The parent object, which contains the current item\n * 4. The root object\n *\n * Setting the optional third parameter to 'top-down' or 'bottom-up' will cause\n * it to also recursively iterate over items in sub-objects or sub-arrays in the\n * specified direction.\n *\n * @param object - The object or array to iterate over\n * @param fn - the iterator function to call on each item\n * @param recurse -\n * @param rootObject -\n * @param errors - Show errors?\n */\nexport function forEach(\n  object: any | any[],\n  fn: (v: any, k?: string | number, c?: any, rc?: any) => any,\n  recurse: boolean | string = false,\n  rootObject: any = object,\n  errors = false\n): void {\n  if (isEmpty(object)) {\n    return\n  }\n  if ((isObject(object) || isArray(object)) && typeof fn === 'function') {\n    for (const key of Object.keys(object)) {\n      const value = object[key]\n      if (recurse === 'bottom-up' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject)\n      }\n      fn(value, key, object, rootObject)\n      if (recurse === 'top-down' && (isObject(value) || isArray(value))) {\n        forEach(value, fn, recurse, rootObject)\n      }\n    }\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEach error: Iterator must be a function.')\n      console.error('function', fn)\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEach error: Input object must be an object or array.')\n      console.error('object', object)\n    }\n  }\n}\n","import {hasValue, isArray, isObject} from '../validator'\n\n/**\n * 'forEachCopy' function\n *\n * Iterates over all items in the first level of an object or array\n * and calls an iterator function on each item. Returns a new object or array\n * with the same keys or indexes as the original, and values set to the results\n * of the iterator function.\n *\n * Does NOT recursively iterate over items in sub-objects or sub-arrays.\n *\n * @param object - The object or array to iterate over\n * @param fn - The iterator function to call on each item\n * @param errors - Show errors?\n * @return The resulting object or array\n */\nexport function forEachCopy(\n  object: any | any[],\n  fn: (v: any, k?: string | number, o?: any, p?: string) => any,\n  errors = false\n): any | any[] {\n  if (!hasValue(object)) {\n    return\n  }\n  if ((isObject(object) || isArray(object)) && typeof object !== 'function') {\n    const newObject: any = isArray(object) ? [] : {}\n    for (const key of Object.keys(object)) {\n      newObject[key] = fn(object[key], key, object)\n    }\n    return newObject\n  }\n  if (errors) {\n    if (typeof fn !== 'function') {\n      console.error('forEachCopy error: Iterator must be a function.')\n      console.error('function', fn)\n    }\n    if (!isObject(object) && !isArray(object)) {\n      console.error('forEachCopy error: Input object must be an object or array.')\n      console.error('object', object)\n    }\n  }\n}\n","import {isArray, isMap, isObject, isSet} from '../validator'\n\n/**\n * 'hasOwn' utility function\n *\n * Checks whether an object or array has a particular property.\n *\n * @param object - the object to check\n * @param property - the property to look for\n * @return true if object has property, false if not\n */\nexport function hasOwn(object: any, property: string): boolean {\n  if (!object || !['number', 'string', 'symbol'].includes(typeof property) ||\n    (!isObject(object) && !isArray(object) && !isMap(object) && !isSet(object))\n  ) {\n    return false\n  }\n  if (isMap(object) || isSet(object)) {\n    return object.has(property)\n  }\n  if (typeof property === 'number') {\n    if (isArray(object)) {\n      return object[property as number]\n    }\n    property = property + ''\n  }\n  return object.hasOwnProperty(property)\n}\n","import {inArray, isDefined, isObject, PlainObject} from '../validator'\n\n/**\n * 'mergeFilteredObject' utility function\n *\n * Shallowly merges two objects, setting key and values from source object\n * in target object, excluding specified keys.\n *\n * Optionally, it can also use functions to transform the key names and/or\n * the values of the merging object.\n *\n * @param targetObject - Target object to add keys and values to\n * @param sourceObject - Source object to copy keys and values from\n * @param excludeKeys - Array of keys to exclude\n * @param keyFn - Function to apply to keys\n * @param valFn - Function to apply to values\n * @return Returns targetObject\n */\nexport function mergeFilteredObject(\n  targetObject: PlainObject,\n  sourceObject: PlainObject,\n  excludeKeys:string[] = [],\n  keyFn = (key: string): string => key,\n  valFn = (val: any): any => val\n): PlainObject {\n  if (!isObject(sourceObject)) {\n    return targetObject\n  }\n  if (!isObject(targetObject)) {\n    targetObject = {}\n  }\n  for (const key of Object.keys(sourceObject)) {\n    if (!inArray(key, excludeKeys) && isDefined(sourceObject[key])) {\n      targetObject[keyFn(key)] = valFn(sourceObject[key])\n    }\n  }\n  return targetObject\n}\n","/**\n * 'uniqueItems' function\n *\n * Accepts any number of string value inputs,\n * and returns an array of all input vaues, excluding duplicates.\n */\nexport function uniqueItems(...items: string[]): string[] {\n  const returnItems = []\n  for (const item of items) {\n    if (!returnItems.includes(item)) {\n      returnItems.push(item)\n    }\n  }\n  return returnItems\n}\n","import {Injectable} from '@angular/core'\n\nimport {\n  isDefined, isEmpty, isObject, isArray, isMap, isNumber, isString\n} from './validator'\nimport {hasOwn, copy} from './utility'\nimport {FormGroup} from '@angular/forms'\n\n/**\n * 'JsonPointer' class\n *\n * Some utilities for using JSON Pointers with JSON objects\n * https://tools.ietf.org/html/rfc6901\n *\n * get, getCopy, getFirst, set, setCopy, insert, insertCopy, remove, has, dict,\n * forEachDeep, forEachDeepCopy, escape, unescape, parse, compile, toKey,\n * isJsonPointer, isSubPointer, toIndexedPointer, toGenericPointer,\n * toControlPointer, toSchemaPointer, toDataPointer, parseObjectPath\n *\n * Some functions based on manuelstofer's json-pointer utilities\n * https://github.com/manuelstofer/json-pointer\n */\nexport type Pointer = string | string[]\n\n// @dynamic\n@Injectable()\nexport class JsonPointer {\n\n  /**\n   * 'get' function\n   *\n   * Uses a JSON Pointer to retrieve a value from an object.\n   *\n   * @param object - Object to get value from\n   * @param pointer - JSON Pointer (string or array)\n   * @param startSlice - Zero-based index of first Pointer key to use\n   * @param endSlice - Zero-based index of last Pointer key to use\n   * @param getBoolean - Return only true or false?\n   * @param errors - Show error if not found?\n   * @return Located value (or true or false if getBoolean = true)\n   */\n  static get(\n    object,\n    pointer: Pointer,\n    startSlice: number = 0,\n    endSlice: number = null,\n    getBoolean: boolean = false,\n    errors: boolean = false\n  ) {\n    if (object === null) {\n      return getBoolean ? false : undefined\n    }\n    let keyArray: any[] = this.parse(pointer, errors)\n    if (typeof object === 'object' && keyArray !== null) {\n      let subObject = object\n      if (startSlice >= keyArray.length || endSlice <= -keyArray.length) {\n        return object\n      }\n      if (startSlice <= -keyArray.length) {\n        startSlice = 0\n      }\n      if (!isDefined(endSlice) || endSlice >= keyArray.length) {\n        endSlice = keyArray.length\n      }\n      keyArray = keyArray.slice(startSlice, endSlice)\n      for (let key of keyArray) {\n        if (key === '-' && isArray(subObject) && subObject.length) {\n          key = subObject.length - 1\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key)\n        } else if (typeof subObject === 'object' && subObject !== null &&\n          hasOwn(subObject, key)\n        ) {\n          subObject = subObject[key]\n        } else {\n          if (errors) {\n            console.error(`get error: \"${key}\" key not found in object.`)\n            console.error(pointer)\n            console.error(object)\n          }\n          return getBoolean ? false : undefined\n        }\n      }\n      return getBoolean ? true : subObject\n    }\n    if (errors && keyArray === null) {\n      console.error(`get error: Invalid JSON Pointer: ${pointer}`)\n    }\n    if (errors && typeof object !== 'object') {\n      console.error('get error: Invalid object:')\n      console.error(object)\n    }\n    return getBoolean ? false : undefined\n  }\n\n  /**\n   * 'getCopy' function\n   *\n   * Uses a JSON Pointer to deeply clone a value from an object.\n   *\n   * @param object - Object to get value from\n   * @param pointer - JSON Pointer (string or array)\n   * @param startSlice - Zero-based index of first Pointer key to use\n   * @param endSlice - Zero-based index of last Pointer key to use\n   * @param getBoolean - Return only true or false?\n   * @param errors - Show error if not found?\n   * @return Located value (or true or false if getBoolean = true)\n   */\n  static getCopy(\n    object,\n    pointer: Pointer,\n    startSlice: number = 0,\n    endSlice: number = null,\n    getBoolean: boolean = false,\n    errors: boolean = false\n  ) {\n    const objectToCopy =\n      this.get(object, pointer, startSlice, endSlice, getBoolean, errors)\n    return this.forEachDeepCopy(objectToCopy)\n  }\n\n  /**\n   * 'getFirst' function\n   *\n   * Takes an array of JSON Pointers and objects,\n   * checks each object for a value specified by the pointer,\n   * and returns the first value found.\n   *\n   * @param items - Array of objects and pointers to check\n   * @param defaultValue - Value to return if nothing found\n   * @param getCopy - Return a copy instead?\n   * @return First value found\n   */\n  static getFirst(\n    items: Array<object | Pointer>,\n    defaultValue: any = null,\n    getCopy = false\n  ) {\n    if (isEmpty(items)) {\n      return\n    }\n    if (isArray(items)) {\n      for (const item of items) {\n        if (isEmpty(item)) {\n          continue\n        }\n        if (isArray(item) && (item as string[]).length >= 2) {\n          if (isEmpty(item[0]) || isEmpty(item[1])) {\n            continue\n          }\n          const value = getCopy ?\n            this.getCopy(item[0], item[1]) :\n            this.get(item[0], item[1])\n          if (value) {\n            return value\n          }\n          continue\n        }\n        console.error('getFirst error: Input not in correct format.\\n' +\n          'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]')\n        return\n      }\n      return defaultValue\n    }\n    if (isMap(items)) {\n      for (const [object, pointer] of (items as any)) {\n        if (object === null || !this.isJsonPointer(pointer)) {\n          continue\n        }\n        const value = getCopy ?\n          this.getCopy(object, pointer) :\n          this.get(object, pointer)\n        if (value) {\n          return value\n        }\n      }\n      return defaultValue\n    }\n    console.error('getFirst error: Input not in correct format.\\n' +\n      'Should be: [ [ object1, pointer1 ], [ object 2, pointer2 ], etc... ]')\n    return defaultValue\n  }\n\n  /**\n   * 'getFirstCopy' function\n   *\n   * Similar to getFirst, but always returns a copy.\n   *\n   * @param items - Array of objects and pointers to check\n   * @param defaultValue - Value to return if nothing found\n   * @return Copy of first value found\n   */\n  static getFirstCopy(\n    items: Array<object | Pointer>,\n    defaultValue: any = null\n  ) {\n    return this.getFirst(items, defaultValue, true)\n  }\n\n  /**\n   * 'set' function\n   *\n   * Uses a JSON Pointer to set a value on an object.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing\n   * value (if any) at that location.\n   *\n   * So set([1, 2, 3], '/1', 4) => [1, 4, 3]\n   * and\n   * So set([1, 2, 3], '/1', 4, true) => [1, 4, 2, 3]\n   *\n   * @param object - The object to set value in\n   * @param pointer - The JSON Pointer (string or array)\n   * @param value - The new value to set\n   * @param insert - insert value?\n   * @return The original object, modified with the set value\n   */\n  static set(\n    object: object,\n    pointer: Pointer,\n    value: any,\n    insert = false\n  ) {\n    const keyArray = this.parse(pointer)\n    if (keyArray !== null && keyArray.length) {\n      let subObject: any = object\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i]\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject = subObject.get(key)\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {}\n          }\n          subObject = subObject[key]\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1]\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value)\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value)\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value)\n      } else {\n        subObject[lastKey] = value\n      }\n      return object\n    }\n    console.error(`set error: Invalid JSON Pointer: ${pointer}`)\n    return object\n  }\n\n  /**\n   * 'setCopy' function\n   *\n   * Copies an object and uses a JSON Pointer to set a value on the copy.\n   * Also creates any missing sub objects or arrays to contain that value.\n   *\n   * If the optional fourth parameter is TRUE and the inner-most container\n   * is an array, the function will insert the value as a new item at the\n   * specified location in the array, rather than overwriting the existing value.\n   *\n   * @param object - The object to copy and set value in\n   * @param pointer - The JSON Pointer (string or array)\n   * @param value - The value to set\n   * @param insert - insert value?\n   * @return The new object with the set value\n   */\n  static setCopy(\n    object: object,\n    pointer: Pointer,\n    value: any,\n    insert = false\n  ) {\n    const keyArray = this.parse(pointer)\n    if (keyArray !== null) {\n      const newObject = copy(object)\n      let subObject = newObject\n      for (let i = 0; i < keyArray.length - 1; ++i) {\n        let key = keyArray[i]\n        if (key === '-' && isArray(subObject)) {\n          key = subObject.length\n        }\n        if (isMap(subObject) && subObject.has(key)) {\n          subObject.set(key, copy(subObject.get(key)))\n          subObject = subObject.get(key)\n        } else {\n          if (!hasOwn(subObject, key)) {\n            subObject[key] = (keyArray[i + 1].match(/^(\\d+|-)$/)) ? [] : {}\n          }\n          subObject[key] = copy(subObject[key])\n          subObject = subObject[key]\n        }\n      }\n      const lastKey = keyArray[keyArray.length - 1]\n      if (isArray(subObject) && lastKey === '-') {\n        subObject.push(value)\n      } else if (insert && isArray(subObject) && !isNaN(+lastKey)) {\n        subObject.splice(lastKey, 0, value)\n      } else if (isMap(subObject)) {\n        subObject.set(lastKey, value)\n      } else {\n        subObject[lastKey] = value\n      }\n      return newObject\n    }\n    console.error(`setCopy error: Invalid JSON Pointer: ${pointer}`)\n    return object\n  }\n\n  /**\n   * 'insert' function\n   *\n   * Calls 'set' with insert = TRUE\n   *\n   * @param object - object to insert value in\n   * @param pointer - JSON Pointer (string or array)\n   * @param value - value to insert\n   */\n  static insert(\n    object: object,\n    pointer: Pointer,\n    value: any\n  ) {\n    const updatedObject = this.set(object, pointer, value, true)\n    return updatedObject\n  }\n\n  /**\n   * 'insertCopy' function\n   *\n   * Calls 'setCopy' with insert = TRUE\n   *\n   * @param object - object to insert value in\n   * @param pointer - JSON Pointer (string or array)\n   * @param value - value to insert\n   */\n  static insertCopy(\n    object: object,\n    pointer: Pointer,\n    value: any\n  ) {\n    const updatedObject = this.setCopy(object, pointer, value, true)\n    return updatedObject\n  }\n\n  /**\n   * 'remove' function\n   *\n   * Uses a JSON Pointer to remove a key and its attribute from an object\n   *\n   * @param object - object to delete attribute from\n   * @param pointer - JSON Pointer (string or array)\n   */\n  static remove(\n    object: object,\n    pointer: Pointer\n  ) {\n    const keyArray = this.parse(pointer)\n    if (keyArray !== null && keyArray.length) {\n      const lastKey = keyArray.pop()\n      const parentObject = this.get(object, keyArray)\n      if (Array.isArray(parentObject)) {\n        const lastIndex = (lastKey === '-') ? parentObject.length - 1 : parseInt(lastKey, 10)\n\n        parentObject.splice(lastIndex, 1)\n      } else if (isObject(parentObject)) {\n        delete parentObject[lastKey]\n      }\n      return object\n    }\n    console.error(`remove error: Invalid JSON Pointer: ${pointer}`)\n    return object\n  }\n\n  /**\n   * 'has' function\n   *\n   * Tests if an object has a value at the location specified by a JSON Pointer\n   *\n   * @param object - object to chek for value\n   * @param pointer - JSON Pointer (string or array)\n   */\n  static has(\n    object: object,\n    pointer: Pointer\n  ): boolean {\n    return this.get(object, pointer, 0, null, true)\n  }\n\n  /**\n   * 'dict' function\n   *\n   * Returns a (pointer -> value) dictionary for an object\n   *\n   * @param object - The object to create a dictionary from\n   * @return The resulting dictionary object\n   */\n  static dict(object: object) {\n    const results: any = {}\n    this.forEachDeep(object, (value, pointer) => {\n      if (typeof value !== 'object') {\n        results[pointer] = value\n      }\n    })\n    return results\n  }\n\n  /**\n   * 'forEachDeep' function\n   *\n   * Iterates over own enumerable properties of an object or items in an array\n   * and invokes an iteratee function for each key/value or index/value pair.\n   * By default, iterates over items within objects and arrays after calling\n   * the iteratee function on the containing object or array itself.\n   *\n   * The iteratee is invoked with three arguments: (value, pointer, rootObject),\n   * where pointer is a JSON pointer indicating the location of the current\n   * value within the root object, and rootObject is the root object initially\n   * submitted to th function.\n   *\n   * If a third optional parameter 'bottomUp' is set to TRUE, the iterator\n   * function will be called on sub-objects and arrays after being\n   * called on their contents, rather than before, which is the default.\n   *\n   * This function can also optionally be called directly on a sub-object by\n   * including optional 4th and 5th parameters to specify the initial\n   * root object and pointer.\n   *\n   * @param object - the initial object or array\n   * @param fn - iteratee function\n   * @param bottomUp - optional, set to TRUE to reverse direction\n   * @param pointer - optional, JSON Pointer to object within rootObject\n   * @param rootObject - optional, root object or array\n   * @return The modified object\n   */\n  static forEachDeep(\n    object,\n    fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp = false,\n    pointer = '',\n    rootObject = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeep error: Iterator is not a function:`, fn)\n      return\n    }\n    if (!bottomUp) {\n      fn(object, pointer, rootObject)\n    }\n    if (isObject(object) || isArray(object)) {\n      for (const key of Object.keys(object)) {\n        const newPointer = pointer + '/' + this.escape(key)\n        this.forEachDeep(object[key], fn, bottomUp, newPointer, rootObject)\n      }\n    }\n    if (bottomUp) {\n      fn(object, pointer, rootObject)\n    }\n  }\n\n  /**\n   * 'forEachDeepCopy' function\n   *\n   * Similar to forEachDeep, but returns a copy of the original object, with\n   * the same keys and indexes, but with values replaced with the result of\n   * the iteratee function.\n   *\n   * @param object - the initial object or array\n   * @param fn - iteratee function\n   * @param bottomUp - optional, set to TRUE to reverse direction\n   * @param pointer - optional, JSON Pointer to object within rootObject\n   * @param rootObject - optional, root object or array\n   * @return The copied object\n   */\n  static forEachDeepCopy(\n    object: object,\n    fn: (v: any, p?: string, o?: any) => any = (v) => v,\n    bottomUp: boolean = false,\n    pointer: string = '',\n    rootObject: object = object\n  ) {\n    if (typeof fn !== 'function') {\n      console.error(`forEachDeepCopy error: Iterator is not a function:`, fn)\n      return null\n    }\n    if (isObject(object) || Array.isArray(object)) {\n      let newObject = Array.isArray(object) ? [...object] : {...object}\n      if (!bottomUp) {\n        newObject = fn(newObject, pointer, rootObject)\n      }\n      for (const key of Object.keys(newObject)) {\n        const newPointer = pointer + '/' + this.escape(key)\n        newObject[key] = this.forEachDeepCopy(\n          newObject[key], fn, bottomUp, newPointer, rootObject\n        )\n      }\n      if (bottomUp) {\n        newObject = fn(newObject, pointer, rootObject)\n      }\n      return newObject\n    } else {\n      return fn(object, pointer, rootObject)\n    }\n  }\n\n  /**\n   * 'escape' function\n   *\n   * Escapes a string reference key\n   *\n   * @param key - string key to escape\n   * @return escaped key\n   */\n  static escape(key: string): string {\n    return key.toString().replace(/~/g, '~0').replace(/\\//g, '~1')\n  }\n\n  /**\n   * 'unescape' function\n   *\n   * Unescapes a string reference key\n   *\n   * @param key - string key to unescape\n   * @return unescaped key\n   */\n  static unescape(key: string) {\n    return key.toString().replace(/~1/g, '/').replace(/~0/g, '~')\n  }\n\n  /**\n   * 'parse' function\n   *\n   * Converts a string JSON Pointer into a array of keys\n   * (if input is already an an array of keys, it is returned unchanged)\n   *\n   * @param pointer - JSON Pointer (string or array)\n   * @param errors - Show error if invalid pointer?\n   * @return JSON Pointer array of keys\n   */\n  static parse(\n    pointer: Pointer,\n    errors: boolean = false\n  ): string[] {\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) {\n        console.error(`parse error: Invalid JSON Pointer: ${pointer}`)\n      }\n      return null\n    }\n    if (isArray(pointer)) {\n      return pointer as string[]\n    }\n    if (typeof pointer === 'string') {\n      if (pointer[0] === '#') {\n        pointer = pointer.slice(1)\n      }\n      if (pointer === '' || pointer === '/') {\n        return []\n      }\n      return pointer.slice(1).split('/').map(this.unescape)\n    }\n  }\n\n  /**\n   * 'compile' function\n   *\n   * Converts an array of keys into a JSON Pointer string\n   * (if input is already a string, it is normalized and returned)\n   *\n   * The optional second parameter is a default which will replace any empty keys.\n   *\n   * @param pointer - JSON Pointer (string or array)\n   * @param defaultValue - Default value\n   * @param errors - Show error if invalid pointer?\n   * @return JSON Pointer string\n   */\n  static compile(\n    pointer: Pointer,\n    defaultValue: string | number = '',\n    errors: boolean = false\n  ): string {\n    if (pointer === '#') {\n      return ''\n    }\n    if (!this.isJsonPointer(pointer)) {\n      if (errors) {\n        console.error(`compile error: Invalid JSON Pointer: ${pointer}`)\n      }\n      return null\n    }\n    if (Array.isArray(pointer)) {\n      if (pointer.length === 0) {\n        return ''\n      }\n      return '/' + pointer.map(\n        key => key === '' ? defaultValue : this.escape(key)\n      ).join('/')\n    }\n    if (typeof pointer === 'string') {\n      if (pointer[0] === '#') {\n        pointer = pointer.slice(1)\n      }\n      return pointer\n    }\n  }\n\n  /**\n   * 'toKey' function\n   *\n   * Extracts name of the final key from a JSON Pointer.\n   *\n   * @param pointer - JSON Pointer (string or array)\n   * @param errors - Show error if invalid pointer?\n   * @return the extracted key\n   */\n  static toKey(\n    pointer: Pointer,\n    errors: boolean = false\n  ): string {\n    const keyArray = this.parse(pointer, errors)\n    if (keyArray === null) {\n      return null\n    }\n    if (!keyArray.length) {\n      return ''\n    }\n    return keyArray[keyArray.length - 1]\n  }\n\n  /**\n   * 'isJsonPointer' function\n   *\n   * Checks a string or array value to determine if it is a valid JSON Pointer.\n   * Returns true if a string is empty, or starts with '/' or '#/'.\n   * Returns true if an array contains only string values.\n   *\n   * @param value - value to check\n   * @return true if value is a valid JSON Pointer, otherwise false\n   */\n  static isJsonPointer(value: any): boolean {\n    if (isArray(value)) {\n      return value.every(key => typeof key === 'string')\n    } else if (isString(value)) {\n      if (value === '' || value === '#') {\n        return true\n      }\n      if (value[0] === '/' || value.slice(0, 2) === '#/') {\n        return !/(~[^01]|~$)/g.test(value)\n      }\n    }\n    return false\n  }\n\n  /**\n   * 'isSubPointer' function\n   *\n   * Checks whether one JSON Pointer is a subset of another.\n   *\n   * @param shortPointer - potential subset JSON Pointer\n   * @param longPointer - potential superset JSON Pointer\n   * @param trueIfMatching - return true if pointers match?\n   * @param errors - Show error if invalid pointer?\n   * @return true if shortPointer is a subset of longPointer, false if not\n   */\n  static isSubPointer(\n    shortPointer: Pointer,\n    longPointer: Pointer,\n    trueIfMatching: boolean = false,\n    errors: boolean = false\n  ): boolean {\n    if (!this.isJsonPointer(shortPointer) || !this.isJsonPointer(longPointer)) {\n      if (errors) {\n        let invalid = ''\n        if (!this.isJsonPointer(shortPointer)) {\n          invalid += ` 1: ${shortPointer}`\n        }\n        if (!this.isJsonPointer(longPointer)) {\n          invalid += ` 2: ${longPointer}`\n        }\n        console.error(`isSubPointer error: Invalid JSON Pointer ${invalid}`)\n      }\n      return\n    }\n    shortPointer = this.compile(shortPointer, '', errors)\n    longPointer = this.compile(longPointer, '', errors)\n    return shortPointer === longPointer ? trueIfMatching :\n      `${shortPointer}/` === longPointer.slice(0, shortPointer.length + 1)\n  }\n\n  /**\n   * 'toIndexedPointer' function\n   *\n   * Merges an array of numeric indexes and a generic pointer to create an\n   * indexed pointer for a specific item.\n   *\n   * For example, merging the generic pointer '/foo/-/bar/-/baz' and\n   * the array [4, 2] would result in the indexed pointer '/foo/4/bar/2/baz'\n   *\n   * @param genericPointer - The generic pointer\n   * @param indexArray - The array of numeric indexes\n   * @param arrayMap - An optional array map\n   * @return The merged pointer with indexes\n   */\n  static toIndexedPointer(\n    genericPointer: Pointer,\n    indexArray: number[],\n    arrayMap: Map<string, number> = null\n  ): string {\n    if (this.isJsonPointer(genericPointer) && isArray(indexArray)) {\n      let indexedPointer = this.compile(genericPointer)\n      if (isMap(arrayMap)) {\n        let arrayIndex = 0\n        return indexedPointer.replace(/\\/\\-(?=\\/|$)/g, (key, stringIndex) =>\n          arrayMap.has((indexedPointer as string).slice(0, stringIndex)) ?\n            '/' + indexArray[arrayIndex++] : key\n        )\n      } else {\n        for (const pointerIndex of indexArray) {\n          indexedPointer = indexedPointer.replace('/-', '/' + pointerIndex)\n        }\n        return indexedPointer\n      }\n    }\n    if (!this.isJsonPointer(genericPointer)) {\n      console.error(`toIndexedPointer error: Invalid JSON Pointer: ${genericPointer}`)\n    }\n    if (!isArray(indexArray)) {\n      console.error(`toIndexedPointer error: Invalid indexArray: ${indexArray}`)\n    }\n  }\n\n  /**\n   * 'toGenericPointer' function\n   *\n   * Compares an indexed pointer to an array map and removes list array\n   * indexes (but leaves tuple arrray indexes and all object keys, including\n   * numeric keys) to create a generic pointer.\n   *\n   * For example, using the indexed pointer '/foo/1/bar/2/baz/3' and\n   * the arrayMap [['/foo', 0], ['/foo/-/bar', 3], ['/foo/-/bar/-/baz', 0]]\n   * would result in the generic pointer '/foo/-/bar/2/baz/-'\n   * Using the indexed pointer '/foo/1/bar/4/baz/3' and the same arrayMap\n   * would result in the generic pointer '/foo/-/bar/-/baz/-'\n   * (the bar array has 3 tuple items, so index 2 is retained, but 4 is removed)\n   *\n   * The structure of the arrayMap is: [['path to array', number of tuple items]...]\n   *\n   * @param indexedPointer - The indexed pointer (array or string)\n   * @param arrayMap - The optional array map (for preserving tuple indexes)\n   * @return The generic pointer with indexes removed\n   */\n  static toGenericPointer(\n    indexedPointer: Pointer,\n    arrayMap: Map<string, number> = new Map<string, number>()\n  ): string {\n    if (this.isJsonPointer(indexedPointer) && isMap(arrayMap)) {\n      const pointerArray = this.parse(indexedPointer)\n      for (let i = 1; i < pointerArray.length; i++) {\n        const subPointer = this.compile(pointerArray.slice(0, i))\n        if (arrayMap.has(subPointer) &&\n          arrayMap.get(subPointer) <= +pointerArray[i]\n        ) {\n          pointerArray[i] = '-'\n        }\n      }\n      return this.compile(pointerArray)\n    }\n    if (!this.isJsonPointer(indexedPointer)) {\n      console.error(`toGenericPointer error: invalid JSON Pointer: ${indexedPointer}`)\n    }\n    if (!isMap(arrayMap)) {\n      console.error(`toGenericPointer error: invalid arrayMap: ${arrayMap}`)\n    }\n  }\n\n  /**\n   * 'toControlPointer' function\n   *\n   * Accepts a JSON Pointer for a data object and returns a JSON Pointer for the\n   * matching control in an Angular FormGroup.\n   *\n   * @param dataPointer - JSON Pointer (string or array) to a data object\n   * @param formGroup - Angular FormGroup to get value from\n   * @param controlMustExist - Only return if control exists?\n   * @return JSON Pointer (string) to the formGroup object\n   */\n  static toControlPointer(\n    dataPointer: Pointer,\n    formGroup: FormGroup,\n    controlMustExist: boolean = false\n  ) {\n    const dataPointerArray = this.parse(dataPointer)\n    const controlPointerArray: string[] = []\n    let subGroup: any = formGroup\n    if (dataPointerArray !== null) {\n      for (const key of dataPointerArray) {\n        if (hasOwn(subGroup, 'controls')) {\n          controlPointerArray.push('controls')\n          subGroup = subGroup.controls\n        }\n        if (isArray(subGroup) && (key === '-')) {\n          controlPointerArray.push((subGroup.length - 1).toString())\n          subGroup = subGroup[subGroup.length - 1]\n        } else if (hasOwn(subGroup, key)) {\n          controlPointerArray.push(key)\n          subGroup = subGroup[key]\n        } else if (controlMustExist) {\n          console.error(`toControlPointer error: Unable to find \"${key}\" item in FormGroup.`)\n          console.error(dataPointer)\n          console.error(formGroup)\n          return\n        } else {\n          controlPointerArray.push(key)\n          subGroup = {controls: {}}\n        }\n      }\n      return this.compile(controlPointerArray)\n    }\n    console.error(`toControlPointer error: Invalid JSON Pointer: ${dataPointer}`)\n  }\n\n  /**\n   * 'toSchemaPointer' function\n   *\n   * Accepts a JSON Pointer to a value inside a data object and a JSON schema\n   * for that object.\n   *\n   * Returns a Pointer to the sub-schema for the value inside the object's schema.\n   *\n   * @param dataPointer - JSON Pointer (string or array) to an object\n   * @param schema - JSON schema for the object\n   * @return JSON Pointer (string) to the object's schema\n   */\n  static toSchemaPointer(\n    dataPointer: Pointer,\n    schema: any\n  ): Pointer {\n    if (this.isJsonPointer(dataPointer) && typeof schema === 'object') {\n      const pointerArray = this.parse(dataPointer)\n      if (!pointerArray.length) {\n        return ''\n      }\n      const firstKey = pointerArray.shift()\n      if (schema.type === 'object' || schema.properties || schema.additionalProperties) {\n        if ((schema.properties || {})[firstKey]) {\n          return `/properties/${this.escape(firstKey)}` +\n            this.toSchemaPointer(pointerArray, schema.properties[firstKey])\n        } else if (schema.additionalProperties) {\n          return '/additionalProperties' +\n            this.toSchemaPointer(pointerArray, schema.additionalProperties)\n        }\n      }\n      if ((schema.type === 'array' || schema.items) &&\n        (isNumber(firstKey) || firstKey === '-' || firstKey === '')\n      ) {\n        const arrayItem = firstKey === '-' || firstKey === '' ? 0 : +firstKey\n        if (isArray(schema.items)) {\n          if (arrayItem < schema.items.length) {\n            return '/items/' + arrayItem +\n              this.toSchemaPointer(pointerArray, schema.items[arrayItem])\n          } else if (schema.additionalItems) {\n            return '/additionalItems' +\n              this.toSchemaPointer(pointerArray, schema.additionalItems)\n          }\n        } else if (isObject(schema.items)) {\n          return '/items' + this.toSchemaPointer(pointerArray, schema.items)\n        } else if (isObject(schema.additionalItems)) {\n          return '/additionalItems' +\n            this.toSchemaPointer(pointerArray, schema.additionalItems)\n        }\n      }\n      console.error(`toSchemaPointer error: Data pointer ${dataPointer} ` +\n        `not compatible with schema ${schema}`)\n      return null\n    }\n    if (!this.isJsonPointer(dataPointer)) {\n      console.error(`toSchemaPointer error: Invalid JSON Pointer: ${dataPointer}`)\n    }\n    if (typeof schema !== 'object') {\n      console.error(`toSchemaPointer error: Invalid JSON Schema: ${schema}`)\n    }\n    return null\n  }\n\n  /**\n   * 'toDataPointer' function\n   *\n   * Accepts a JSON Pointer to a sub-schema inside a JSON schema and the schema.\n   *\n   * If possible, returns a generic Pointer to the corresponding value inside\n   * the data object described by the JSON schema.\n   *\n   * Returns null if the sub-schema is in an ambiguous location (such as\n   * definitions or additionalProperties) where the corresponding value\n   * location cannot be determined.\n   *\n   * @param schemaPointer - JSON Pointer (string or array) to a JSON schema\n   * @param schema - the JSON schema\n   * @param errors - Show errors?\n   * @return JSON Pointer (string) to the value in the data object\n   */\n  static toDataPointer(\n    schemaPointer: Pointer,\n    schema: any,\n    errors: boolean = false\n  ): Pointer {\n    if (this.isJsonPointer(schemaPointer) && typeof schema === 'object' &&\n      this.has(schema, schemaPointer)\n    ) {\n      const pointerArray = this.parse(schemaPointer)\n      if (!pointerArray.length) {\n        return ''\n      }\n      const dataPointer = ''\n      const firstKey = pointerArray.shift()\n      if (firstKey === 'properties' ||\n        (firstKey === 'items' && isArray(schema.items))\n      ) {\n        const secondKey = pointerArray.shift()\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey][secondKey])\n        return pointerSuffix === null ? null : '/' + secondKey + pointerSuffix\n      } else if (firstKey === 'additionalItems' ||\n        (firstKey === 'items' && isObject(schema.items))\n      ) {\n        const pointerSuffix = this.toDataPointer(pointerArray, schema[firstKey])\n        return pointerSuffix === null ? null : '/-' + pointerSuffix\n      } else if (['allOf', 'anyOf', 'oneOf'].includes(firstKey)) {\n        const secondKey = pointerArray.shift()\n        return this.toDataPointer(pointerArray, schema[firstKey][secondKey])\n      } else if (firstKey === 'not') {\n        return this.toDataPointer(pointerArray, schema[firstKey])\n      } else if (['contains', 'definitions', 'dependencies', 'additionalItems',\n        'additionalProperties', 'patternProperties', 'propertyNames'].includes(firstKey)\n      ) {\n        if (errors) {\n          console.error(`toDataPointer error: Ambiguous location`)\n        }\n      }\n      return ''\n    }\n    if (errors) {\n      if (!this.isJsonPointer(schemaPointer)) {\n        console.error(`toDataPointer error: Invalid JSON Pointer: ${schemaPointer}`)\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Invalid JSON Schema: ${schema}`)\n      }\n      if (typeof schema !== 'object') {\n        console.error(`toDataPointer error: Pointer ${schemaPointer} invalid for Schema: ${schema}`)\n      }\n    }\n    return null\n  }\n\n  /**\n   * 'parseObjectPath' function\n   *\n   * Parses a JavaScript object path into an array of keys, which\n   * can then be passed to compile() to convert into a string JSON Pointer.\n   *\n   * Based on mike-marcacci's excellent objectpath parse function:\n   * https://github.com/mike-marcacci/objectpath\n   *\n   * @param path - The object path to parse\n   * @return The resulting array of keys\n   */\n  static parseObjectPath(path: Pointer): string[] {\n    if (isArray(path)) {\n      return path as string[]\n    }\n    if (this.isJsonPointer(path)) {\n      return this.parse(path)\n    }\n    if (typeof path === 'string') {\n      let index = 0\n      const parts: string[] = []\n      while (index < path.length) {\n        const nextDot = path.indexOf('.', index)\n        const nextOB = path.indexOf('[', index) // next open bracket\n        if (nextDot === -1 && nextOB === -1) { // last item\n          parts.push(path.slice(index))\n          index = path.length\n        } else if (nextDot !== -1 && (nextDot < nextOB || nextOB === -1)) { // dot notation\n          parts.push(path.slice(index, nextDot))\n          index = nextDot + 1\n        } else { // bracket notation\n          if (nextOB > index) {\n            parts.push(path.slice(index, nextOB))\n            index = nextOB\n          }\n          const quote = path.charAt(nextOB + 1)\n          if (quote === '\"' || quote === '\\'') { // enclosing quotes\n            let nextCB = path.indexOf(quote + ']', nextOB) // next close bracket\n            while (nextCB !== -1 && path.charAt(nextCB - 1) === '\\\\') {\n              nextCB = path.indexOf(quote + ']', nextCB + 2)\n            }\n            if (nextCB === -1) {\n              nextCB = path.length\n            }\n            parts.push(path.slice(index + 2, nextCB)\n              .replace(new RegExp('\\\\' + quote, 'g'), quote))\n            index = nextCB + 2\n          } else { // no enclosing quotes\n            let nextCB = path.indexOf(']', nextOB) // next close bracket\n            if (nextCB === -1) {\n              nextCB = path.length\n            }\n            parts.push(path.slice(index + 1, nextCB))\n            index = nextCB + 1\n          }\n          if (path.charAt(index) === '.') {\n            index++\n          }\n        }\n      }\n      return parts\n    }\n    console.error('parseObjectPath error: Input object path must be a string.')\n  }\n}\n","// tslint:disable max-line-length\n// updated from AJV fast format regular expressions:\n// https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n\nexport const jsonSchemaFormatTests = {\n  date: /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/,\n\n  time: /^[0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // Modified to allow incomplete entries, such as\n  // \"2000-03-14T01:59:26.535\" (needs \"Z\") or \"2000-03-14T01:59\" (needs \":00Z\")\n  'date-time': /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d(?::[0-5]\\d)?(?:\\.\\d+)?(?:z|[+-]\\d\\d:\\d\\d)?$/i,\n\n  // email (sources from jsen validator):\n  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363\n  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')\n  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,\n\n  hostname: /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i,\n\n  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html\n  ipv4: /^(?:(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d\\d?)$/,\n\n  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses\n  ipv6: /^\\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(?:%.+)?\\s*$/i,\n\n  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js\n  uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\\/)\\/?[^\\s]*$/i,\n\n  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A\n  'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\\/\\/)?[^\\s]*$/i,\n\n  // uri-template: https://tools.ietf.org/html/rfc6570\n  'uri-template': /^(?:(?:[^\\x00-\\x20\"'<>%\\\\^`{|}]|%[0-9a-f]{2})|\\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\\*)?)*\\})*$/i,\n\n  // For the source: https://gist.github.com/dperini/729294\n  // For test cases: https://mathiasbynens.be/demo/url-regex\n  // @todo Delete current URL in favour of the commented out URL rule when this ajv issue is fixed https://github.com/eslint/eslint/issues/7983.\n  // URL: /^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!10(?:\\.\\d{1,3}){3})(?!127(?:\\.\\d{1,3}){3})(?!169\\.254(?:\\.\\d{1,3}){2})(?!192\\.168(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}0-9]+-?)*[a-z\\u{00a1}-\\u{ffff}0-9]+)*(?:\\.(?:[a-z\\u{00a1}-\\u{ffff}]{2,})))(?::\\d{2,5})?(?:\\/[^\\s]*)?$/iu,\n  url: /^(?:(?:http[s\\u017F]?|ftp):\\/\\/)(?:(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+(?::(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?@)?(?:(?!10(?:\\.[0-9]{1,3}){3})(?!127(?:\\.[0-9]{1,3}){3})(?!169\\.254(?:\\.[0-9]{1,3}){2})(?!192\\.168(?:\\.[0-9]{1,3}){2})(?!172\\.(?:1[6-9]|2[0-9]|3[01])(?:\\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)(?:\\.(?:(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+-?)*(?:[0-9KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])+)*(?:\\.(?:(?:[KSa-z\\xA1-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\\/(?:[\\0-\\x08\\x0E-\\x1F!-\\x9F\\xA1-\\u167F\\u1681-\\u1FFF\\u200B-\\u2027\\u202A-\\u202E\\u2030-\\u205E\\u2060-\\u2FFF\\u3001-\\uD7FF\\uE000-\\uFEFE\\uFF00-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF])*)?$/i,\n\n  // uuid: http://tools.ietf.org/html/rfc4122\n  uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,\n\n  // optimized https://gist.github.com/olmokramer/82ccce673f86db7cda5e\n  color: /^\\s*(#(?:[\\da-f]{3}){1,2}|rgb\\((?:\\d{1,3},\\s*){2}\\d{1,3}\\)|rgba\\((?:\\d{1,3},\\s*){3}\\d*\\.?\\d+\\)|hsl\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2}\\)|hsla\\(\\d{1,3}(?:,\\s*\\d{1,3}%){2},\\s*\\d*\\.?\\d+\\))\\s*$/gi,\n\n  // JSON-pointer: https://tools.ietf.org/html/rfc6901\n  'json-pointer': /^(?:\\/(?:[^~/]|~0|~1)*)*$|^#(?:\\/(?:[a-z0-9_\\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,\n\n  'relative-json-pointer': /^(?:0|[1-9][0-9]*)(?:#|(?:\\/(?:[^~/]|~0|~1)*)*)$/,\n\n  regex(str) {\n    if (/[^\\\\]\\\\Z/.test(str)) {\n      return false\n    }\n    try {\n      // tslint:disable-next-line no-unused-expression\n      new RegExp(str)\n      return true\n    } catch (e) {\n      return false\n    }\n  }\n}\n\nexport type JsonSchemaFormatNames =\n  'date' | 'time' | 'date-time' | 'email' | 'hostname' | 'ipv4' | 'ipv6' |\n  'uri' | 'uri-reference' | 'uri-template' | 'url' | 'uuid' | 'color' |\n  'json-pointer' | 'relative-json-pointer' | 'regex'\n","import {AbstractControl, ValidationErrors, ValidatorFn} from '@angular/forms'\nimport {forkJoin} from 'rxjs-compat/observable/forkJoin'\nimport {map} from 'rxjs-compat/operator/map'\n\nimport * as _ from 'lodash'\n\nimport {\n  executeValidators, executeAsyncValidators, mergeObjects, mergeErrors,\n  isEmpty, isDefined, hasValue, isString, isNumber, isBoolean, isArray,\n  getType, isType, toJavaScriptType, toObservable, xor, SchemaPrimitiveType,\n  IValidatorFn, AsyncIValidatorFn\n} from './functions/validator'\nimport {forEachCopy} from './functions/utility'\nimport {jsonSchemaFormatTests, JsonSchemaFormatNames} from './constants/format-regex.constants'\n\n/**\n * 'JsonValidators' class\n *\n * Provides an extended set of validators to be used by form controls,\n * compatible with standard JSON Schema validation options.\n * http://json-schema.org/latest/json-schema-validation.html\n *\n * Note: This library is designed as a drop-in replacement for the Angular\n * Validators library, and except for one small breaking change to the 'pattern'\n * validator (described below) it can even be imported as a substitute, like so:\n *\n *   import { JsonValidators as Validators } from 'json-validators';\n *\n * and it should work with existing code as a complete replacement.\n *\n * The one exception is the 'pattern' validator, which has been changed to\n * match partial values by default (the standard 'pattern' validator wrapped\n * all patterns in '^' and '$', forcing them to always match an entire value).\n * However, the old behavior can be restored by simply adding '^' and '$'\n * around your patterns, or by passing an optional second parameter of TRUE.\n * This change is to make the 'pattern' validator match the behavior of a\n * JSON Schema pattern, which allows partial matches, rather than the behavior\n * of an HTML input control pattern, which does not.\n *\n * This library replaces Angular's validators and combination functions\n * with the following validators and transformation functions:\n *\n * Validators:\n *   For all formControls:     required (*), type, enum, const\n *   For text formControls:    minLength (*), maxLength (*), pattern (*), format\n *   For numeric formControls: maximum, exclusiveMaximum,\n *                             minimum, exclusiveMinimum, multipleOf\n *   For formGroup objects:    minProperties, maxProperties, dependencies\n *   For formArray arrays:     minItems, maxItems, uniqueItems, contains\n *   Not used by JSON Schema:  min (*), max (*), requiredTrue (*), email (*)\n * (Validators originally included with Angular are marked with (*).)\n *\n * NOTE / TODO: The dependencies validator is not complete.\n * NOTE / TODO: The contains validator is not complete.\n *\n * Validators not used by JSON Schema (but included for compatibility)\n * and their JSON Schema equivalents:\n *\n *   Angular validator | JSON Schema equivalent\n *   ------------------|-----------------------\n *     min(number)     |   minimum(number)\n *     max(number)     |   maximum(number)\n *     requiredTrue()  |   const(true)\n *     email()         |   format('email')\n *\n * Validator transformation functions:\n *   composeAnyOf, composeOneOf, composeAllOf, composeNot\n * (Angular's original combination function, 'compose', is also included for\n * backward compatibility, though it is functionally equivalent to composeAllOf,\n * aside from its more generic error message.)\n *\n * All validators have also been extended to accept an optional second argument\n * which, if passed a TRUE value, causes the validator to perform the opposite\n * of its original function. (This is used internally to enable 'not' and\n * 'composeOneOf' to function and return useful error messages.)\n *\n * The 'required' validator has also been overloaded so that if called with\n * a boolean parameter (or no parameters) it returns the original validator\n * function (rather than executing it). However, if it is called with an\n * AbstractControl parameter (as was previously required), it behaves\n * exactly as before.\n *\n * This enables all validators (including 'required') to be constructed in\n * exactly the same way, so they can be automatically applied using the\n * equivalent key names and values taken directly from a JSON Schema.\n *\n * This source code is partially derived from Angular,\n * which is Copyright (c) 2014-2017 Google, Inc.\n * Use of this source code is therefore governed by the same MIT-style license\n * that can be found in the LICENSE file at https://angular.io/license\n *\n * Original Angular Validators:\n * https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n */\nexport class JsonValidators {\n\n  /**\n   * Validator functions:\n   *\n   * For all formControls:     required, type, enum, const\n   * For text formControls:    minLength, maxLength, pattern, format\n   * For numeric formControls: maximum, exclusiveMaximum,\n   *                           minimum, exclusiveMinimum, multipleOf\n   * For formGroup objects:    minProperties, maxProperties, dependencies\n   * For formArray arrays:     minItems, maxItems, uniqueItems, contains\n   *\n   * TODO: finish dependencies validator\n   */\n\n  /**\n   * 'required' validator\n   *\n   * This validator is overloaded, compared to the default required validator.\n   * If called with no parameters, or TRUE, this validator returns the\n   * 'required' validator function (rather than executing it). This matches\n   * the behavior of all other validators in this library.\n   *\n   * If this validator is called with an AbstractControl parameter\n   * (as was previously required) it behaves the same as Angular's default\n   * required validator, and returns an error if the control is empty.\n   *\n   * Behavior: (if no input, or input type = boolean)\n   * param {boolean = true} required? - true to validate, false to disable\n   * return {IValidatorFn} - returns the 'required' validator function itself\n   */\n  static required(input: AbstractControl): ValidationErrors | null\n  static required(input?: boolean): IValidatorFn\n  static required(input?: AbstractControl | boolean): ValidationErrors | null | IValidatorFn {\n    if (input === undefined) {\n      input = true\n    }\n    switch (input) {\n      case true: // Return required function (do not execute it yet)\n        return (control: AbstractControl, invert = false): ValidationErrors | null => {\n          if (invert) {\n            return null\n          } // if not required, always return valid\n          return hasValue(control.value) ? null : {required: true}\n        }\n      case false: // Do nothing (if field is not required, it is always valid)\n        return JsonValidators.nullValidator\n      default: // Execute required function\n        return hasValue((input as AbstractControl).value) ? null : {required: true}\n    }\n  }\n\n  /**\n   * 'type' validator\n   *\n   * Requires a control to only accept values of a specified type,\n   * or one of an array of types.\n   *\n   * Note: SchemaPrimitiveType = 'string'|'number'|'integer'|'boolean'|'null'\n   *\n   * @param requiredType - type(s) to accept\n   */\n  static type(requiredType: SchemaPrimitiveType | SchemaPrimitiveType[]): IValidatorFn {\n    if (!hasValue(requiredType)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue: any = control.value\n      const isValid = isArray(requiredType) ?\n        (requiredType as SchemaPrimitiveType[]).some(type => isType(currentValue, type)) :\n        isType(currentValue, requiredType as SchemaPrimitiveType)\n      return xor(isValid, invert) ?\n        null : {type: {requiredType, currentValue}}\n    }\n  }\n\n  /**\n   * 'enum' validator\n   *\n   * Requires a control to have a value from an enumerated list of values.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null enum values.\n   *\n   * @param allowedValues - array of acceptable values\n   */\n  static enum(allowedValues: any[]): IValidatorFn {\n    if (!isArray(allowedValues)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue: any = control.value\n      const isEqual = (enumValue, inputValue) =>\n        enumValue === inputValue ||\n        (isNumber(enumValue) && +inputValue === +enumValue) ||\n        (isBoolean(enumValue, 'strict') &&\n          toJavaScriptType(inputValue, 'boolean') === enumValue) ||\n        (enumValue === null && !hasValue(inputValue)) ||\n        _.isEqual(enumValue, inputValue)\n      const isValid = isArray(currentValue) ?\n        currentValue.every(inputValue => allowedValues.some(enumValue =>\n          isEqual(enumValue, inputValue)\n        )) :\n        allowedValues.some(enumValue => isEqual(enumValue, currentValue))\n      return xor(isValid, invert) ?\n        null : {enum: {allowedValues, currentValue}}\n    }\n  }\n\n  /**\n   * 'const' validator\n   *\n   * Requires a control to have a specific value.\n   *\n   * Converts types as needed to allow string inputs to still correctly\n   * match number, boolean, and null values.\n   *\n   * TODO: modify to work with objects\n   *\n   * @param requiredValue - required value\n   */\n  static const(requiredValue: any): IValidatorFn {\n    if (!hasValue(requiredValue)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue: any = control.value\n      const isEqual = (constValue, inputValue) =>\n        constValue === inputValue ||\n        isNumber(constValue) && +inputValue === +constValue ||\n        isBoolean(constValue, 'strict') &&\n        toJavaScriptType(inputValue, 'boolean') === constValue ||\n        constValue === null && !hasValue(inputValue)\n      const isValid = isEqual(requiredValue, currentValue)\n      return xor(isValid, invert) ?\n        null : {const: {requiredValue, currentValue}}\n    }\n  }\n\n  /**\n   * 'minLength' validator\n   *\n   * Requires a control's text value to be greater than a specified length.\n   *\n   * @param minimumLength - minimum allowed string length\n   */\n  static minLength(minimumLength: number): IValidatorFn {\n    if (!hasValue(minimumLength)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentLength = isString(control.value) ? control.value.length : 0\n      const isValid = currentLength >= minimumLength\n      return xor(isValid, invert) ?\n        null : {minLength: {minimumLength, currentLength}}\n    }\n  }\n\n  /**\n   * 'maxLength' validator\n   *\n   * Requires a control's text value to be less than a specified length.\n   *\n   * @param maximumLength - maximum allowed string length\n   */\n  static maxLength(maximumLength: number): IValidatorFn {\n    if (!hasValue(maximumLength)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      const currentLength = isString(control.value) ? control.value.length : 0\n      const isValid = currentLength <= maximumLength\n      return xor(isValid, invert) ?\n        null : {maxLength: {maximumLength, currentLength}}\n    }\n  }\n\n  /**\n   * 'pattern' validator\n   *\n   * Note: NOT the same as Angular's default pattern validator.\n   *\n   * Requires a control's value to match a specified regular expression pattern.\n   *\n   * This validator changes the behavior of default pattern validator\n   * by replacing RegExp(`^${pattern}$`) with RegExp(`${pattern}`),\n   * which allows for partial matches.\n   *\n   * To return to the default functionality, and match the entire string,\n   * pass TRUE as the optional second parameter.\n   *\n   * @param pattern - regular expression pattern\n   * @param wholeString - match whole value string?\n   */\n  static pattern(pattern: string | RegExp, wholeString = false): IValidatorFn {\n    if (!hasValue(pattern)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      let regex: RegExp\n      let requiredPattern: string\n      if (typeof pattern === 'string') {\n        requiredPattern = (wholeString) ? `^${pattern}$` : pattern\n        regex = new RegExp(requiredPattern)\n      } else {\n        requiredPattern = pattern.toString()\n        regex = pattern\n      }\n      const currentValue: string = control.value\n      const isValid = isString(currentValue) ? regex.test(currentValue) : false\n      return xor(isValid, invert) ?\n        null : {pattern: {requiredPattern, currentValue}}\n    }\n  }\n\n  /**\n   * 'format' validator\n   *\n   * Requires a control to have a value of a certain format.\n   *\n   * This validator currently checks the following formats:\n   *   date, time, date-time, email, hostname, ipv4, ipv6,\n   *   uri, uri-reference, uri-template, url, uuid, color,\n   *   json-pointer, relative-json-pointer, regex\n   *\n   * Fast format regular expressions copied from AJV:\n   * https://github.com/epoberezkin/ajv/blob/master/lib/compile/formats.js\n   *\n   * @param requiredFormat - format to check\n   */\n  static format(requiredFormat: JsonSchemaFormatNames): IValidatorFn {\n    if (!hasValue(requiredFormat)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      let isValid: boolean\n      const currentValue: string | Date = control.value\n      if (isString(currentValue)) {\n        const formatTest = jsonSchemaFormatTests[requiredFormat]\n        if (typeof formatTest === 'object') {\n          isValid = (formatTest as RegExp).test(currentValue as string)\n        } else if (typeof formatTest === 'function') {\n          isValid = formatTest(currentValue as string)\n        } else {\n          console.error(`format validator error: \"${requiredFormat}\" is not a recognized format.`)\n          isValid = true\n        }\n      } else {\n        // Allow JavaScript Date objects\n        isValid = ['date', 'time', 'date-time'].includes(requiredFormat) &&\n          Object.prototype.toString.call(currentValue) === '[object Date]'\n      }\n      return xor(isValid, invert) ?\n        null : {format: {requiredFormat, currentValue}}\n    }\n  }\n\n  /**\n   * 'minimum' validator\n   *\n   * Requires a control's numeric value to be greater than or equal to\n   * a minimum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a minimum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param minimumValue - minimum allowed value\n   */\n  static minimum(minimumValue: number): IValidatorFn {\n    if (!hasValue(minimumValue)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue = control.value\n      const isValid = !isNumber(currentValue) || currentValue >= minimumValue\n      return xor(isValid, invert) ?\n        null : {minimum: {minimumValue, currentValue}}\n    }\n  }\n\n  /**\n   * 'exclusiveMinimum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param exclusiveMinimumValue - maximum allowed value\n   */\n  static exclusiveMinimum(exclusiveMinimumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMinimumValue)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue = control.value\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMinimumValue\n      return xor(isValid, invert) ?\n        null : {exclusiveMinimum: {exclusiveMinimumValue, currentValue}}\n    }\n  }\n\n  /**\n   * 'maximum' validator\n   *\n   * Requires a control's numeric value to be less than or equal to\n   * a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param maximumValue - maximum allowed value\n   */\n  static maximum(maximumValue: number): IValidatorFn {\n    if (!hasValue(maximumValue)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue = control.value\n      const isValid = !isNumber(currentValue) || +currentValue <= maximumValue\n      return xor(isValid, invert) ?\n        null : {maximum: {maximumValue, currentValue}}\n    }\n  }\n\n  /**\n   * 'exclusiveMaximum' validator\n   *\n   * Requires a control's numeric value to be less than a maximum amount.\n   *\n   * Any non-numeric value is also valid (according to the HTML forms spec,\n   * a non-numeric value doesn't have a maximum).\n   * https://www.w3.org/TR/html5/forms.html#attr-input-max\n   *\n   * @param exclusiveMaximumValue - maximum allowed value\n   */\n  static exclusiveMaximum(exclusiveMaximumValue: number): IValidatorFn {\n    if (!hasValue(exclusiveMaximumValue)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue = control.value\n      const isValid = !isNumber(currentValue) || +currentValue < exclusiveMaximumValue\n      return xor(isValid, invert) ?\n        null : {exclusiveMaximum: {exclusiveMaximumValue, currentValue}}\n    }\n  }\n\n  /**\n   * 'multipleOf' validator\n   *\n   * Requires a control to have a numeric value that is a multiple\n   * of a specified number.\n   *\n   * @param multipleOfValue - number value must be a multiple of\n   */\n  static multipleOf(multipleOfValue: number): IValidatorFn {\n    if (!hasValue(multipleOfValue)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentValue = control.value\n      const isValid = isNumber(currentValue) &&\n        currentValue % multipleOfValue === 0\n      return xor(isValid, invert) ?\n        null : {multipleOf: {multipleOfValue, currentValue}}\n    }\n  }\n\n  /**\n   * 'minProperties' validator\n   *\n   * Requires a form group to have a minimum number of properties (i.e. have\n   * values entered in a minimum number of controls within the group).\n   *\n   * @param minimumProperties - minimum number of properties allowed\n   */\n  static minProperties(minimumProperties: number): IValidatorFn {\n    if (!hasValue(minimumProperties)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentProperties = Object.keys(control.value).length || 0\n      const isValid = currentProperties >= minimumProperties\n      return xor(isValid, invert) ?\n        null : {minProperties: {minimumProperties, currentProperties}}\n    }\n  }\n\n  /**\n   * 'maxProperties' validator\n   *\n   * Requires a form group to have a maximum number of properties (i.e. have\n   * values entered in a maximum number of controls within the group).\n   *\n   * Note: Has no effect if the form group does not contain more than the\n   * maximum number of controls.\n   *\n   * @param maximumProperties - maximum number of properties allowed\n   */\n  static maxProperties(maximumProperties: number): IValidatorFn {\n    if (!hasValue(maximumProperties)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      const currentProperties = Object.keys(control.value).length || 0\n      const isValid = currentProperties <= maximumProperties\n      return xor(isValid, invert) ?\n        null : {maxProperties: {maximumProperties, currentProperties}}\n    }\n  }\n\n  /**\n   * 'dependencies' validator\n   *\n   * Requires the controls in a form group to meet additional validation\n   * criteria, depending on the values of other controls in the group.\n   *\n   * Examples:\n   * https://spacetelescope.github.io/understanding-json-schema/reference/object.html#dependencies\n   *\n   * @param dependencies - required dependencies\n   */\n  static dependencies(dependencies: any): IValidatorFn {\n    if (getType(dependencies) !== 'object' || isEmpty(dependencies)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const allErrors = mergeObjects(\n        forEachCopy(dependencies, (value, requiringField) => {\n          if (!hasValue(control.value[requiringField])) {\n            return null\n          }\n          let requiringFieldErrors: ValidationErrors = {}\n          let requiredFields: string[]\n          let properties: ValidationErrors = {}\n          if (getType(dependencies[requiringField]) === 'array') {\n            requiredFields = dependencies[requiringField]\n          } else if (getType(dependencies[requiringField]) === 'object') {\n            requiredFields = dependencies[requiringField].required || []\n            properties = dependencies[requiringField].properties || {}\n          }\n\n          // Validate property dependencies\n          for (const requiredField of requiredFields) {\n            if (xor(!hasValue(control.value[requiredField]), invert)) {\n              requiringFieldErrors[requiredField] = {required: true}\n            }\n          }\n\n          // Validate schema dependencies\n          requiringFieldErrors = mergeObjects(requiringFieldErrors,\n            forEachCopy(properties, (requirements, requiredField) => {\n              const requiredFieldErrors = mergeObjects(\n                forEachCopy(requirements, (requirement, parameter) => {\n                  let validator: IValidatorFn = null\n                  if (requirement === 'maximum' || requirement === 'minimum') {\n                    const exclusive = !!requirements['exclusiveM' + requirement.slice(1)]\n                    validator = JsonValidators[requirement](parameter, exclusive)\n                  } else if (typeof JsonValidators[requirement] === 'function') {\n                    validator = JsonValidators[requirement](parameter)\n                  }\n                  return !isDefined(validator) ?\n                    null : validator(control.value[requiredField])\n                })\n              )\n              return isEmpty(requiredFieldErrors) ?\n                null : {[requiredField]: requiredFieldErrors}\n            })\n          )\n          return isEmpty(requiringFieldErrors) ?\n            null : {[requiringField]: requiringFieldErrors}\n        })\n      )\n      return isEmpty(allErrors) ? null : allErrors\n    }\n  }\n\n  /**\n   * 'minItems' validator\n   *\n   * Requires a form array to have a minimum number of values.\n   *\n   * @param minimumItems - minimum number of items allowed\n   */\n  static minItems(minimumItems: number): IValidatorFn {\n    if (!hasValue(minimumItems)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const currentItems = isArray(control.value) ? control.value.length : 0\n      const isValid = currentItems >= minimumItems\n      return xor(isValid, invert) ?\n        null : {minItems: {minimumItems, currentItems}}\n    }\n  }\n\n  /**\n   * 'maxItems' validator\n   *\n   * Requires a form array to have a maximum number of values.\n   *\n   * @param maximumItems - maximum number of items allowed\n   */\n  static maxItems(maximumItems: number): IValidatorFn {\n    if (!hasValue(maximumItems)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      const currentItems = isArray(control.value) ? control.value.length : 0\n      const isValid = currentItems <= maximumItems\n      return xor(isValid, invert) ?\n        null : {maxItems: {maximumItems, currentItems}}\n    }\n  }\n\n  /**\n   * 'uniqueItems' validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param unique? - true to validate, false to disable\n   */\n  static uniqueItems(unique = true): IValidatorFn {\n    if (!unique) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const sorted: any[] = control.value.slice().sort()\n      const duplicateItems = []\n      for (let i = 1; i < sorted.length; i++) {\n        if (sorted[i - 1] === sorted[i] && duplicateItems.includes(sorted[i])) {\n          duplicateItems.push(sorted[i])\n        }\n      }\n      const isValid = !duplicateItems.length\n      return xor(isValid, invert) ?\n        null : {uniqueItems: {duplicateItems}}\n    }\n  }\n\n  /**\n   * 'contains' validator\n   *\n   * TODO: Complete this validator\n   *\n   * Requires values in a form array to be unique.\n   *\n   * @param requiredItem? - true to validate, false to disable\n   */\n  static contains(requiredItem = true): IValidatorFn {\n    if (!requiredItem) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value) || !isArray(control.value)) {\n        return null\n      }\n      const currentItems = control.value\n      // const isValid = currentItems.some(item =>\n      //\n      // );\n      const isValid = true\n      return xor(isValid, invert) ?\n        null : {contains: {requiredItem, currentItems}}\n    }\n  }\n\n  /**\n   * No-op validator. Included for backward compatibility.\n   */\n  static nullValidator(control: AbstractControl): ValidationErrors | null {\n    return null\n  }\n\n  /**\n   * Validator transformation functions:\n   * composeAnyOf, composeOneOf, composeAllOf, composeNot,\n   * compose, composeAsync\n   *\n   * TODO: Add composeAnyOfAsync, composeOneOfAsync,\n   *           composeAllOfAsync, composeNotAsync\n   */\n\n  /**\n   * 'composeAnyOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid if any one or more of the submitted validators are\n   * valid. If every validator is invalid, it returns combined errors from\n   * all validators.\n   *\n   * @param validators - array of validators to combine\n   */\n  static composeAnyOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) {\n      return null\n    }\n    const presentValidators = validators.filter(isDefined)\n    if (presentValidators.length === 0) {\n      return null\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      const arrayOfErrors =\n        executeValidators(control, presentValidators, invert).filter(isDefined)\n      const isValid = validators.length > arrayOfErrors.length\n      return xor(isValid, invert) ?\n        null : mergeObjects(...arrayOfErrors, {anyOf: !invert})\n    }\n  }\n\n  /**\n   * 'composeOneOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if exactly one of the submitted validators\n   * is valid. Otherwise returns combined information from all validators,\n   * both valid and invalid.\n   *\n   * @param validators - array of validators to combine\n   * @return single combined validator function\n   */\n  static composeOneOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) {\n      return null\n    }\n    const presentValidators = validators.filter(isDefined)\n    if (presentValidators.length === 0) {\n      return null\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      const arrayOfErrors =\n        executeValidators(control, presentValidators)\n      const validControls =\n        validators.length - arrayOfErrors.filter(isDefined).length\n      const isValid = validControls === 1\n      if (xor(isValid, invert)) {\n        return null\n      }\n      const arrayOfValids =\n        executeValidators(control, presentValidators, invert)\n      return mergeObjects(...arrayOfErrors, ...arrayOfValids, {oneOf: !invert})\n    }\n  }\n\n  /**\n   * 'composeAllOf' validator combination function\n   *\n   * Accepts an array of validators and returns a single validator that\n   * evaluates to valid only if all the submitted validators are individually\n   * valid. Otherwise it returns combined errors from all invalid validators.\n   *\n   * @param validators - array of validators to combine\n   * @return single combined validator function\n   */\n  static composeAllOf(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) {\n      return null\n    }\n    const presentValidators = validators.filter(isDefined)\n    if (presentValidators.length === 0) {\n      return null\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      const combinedErrors = mergeErrors(\n        executeValidators(control, presentValidators, invert)\n      )\n      const isValid = combinedErrors === null\n      return (xor(isValid, invert)) ?\n        null : mergeObjects(combinedErrors, {allOf: !invert})\n    }\n  }\n\n  /**\n   * 'composeNot' validator inversion function\n   *\n   * Accepts a single validator function and inverts its result.\n   * Returns valid if the submitted validator is invalid, and\n   * returns invalid if the submitted validator is valid.\n   * (Note: this function can itself be inverted\n   *   - e.g. composeNot(composeNot(validator)) -\n   *   but this can be confusing and is therefore not recommended.)\n   *\n   * @param validator - validator(s) to invert\n   * @return new validator function that returns opposite result\n   */\n  static composeNot(validator: IValidatorFn): IValidatorFn {\n    if (!validator) {\n      return null\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null => {\n      if (isEmpty(control.value)) {\n        return null\n      }\n      const error = validator(control, !invert)\n      const isValid = error === null\n      return (xor(isValid, invert)) ?\n        null : mergeObjects(error, {not: !invert})\n    }\n  }\n\n  /**\n   * 'compose' validator combination function\n   *\n   * @param validators - array of validators to combine\n   * @return single combined validator function\n   */\n  static compose(validators: IValidatorFn[]): IValidatorFn {\n    if (!validators) {\n      return null\n    }\n    const presentValidators = validators.filter(isDefined)\n    if (presentValidators.length === 0) {\n      return null\n    }\n    return (control: AbstractControl, invert = false): ValidationErrors | null =>\n      mergeErrors(executeValidators(control, presentValidators, invert))\n  }\n\n  /**\n   * 'composeAsync' async validator combination function\n   *\n   * @param validators - array of async validators\n   * @return single combined async validator function\n   */\n  static composeAsync(validators: AsyncIValidatorFn[]): AsyncIValidatorFn {\n    if (!validators) {\n      return null\n    }\n    const presentValidators = validators.filter(isDefined)\n    if (presentValidators.length === 0) {\n      return null\n    }\n    return (control: AbstractControl) => {\n      const observables =\n        executeAsyncValidators(control, presentValidators).map(toObservable)\n      return map.call(forkJoin(observables), mergeErrors)\n    }\n  }\n\n  // Additional angular validators (not used by Angualr JSON Schema Form)\n  // From https://github.com/angular/angular/blob/master/packages/forms/src/validators.ts\n\n  /**\n   * Validator that requires controls to have a value greater than a number.\n   */\n  static min(min: number): ValidatorFn {\n    if (!hasValue(min)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl): ValidationErrors | null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(min)) {\n        return null\n      }\n      const value = parseFloat(control.value)\n      const actual = control.value\n      // Controls with NaN values after parsing should be treated as not having a\n      // minimum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-min\n      return isNaN(value) || value >= min ? null : {min: {min, actual}}\n    }\n  }\n\n  /**\n   * Validator that requires controls to have a value less than a number.\n   */\n  static max(max: number): ValidatorFn {\n    if (!hasValue(max)) {\n      return JsonValidators.nullValidator\n    }\n    return (control: AbstractControl): ValidationErrors | null => {\n      // don't validate empty values to allow optional controls\n      if (isEmpty(control.value) || isEmpty(max)) {\n        return null\n      }\n      const value = parseFloat(control.value)\n      const actual = control.value\n      // Controls with NaN values after parsing should be treated as not having a\n      // maximum, per the HTML forms spec: https://www.w3.org/TR/html5/forms.html#attr-input-max\n      return isNaN(value) || value <= max ? null : {max: {max, actual}}\n    }\n  }\n\n  /**\n   * Validator that requires control value to be true.\n   */\n  static requiredTrue(control: AbstractControl): ValidationErrors | null {\n    if (!control) {\n      return JsonValidators.nullValidator\n    }\n    return control.value === true ? null : {required: true}\n  }\n\n  /**\n   * Validator that performs email validation.\n   */\n  static email(control: AbstractControl): ValidationErrors | null {\n    if (!control) {\n      return JsonValidators.nullValidator\n    }\n    const EMAIL_REGEXP =\n      // tslint:disable-next-line max-line-length\n      /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/\n    return EMAIL_REGEXP.test(control.value) ? null : {email: true}\n  }\n}\n","import {getType} from '../validator'\n\n/**\n * 'buildSchemaFromData' function\n *\n * Build a JSON Schema from a data object\n *\n * @param  data - The data object\n * @param  requireAllFields - Require all fields?\n * @param  isRoot - is root\n * @return The new JSON Schema\n */\nexport function buildSchemaFromData(\n  data: any,\n  requireAllFields = false,\n  isRoot = true\n) {\n  const newSchema: any = {}\n  const getFieldType = (value: any): string => {\n    const fieldType = getType(value, 'strict')\n    return {integer: 'number', null: 'string'}[fieldType] || fieldType\n  }\n  const buildSubSchema = (value) =>\n    buildSchemaFromData(value, requireAllFields, false)\n  if (isRoot) {\n    newSchema.$schema = 'http://json-schema.org/draft-06/schema#'\n  }\n  newSchema.type = getFieldType(data)\n  if (newSchema.type === 'object') {\n    newSchema.properties = {}\n    if (requireAllFields) {\n      newSchema.required = []\n    }\n    for (const key of Object.keys(data)) {\n      newSchema.properties[key] = buildSubSchema(data[key])\n      if (requireAllFields) {\n        newSchema.required.push(key)\n      }\n    }\n  } else if (newSchema.type === 'array') {\n    newSchema.items = data.map(buildSubSchema)\n    // If all items are the same type, use an object for items instead of an array\n    if ((new Set(data.map(getFieldType))).size === 1) {\n      newSchema.items = newSchema.items.reduce((a, b) => ({...a, ...b}), {})\n    }\n    if (requireAllFields) {\n      newSchema.minItems = 1\n    }\n  }\n  return newSchema\n}\n","/**\n * 'buildSchemaFromLayout' function\n *\n * TODO: Build a JSON Schema from a JSON Form layout\n *\n * @param  layout - The JSON Form layout\n * @return The new JSON Schema\n */\nexport function buildSchemaFromLayout(layout: any[]) {\n  return\n  // let newSchema: any = { };\n  // const walkLayout = (layoutItems: any[], callback: Function): any[] => {\n  //   let returnArray: any[] = [];\n  //   for (let layoutItem of layoutItems) {\n  //     const returnItem: any = callback(layoutItem);\n  //     if (returnItem) { returnArray = returnArray.concat(callback(layoutItem)); }\n  //     if (layoutItem.items) {\n  //       returnArray = returnArray.concat(walkLayout(layoutItem.items, callback));\n  //     }\n  //   }\n  //   return returnArray;\n  // };\n  // walkLayout(layout, layoutItem => {\n  //   let itemKey: string;\n  //   if (typeof layoutItem === 'string') {\n  //     itemKey = layoutItem;\n  //   } else if (layoutItem.key) {\n  //     itemKey = layoutItem.key;\n  //   }\n  //   if (!itemKey) { return; }\n  //   //\n  // });\n}\n","import {isString} from '../validator'\nimport {JsonPointer} from '../jsonpointer.functions'\n\n/**\n * 'checkInlineType' function\n *\n * Checks layout and schema nodes for 'inline: true', and converts\n * 'radios' or 'checkboxes' to 'radios-inline' or 'checkboxes-inline'\n */\nexport function checkInlineType(\n  controlType: string,\n  schema: any,\n  layoutNode: any = null\n): string {\n  if (!isString(controlType) || (\n    controlType.slice(0, 8) !== 'checkbox' && controlType.slice(0, 5) !== 'radio'\n  )) {\n    return controlType\n  }\n  if (\n    JsonPointer.getFirst([\n      [layoutNode, '/inline'],\n      [layoutNode, '/options/inline'],\n      [schema, '/inline'],\n      [schema, '/x-schema-form/inline'],\n      [schema, '/x-schema-form/options/inline'],\n      [schema, '/x-schema-form/widget/inline'],\n      [schema, '/x-schema-form/widget/component/inline'],\n      [schema, '/x-schema-form/widget/component/options/inline'],\n      [schema, '/widget/inline'],\n      [schema, '/widget/component/inline'],\n      [schema, '/widget/component/options/inline'],\n    ]) === true\n  ) {\n    return controlType.slice(0, 5) === 'radio' ?\n      'radios-inline' : 'checkboxes-inline'\n  } else {\n    return controlType\n  }\n}\n","import {isArray, isEmpty, isNumber, isObject, isString} from '../validator'\nimport {commonItems, hasOwn, uniqueItems} from '../utility'\nimport * as _ from 'lodash'\n\n/**\n * 'mergeSchemas' function\n *\n * Merges multiple JSON schemas into a single schema with combined rules.\n *\n * If able to logically merge properties from all schemas,\n * returns a single schema object containing all merged properties.\n *\n * Example: ({ a: b, max: 1 }, { c: d, max: 2 }) => { a: b, c: d, max: 1 }\n *\n * If unable to logically merge, returns an allOf schema object containing\n * an array of the original schemas;\n *\n * Example: ({ a: b }, { a: d }) => { allOf: [ { a: b }, { a: d } ] }\n *\n * @param schemas - one or more input schemas\n * @return merged schema\n */\nexport function mergeSchemas(...schemas: any) {\n  schemas = schemas.filter(schema => !isEmpty(schema))\n  if (schemas.some(schema => !isObject(schema))) {\n    return null\n  }\n  const combinedSchema: any = {}\n  for (const schema of schemas) {\n    for (const key of Object.keys(schema)) {\n      const combinedValue = combinedSchema[key]\n      const schemaValue = schema[key]\n      if (!hasOwn(combinedSchema, key) || _.isEqual(combinedValue, schemaValue)) {\n        combinedSchema[key] = schemaValue\n      } else {\n        switch (key) {\n          case 'allOf':\n            // Combine all items from both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.allOf = mergeSchemas(...combinedValue, ...schemaValue)\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'additionalItems':\n          case 'additionalProperties':\n          case 'contains':\n          case 'propertyNames':\n            // Merge schema objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema[key] = mergeSchemas(combinedValue, schemaValue)\n              // additionalProperties == false in any schema overrides all other values\n            } else if (\n              key === 'additionalProperties' &&\n              (combinedValue === false || schemaValue === false)\n            ) {\n              combinedSchema.combinedSchema = false\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'anyOf':\n          case 'oneOf':\n          case 'enum':\n            // Keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema[key] = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              )\n              if (!combinedSchema[key].length) {\n                return {allOf: [...schemas]}\n              }\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'definitions':\n            // Combine keys from both objects\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = {...combinedValue}\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey]\n                  // Don't combine matching keys with different values\n                } else {\n                  return {allOf: [...schemas]}\n                }\n              }\n              combinedSchema.definitions = combinedObject\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'dependencies':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys,\n            // converting from arrays to objects if necessary\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = {...combinedValue}\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey]\n                  // If both keys are arrays, include all items from both arrays,\n                  // excluding duplicates\n                } else if (\n                  isArray(schemaValue[subKey]) && isArray(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    uniqueItems(...combinedObject[subKey], ...schemaValue[subKey])\n                  // If either key is an object, merge the schemas\n                } else if (\n                  (isArray(schemaValue[subKey]) || isObject(schemaValue[subKey])) &&\n                  (isArray(combinedObject[subKey]) || isObject(combinedObject[subKey]))\n                ) {\n                  // If either key is an array, convert it to an object first\n                  const required = isArray(combinedSchema.required) ?\n                    combinedSchema.required : []\n                  const combinedDependency = isArray(combinedObject[subKey]) ?\n                    {required: uniqueItems(...required, combinedObject[subKey])} :\n                    combinedObject[subKey]\n                  const schemaDependency = isArray(schemaValue[subKey]) ?\n                    {required: uniqueItems(...required, schemaValue[subKey])} :\n                    schemaValue[subKey]\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedDependency, schemaDependency)\n                } else {\n                  return {allOf: [...schemas]}\n                }\n              }\n              combinedSchema.dependencies = combinedObject\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'items':\n            // If arrays, keep only items that appear in both arrays\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items = combinedValue.filter(item1 =>\n                schemaValue.findIndex(item2 => _.isEqual(item1, item2)) > -1\n              )\n              if (!combinedSchema.items.length) {\n                return {allOf: [...schemas]}\n              }\n              // If both keys are objects, merge them\n            } else if (isObject(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items = mergeSchemas(combinedValue, schemaValue)\n              // If object + array, combine object with each array item\n            } else if (isArray(combinedValue) && isObject(schemaValue)) {\n              combinedSchema.items =\n                combinedValue.map(item => mergeSchemas(item, schemaValue))\n            } else if (isObject(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.items =\n                schemaValue.map(item => mergeSchemas(item, combinedValue))\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'multipleOf':\n            // TODO: Adjust to correctly handle decimal values\n            // If numbers, set to least common multiple\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              const gcd = (x, y) => !y ? x : gcd(y, x % y)\n              const lcm = (x, y) => (x * y) / gcd(x, y)\n              combinedSchema.multipleOf = lcm(combinedValue, schemaValue)\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'maximum':\n          case 'exclusiveMaximum':\n          case 'maxLength':\n          case 'maxItems':\n          case 'maxProperties':\n            // If numbers, set to lowest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.min(combinedValue, schemaValue)\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'minimum':\n          case 'exclusiveMinimum':\n          case 'minLength':\n          case 'minItems':\n          case 'minProperties':\n            // If numbers, set to highest value\n            if (isNumber(combinedValue) && isNumber(schemaValue)) {\n              combinedSchema[key] = Math.max(combinedValue, schemaValue)\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'not':\n            // Combine not values into anyOf array\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const notAnyOf = [combinedValue, schemaValue]\n                .reduce((notAnyOfArray, notSchema) =>\n                    isArray(notSchema.anyOf) &&\n                    Object.keys(notSchema).length === 1 ?\n                      [...notAnyOfArray, ...notSchema.anyOf] :\n                      [...notAnyOfArray, notSchema]\n                  , [])\n              // TODO: Remove duplicate items from array\n              combinedSchema.not = {anyOf: notAnyOf}\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'patternProperties':\n            // Combine all keys from both objects\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = {...combinedValue}\n              for (const subKey of Object.keys(schemaValue)) {\n                if (!hasOwn(combinedObject, subKey) ||\n                  _.isEqual(combinedObject[subKey], schemaValue[subKey])\n                ) {\n                  combinedObject[subKey] = schemaValue[subKey]\n                  // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) && isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey])\n                } else {\n                  return {allOf: [...schemas]}\n                }\n              }\n              combinedSchema.patternProperties = combinedObject\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'properties':\n            // Combine all keys from both objects\n            // unless additionalProperties === false\n            // and merge schemas on matching keys\n            if (isObject(combinedValue) && isObject(schemaValue)) {\n              const combinedObject = {...combinedValue}\n              // If new schema has additionalProperties,\n              // merge or remove non-matching property keys in combined schema\n              if (hasOwn(schemaValue, 'additionalProperties')) {\n                Object.keys(combinedValue)\n                  .filter(combinedKey => !Object.keys(schemaValue).includes(combinedKey))\n                  .forEach(nonMatchingKey => {\n                    if (schemaValue.additionalProperties === false) {\n                      delete combinedObject[nonMatchingKey]\n                    } else if (isObject(schemaValue.additionalProperties)) {\n                      combinedObject[nonMatchingKey] = mergeSchemas(\n                        combinedObject[nonMatchingKey],\n                        schemaValue.additionalProperties\n                      )\n                    }\n                  })\n              }\n              for (const subKey of Object.keys(schemaValue)) {\n                if (_.isEqual(combinedObject[subKey], schemaValue[subKey]) || (\n                  !hasOwn(combinedObject, subKey) &&\n                  !hasOwn(combinedObject, 'additionalProperties')\n                )) {\n                  combinedObject[subKey] = schemaValue[subKey]\n                  // If combined schema has additionalProperties,\n                  // merge or ignore non-matching property keys in new schema\n                } else if (\n                  !hasOwn(combinedObject, subKey) &&\n                  hasOwn(combinedObject, 'additionalProperties')\n                ) {\n                  // If combinedObject.additionalProperties === false,\n                  // do nothing (don't set key)\n                  // If additionalProperties is object, merge with new key\n                  if (isObject(combinedObject.additionalProperties)) {\n                    combinedObject[subKey] = mergeSchemas(\n                      combinedObject.additionalProperties, schemaValue[subKey]\n                    )\n                  }\n                  // If both keys are objects, merge them\n                } else if (\n                  isObject(schemaValue[subKey]) &&\n                  isObject(combinedObject[subKey])\n                ) {\n                  combinedObject[subKey] =\n                    mergeSchemas(combinedObject[subKey], schemaValue[subKey])\n                } else {\n                  return {allOf: [...schemas]}\n                }\n              }\n              combinedSchema.properties = combinedObject\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'required':\n            // If arrays, include all items from both arrays, excluding duplicates\n            if (isArray(combinedValue) && isArray(schemaValue)) {\n              combinedSchema.required = uniqueItems(...combinedValue, ...schemaValue)\n              // If booleans, aet true if either true\n            } else if (\n              typeof schemaValue === 'boolean' &&\n              typeof combinedValue === 'boolean'\n            ) {\n              combinedSchema.required = !!combinedValue || !!schemaValue\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case '$schema':\n          case '$id':\n          case 'id':\n            // Don't combine these keys\n            break\n          case 'title':\n          case 'description':\n            // Return the last value, overwriting any previous one\n            // These properties are not used for validation, so conflicts don't matter\n            combinedSchema[key] = schemaValue\n            break\n          case 'type':\n            if (\n              (isArray(schemaValue) || isString(schemaValue)) &&\n              (isArray(combinedValue) || isString(combinedValue))\n            ) {\n              const combinedTypes = commonItems(combinedValue, schemaValue)\n              if (!combinedTypes.length) {\n                return {allOf: [...schemas]}\n              }\n              combinedSchema.type = combinedTypes.length > 1 ? combinedTypes : combinedTypes[0]\n            } else {\n              return {allOf: [...schemas]}\n            }\n            break\n          case 'uniqueItems':\n            // Set true if either true\n            combinedSchema.uniqueItems = !!combinedValue || !!schemaValue\n            break\n          default:\n            return {allOf: [...schemas]}\n        }\n      }\n    }\n  }\n  return combinedSchema\n}\n","import {isArray, isObject} from '../validator'\nimport {mergeSchemas} from '../merge-schemas'\n\n/**\n * 'combineAllOf' function\n *\n * Attempt to convert an allOf schema object into\n * a non-allOf schema object with equivalent rules.\n *\n * @param  schema - allOf schema object\n * @return converted schema object\n */\nexport function combineAllOf(schema: any) {\n  if (!isObject(schema) || !isArray(schema.allOf)) {\n    return schema\n  }\n  let mergedSchema = mergeSchemas(...schema.allOf)\n  if (Object.keys(schema).length > 1) {\n    const extraKeys = {...schema}\n    delete extraKeys.allOf\n    mergedSchema = mergeSchemas(mergedSchema, extraKeys)\n  }\n  return mergedSchema\n}\n","import {isArray} from '../validator'\nimport {hasOwn} from '../utility'\nimport * as _ from 'lodash'\n\n/**\n * 'fixRequiredArrayProperties' function\n *\n * Fixes an incorrectly placed required list inside an array schema, by moving\n * it into items.properties or additionalItems.properties, where it belongs.\n *\n * @param  schema - allOf schema object\n * @return converted schema object\n */\nexport function fixRequiredArrayProperties(schema: any) {\n  if (schema.type === 'array' && isArray(schema.required)) {\n    const itemsObject = hasOwn(schema.items, 'properties') ? 'items' :\n      hasOwn(schema.additionalItems, 'properties') ? 'additionalItems' : null\n    if (itemsObject && !hasOwn(schema[itemsObject], 'required') && (\n      hasOwn(schema[itemsObject], 'additionalProperties') ||\n      schema.required.every(key => hasOwn(schema[itemsObject].properties, key))\n    )) {\n      schema = _.cloneDeep(schema)\n      schema[itemsObject].required = schema.required\n      delete schema.required\n    }\n  }\n  return schema\n}\n","import {isObject} from '../validator'\nimport {forEach, hasOwn} from '../utility'\n\n/**\n * 'getControlValidators' function\n */\nexport function getControlValidators(schema: any) {\n  if (!isObject(schema)) {\n    return null\n  }\n  const validators: any = {}\n  if (hasOwn(schema, 'type')) {\n    switch (schema.type) {\n      case 'string':\n        forEach(['pattern', 'format', 'minLength', 'maxLength'], (prop) => {\n          if (hasOwn(schema, prop)) {\n            validators[prop] = [schema[prop]]\n          }\n        })\n        break\n      case 'number':\n      case 'integer':\n        forEach(['Minimum', 'Maximum'], (ucLimit) => {\n          const eLimit = 'exclusive' + ucLimit\n          const limit = ucLimit.toLowerCase()\n          if (hasOwn(schema, limit)) {\n            const exclusive = hasOwn(schema, eLimit) && schema[eLimit] === true\n            validators[limit] = [schema[limit], exclusive]\n          }\n        })\n        forEach(['multipleOf', 'type'], (prop) => {\n          if (hasOwn(schema, prop)) {\n            validators[prop] = [schema[prop]]\n          }\n        })\n        break\n      case 'object':\n        forEach(['minProperties', 'maxProperties', 'dependencies'], (prop) => {\n          if (hasOwn(schema, prop)) {\n            validators[prop] = [schema[prop]]\n          }\n        })\n        break\n      case 'array':\n        forEach(['minItems', 'maxItems', 'uniqueItems'], (prop) => {\n          if (hasOwn(schema, prop)) {\n            validators[prop] = [schema[prop]]\n          }\n        })\n        break\n    }\n  }\n  if (hasOwn(schema, 'enum')) {\n    validators.enum = [schema.enum]\n  }\n  return validators\n}\n","import {JsonPointer, Pointer} from '../jsonpointer.functions'\nimport {hasOwn} from '../utility'\nimport {isArray, isObject} from '../validator'\n\n/**\n * 'getFromSchema' function\n *\n * Uses a JSON Pointer for a value within a data object to retrieve\n * the schema for that value within schema for the data object.\n *\n * The optional third parameter can also be set to return something else:\n * 'schema' (default): the schema for the value indicated by the data pointer\n * 'parentSchema': the schema for the value's parent object or array\n * 'schemaPointer': a pointer to the value's schema within the object's schema\n * 'parentSchemaPointer': a pointer to the schema for the value's parent object or array\n *\n * @param  schema - The schema to get the sub-schema from\n * @param  dataPointer - JSON Pointer (string or array)\n * @param  returnType - what to return?\n * @return The located sub-schema\n */\nexport function getFromSchema(\n  schema: any,\n  dataPointer: Pointer,\n  returnType = 'schema'\n) {\n  const dataPointerArray: any[] = JsonPointer.parse(dataPointer)\n  if (dataPointerArray === null) {\n    console.error(`getFromSchema error: Invalid JSON Pointer: ${dataPointer}`)\n    return null\n  }\n  let subSchema = schema\n  const schemaPointer = []\n  const length = dataPointerArray.length\n  if (returnType.slice(0, 6) === 'parent') {\n    dataPointerArray.length--\n  }\n  for (let i = 0; i < length; ++i) {\n    const parentSchema = subSchema\n    const key = dataPointerArray[i]\n    let subSchemaFound = false\n    if (typeof subSchema !== 'object') {\n      console.error(`getFromSchema error: Unable to find \"${key}\" key in schema.`)\n      console.error(schema)\n      console.error(dataPointer)\n      return null\n    }\n    if (subSchema.type === 'array' && (!isNaN(key) || key === '-')) {\n      if (hasOwn(subSchema, 'items')) {\n        if (isObject(subSchema.items)) {\n          subSchemaFound = true\n          subSchema = subSchema.items\n          schemaPointer.push('items')\n        } else if (isArray(subSchema.items)) {\n          if (!isNaN(key) && subSchema.items.length >= +key) {\n            subSchemaFound = true\n            subSchema = subSchema.items[+key]\n            schemaPointer.push('items', key)\n          }\n        }\n      }\n      if (!subSchemaFound && isObject(subSchema.additionalItems)) {\n        subSchemaFound = true\n        subSchema = subSchema.additionalItems\n        schemaPointer.push('additionalItems')\n      } else if (subSchema.additionalItems !== false) {\n        subSchemaFound = true\n        subSchema = {}\n        schemaPointer.push('additionalItems')\n      }\n    } else if (subSchema.type === 'object') {\n      if (isObject(subSchema.properties) && hasOwn(subSchema.properties, key)) {\n        subSchemaFound = true\n        subSchema = subSchema.properties[key]\n        schemaPointer.push('properties', key)\n      } else if (isObject(subSchema.additionalProperties)) {\n        subSchemaFound = true\n        subSchema = subSchema.additionalProperties\n        schemaPointer.push('additionalProperties')\n      } else if (subSchema.additionalProperties !== false) {\n        subSchemaFound = true\n        subSchema = {}\n        schemaPointer.push('additionalProperties')\n      }\n    }\n    if (!subSchemaFound) {\n      console.error(`getFromSchema error: Unable to find \"${key}\" item in schema.`)\n      console.error(schema)\n      console.error(dataPointer)\n      return\n    }\n  }\n  return returnType.slice(-7) === 'Pointer' ? schemaPointer : subSchema\n}\n","import {isArray} from '../validator'\nimport {hasOwn} from '../utility'\n\n/**\n * 'getTitleMapFromOneOf' function\n */\nexport function getTitleMapFromOneOf(\n  schema: any = {},\n  flatList: boolean = null,\n  validateOnly = false\n) {\n  let titleMap = null\n  const oneOf = schema.oneOf || schema.anyOf || null\n  if (isArray(oneOf) && oneOf.every(item => item.title)) {\n    if (oneOf.every(item => isArray(item.enum) && item.enum.length === 1)) {\n      if (validateOnly) {\n        return true\n      }\n      titleMap = oneOf.map(item => ({name: item.title, value: item.enum[0]}))\n    } else if (oneOf.every(item => item.const)) {\n      if (validateOnly) {\n        return true\n      }\n      titleMap = oneOf.map(item => ({name: item.title, value: item.const}))\n    }\n\n    // if flatList !== false and some items have colons, make grouped map\n    if (flatList !== false && (titleMap || [])\n      .filter(title => ((title || {}).name || '').indexOf(': ')).length > 1\n    ) {\n\n      // Split name on first colon to create grouped map (name -> group: name)\n      const newTitleMap = titleMap.map(title => {\n        const [group, name] = title.name.split(/: (.+)/)\n        return group && name ? {...title, group, name} : title\n      })\n\n      // If flatList === true or at least one group has multiple items, use grouped map\n      if (flatList === true || newTitleMap.some((title, index) => index &&\n        hasOwn(title, 'group') && title.group === newTitleMap[index - 1].group\n      )) {\n        titleMap = newTitleMap\n      }\n    }\n  }\n  return validateOnly ? false : titleMap\n}\n","import {JsonPointer} from '../jsonpointer.functions'\nimport {inArray, isArray, isString} from '../validator'\nimport {hasOwn} from '../utility'\nimport {checkInlineType} from './checkInlineType'\nimport {getTitleMapFromOneOf} from './getTitleMapFromOneOf'\n\n/**\n * 'getInputType' function\n */\nexport function getInputType(\n  schema: any,\n  layoutNode: any = null\n): string {\n  // x-schema-form = Angular Schema Form compatibility\n  // widget & component = React Jsonschema Form compatibility\n  const controlType = JsonPointer.getFirst([\n    [schema, '/x-schema-form/type'],\n    [schema, '/x-schema-form/widget/component'],\n    [schema, '/x-schema-form/widget'],\n    [schema, '/widget/component'],\n    [schema, '/widget']\n  ])\n  if (isString(controlType)) {\n    return checkInlineType(controlType, schema, layoutNode)\n  }\n  let schemaType = schema.type\n  if (schemaType) {\n    if (isArray(schemaType)) { // If multiple types listed, use most inclusive type\n      schemaType =\n        inArray('object', schemaType) && hasOwn(schema, 'properties') ? 'object' :\n          inArray('array', schemaType) && hasOwn(schema, 'items') ? 'array' :\n            inArray('array', schemaType) && hasOwn(schema, 'additionalItems') ? 'array' :\n              inArray('string', schemaType) ? 'string' :\n                inArray('number', schemaType) ? 'number' :\n                  inArray('integer', schemaType) ? 'integer' :\n                    inArray('boolean', schemaType) ? 'boolean' : 'unknown'\n    }\n    if (schemaType === 'boolean') {\n      return 'checkbox'\n    }\n    if (schemaType === 'object') {\n      if (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) {\n        return 'section'\n      }\n      // TODO: Figure out how to handle additionalProperties\n      if (hasOwn(schema, '$ref')) {\n        return '$ref'\n      }\n    }\n    if (schemaType === 'array') {\n      const itemsObject = JsonPointer.getFirst([\n        [schema, '/items'],\n        [schema, '/additionalItems']\n      ]) || {}\n      return hasOwn(itemsObject, 'enum') && schema.maxItems !== 1 ?\n        checkInlineType('checkboxes', schema, layoutNode) : 'array'\n    }\n    if (schemaType === 'null') {\n      return 'none'\n    }\n    if (JsonPointer.has(layoutNode, '/options/titleMap') ||\n      hasOwn(schema, 'enum') || getTitleMapFromOneOf(schema, null, true)\n    ) {\n      return 'select'\n    }\n    if (schemaType === 'number' || schemaType === 'integer') {\n      return (schemaType === 'integer' || hasOwn(schema, 'multipleOf')) &&\n      hasOwn(schema, 'maximum') && hasOwn(schema, 'minimum') ? 'range' : schemaType\n    }\n    if (schemaType === 'string') {\n      return {\n        color: 'color',\n        date: 'date',\n        'date-time': 'datetime-local',\n        email: 'email',\n        uri: 'url',\n      }[schema.format] || 'text'\n    }\n  }\n  if (hasOwn(schema, '$ref')) {\n    return '$ref'\n  }\n  if (isArray(schema.oneOf) || isArray(schema.anyOf)) {\n    return 'one-of'\n  }\n  console.error(`getInputType error: Unable to determine input type for ${schemaType}`)\n  console.error('schema', schema)\n  if (layoutNode) {\n    console.error('layoutNode', layoutNode)\n  }\n  return 'none'\n}\n","import {JsonPointer, Pointer} from '../jsonpointer.functions'\n\n/**\n * 'removeRecursiveReferences' function\n *\n * Checks a JSON Pointer against a map of recursive references and returns\n * a JSON Pointer to the shallowest equivalent location in the same object.\n *\n * Using this functions enables an object to be constructed with unlimited\n * recursion, while maintaing a fixed set of metadata, such as field data types.\n * The object can grow as large as it wants, and deeply recursed nodes can\n * just refer to the metadata for their shallow equivalents, instead of having\n * to add additional redundant metadata for each recursively added node.\n *\n * Example:\n *\n * pointer:         '/stuff/and/more/and/more/and/more/and/more/stuff'\n * recursiveRefMap: [['/stuff/and/more/and/more', '/stuff/and/more/']]\n * returned:        '/stuff/and/more/stuff'\n */\nexport function removeRecursiveReferences(\n  pointer: Pointer,\n  recursiveRefMap: Map<string, string>,\n  arrayMap:Map<string, number> = new Map()\n): string {\n  if (!pointer) {\n    return ''\n  }\n  let genericPointer =\n    JsonPointer.toGenericPointer(JsonPointer.compile(pointer), arrayMap)\n  if (genericPointer.indexOf('/') === -1) {\n    return genericPointer\n  }\n  let possibleReferences = true\n  while (possibleReferences) {\n    possibleReferences = false\n    recursiveRefMap.forEach((toPointer, fromPointer) => {\n      if (JsonPointer.isSubPointer(toPointer, fromPointer)) {\n        while (JsonPointer.isSubPointer(fromPointer, genericPointer, true)) {\n          genericPointer = JsonPointer.toGenericPointer(\n            toPointer + genericPointer.slice(fromPointer.length), arrayMap\n          )\n          possibleReferences = true\n        }\n      }\n    })\n  }\n  return genericPointer\n}\n","import {JsonPointer, Pointer} from '../jsonpointer.functions'\nimport {isArray, isObject, isString} from '../validator'\nimport {mergeSchemas} from '../merge-schemas'\nimport {combineAllOf} from './combineAllOf'\nimport {fixRequiredArrayProperties} from './fixRequiredArrayProperties'\nimport {removeRecursiveReferences} from './removeRecursiveReferences'\nimport * as _ from 'lodash'\n\n/**\n * 'getSubSchema' function\n */\nexport function getSubSchema(\n  schema: any,\n  pointerArg: Pointer | string,\n  schemaRefLibrary: object = null,\n  schemaRecursiveRefMap: Map<string, string> = null,\n  usedPointers: string[] = []\n) {\n  if (!schemaRefLibrary || !schemaRecursiveRefMap) {\n    return JsonPointer.getCopy(schema, pointerArg)\n  }\n  const pointer: string = typeof pointerArg !== 'string' ? JsonPointer.compile(pointerArg) : pointerArg\n\n  usedPointers = [...usedPointers, pointer]\n  let newSchema: any = null\n  if (pointer === '') {\n    newSchema = _.cloneDeep(schema)\n  } else {\n    const shortPointer = removeRecursiveReferences(pointer, schemaRecursiveRefMap)\n    if (shortPointer !== pointer) {\n      usedPointers = [...usedPointers, shortPointer]\n    }\n    newSchema = JsonPointer.getFirstCopy([\n      [schemaRefLibrary, [shortPointer]],\n      [schema, pointer],\n      [schema, shortPointer]\n    ])\n  }\n  return JsonPointer.forEachDeepCopy(newSchema, (subSchema, subPointer) => {\n    if (isObject(subSchema)) {\n      // Replace non-recursive $ref links with referenced schemas\n      if (isString(subSchema.$ref)) {\n        const refPointer = JsonPointer.compile(subSchema.$ref)\n        if (refPointer.length && usedPointers.every(ptr =>\n          !JsonPointer.isSubPointer(refPointer, ptr, true)\n        )) {\n          const refSchema = getSubSchema(\n            schema, refPointer, schemaRefLibrary, schemaRecursiveRefMap, usedPointers\n          )\n          if (Object.keys(subSchema).length === 1) {\n            return refSchema\n          } else {\n            const extraKeys = {...subSchema}\n            delete extraKeys.$ref\n            return mergeSchemas(refSchema, extraKeys)\n          }\n        }\n      }\n\n      // TODO: Convert schemas with 'type' arrays to 'oneOf'\n\n      // Combine allOf subSchemas\n      if (isArray(subSchema.allOf)) {\n        return combineAllOf(subSchema)\n      }\n\n      // Fix incorrectly placed array object required lists\n      if (subSchema.type === 'array' && isArray(subSchema.required)) {\n        return fixRequiredArrayProperties(subSchema)\n      }\n    }\n    return subSchema\n  }, true, pointer)\n}\n","import {isArray, isNumber, isObject} from '../validator'\nimport {JsonPointer} from '../jsonpointer.functions'\nimport {hasOwn} from '../utility'\n\n/**\n * 'isInputRequired' function\n *\n * Checks a JSON Schema to see if an item is required\n *\n * @param schema - the schema to check\n * @param schemaPointer - the pointer to the item to check\n * @return true if the item is required, false if not\n */\nexport function isInputRequired(\n  schema: any,\n  schemaPointer: string\n): boolean {\n  if (!isObject(schema)) {\n    console.error('isInputRequired error: Input schema must be an object.')\n    return false\n  }\n  const listPointerArray = JsonPointer.parse(schemaPointer)\n  if (isArray(listPointerArray)) {\n    if (!listPointerArray.length) {\n      return schema.required === true\n    }\n    const keyName = listPointerArray.pop()\n    const nextToLastKey = listPointerArray[listPointerArray.length - 1]\n    if (['properties', 'additionalProperties', 'patternProperties', 'items', 'additionalItems']\n      .includes(nextToLastKey)\n    ) {\n      listPointerArray.pop()\n    }\n    const parentSchema = JsonPointer.get(schema, listPointerArray) || {}\n    if (isArray(parentSchema.required)) {\n      return parentSchema.required.includes(keyName)\n    }\n    if (parentSchema.type === 'array') {\n      return hasOwn(parentSchema, 'minItems') &&\n        isNumber(keyName) &&\n        +parentSchema.minItems > +keyName\n    }\n  }\n  return false\n}\n","import {isArray, isObject, isString} from '../validator'\nimport {JsonPointer} from '../jsonpointer.functions'\nimport {hasOwn} from '../utility'\nimport {getSubSchema} from './getSubSchema'\nimport {removeRecursiveReferences} from './removeRecursiveReferences'\n\n/**\n * 'resolveSchemaReferences' function\n *\n * Find all $ref links in schema and save links and referenced schemas in\n * schemaRefLibrary, schemaRecursiveRefMap, and dataRecursiveRefMap\n */\nexport function resolveSchemaReferences(\n  schema: any,\n  schemaRefLibrary: any,\n  schemaRecursiveRefMap: Map<string, string>,\n  dataRecursiveRefMap: Map<string, string>,\n  arrayMap: Map<string, number>\n) {\n  if (!isObject(schema)) {\n    console.error('resolveSchemaReferences error: schema must be an object.')\n    return\n  }\n  const refLinks = new Set<string>()\n  const refMapSet = new Set<string>()\n  const refMap = new Map<string, string>()\n  const recursiveRefMap = new Map<string, string>()\n  const refLibrary: any = {}\n\n  // Search schema for all $ref links, and build full refLibrary\n  JsonPointer.forEachDeep(schema, (subSchema, subSchemaPointer) => {\n    if (hasOwn(subSchema, '$ref') && isString(subSchema.$ref)) {\n      const refPointer = JsonPointer.compile(subSchema.$ref)\n      refLinks.add(refPointer)\n      refMapSet.add(subSchemaPointer + '~~' + refPointer)\n      refMap.set(subSchemaPointer, refPointer)\n    }\n  })\n  refLinks.forEach(ref => refLibrary[ref] = getSubSchema(schema, ref))\n\n  // Follow all ref links and save in refMapSet,\n  // to find any multi-link recursive refernces\n  let checkRefLinks = true\n  while (checkRefLinks) {\n    checkRefLinks = false\n    Array.from(refMap).forEach(([fromRef1, toRef1]) => Array.from(refMap)\n      .filter(([fromRef2, toRef2]) =>\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef2, toRef1, true) &&\n        !refMapSet.has(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2)\n      )\n      .forEach(([fromRef2, toRef2]) => {\n        refMapSet.add(fromRef1 + fromRef2.slice(toRef1.length) + '~~' + toRef2)\n        checkRefLinks = true\n      })\n    )\n  }\n\n  // Build full recursiveRefMap\n  // First pass - save all internally recursive refs from refMapSet\n  Array.from(refMapSet)\n    .map(refLink => refLink.split('~~'))\n    .filter(([fromRef, toRef]) => JsonPointer.isSubPointer(toRef, fromRef))\n    .forEach(([fromRef, toRef]) => recursiveRefMap.set(fromRef, toRef))\n  // Second pass - create recursive versions of any other refs that link to recursive refs\n  Array.from(refMap)\n    .filter(([fromRef1, toRef1]) => Array.from(recursiveRefMap.keys())\n      .every(fromRef2 => !JsonPointer.isSubPointer(fromRef1, fromRef2, true))\n    )\n    .forEach(([fromRef1, toRef1]) => Array.from(recursiveRefMap)\n      .filter(([fromRef2, toRef2]) =>\n        !recursiveRefMap.has(fromRef1 + fromRef2.slice(toRef1.length)) &&\n        JsonPointer.isSubPointer(toRef1, fromRef2, true) &&\n        !JsonPointer.isSubPointer(toRef1, fromRef1, true)\n      )\n      .forEach(([fromRef2, toRef2]) => recursiveRefMap.set(\n        fromRef1 + fromRef2.slice(toRef1.length),\n        fromRef1 + toRef2.slice(toRef1.length)\n      ))\n    )\n\n  // Create compiled schema by replacing all non-recursive $ref links with\n  // thieir linked schemas and, where possible, combining schemas in allOf arrays.\n  let compiledSchema = {...schema}\n  delete compiledSchema.definitions\n  compiledSchema =\n    getSubSchema(compiledSchema, '', refLibrary, recursiveRefMap)\n\n  // Make sure all remaining schema $refs are recursive, and build final\n  // schemaRefLibrary, schemaRecursiveRefMap, dataRecursiveRefMap, & arrayMap\n  JsonPointer.forEachDeep(compiledSchema, (subSchema, subSchemaPointer) => {\n    if (isString(subSchema.$ref)) {\n      let refPointer = JsonPointer.compile(subSchema.$ref)\n      if (!JsonPointer.isSubPointer(refPointer, subSchemaPointer, true)) {\n        refPointer = removeRecursiveReferences(subSchemaPointer, recursiveRefMap)\n        JsonPointer.set(compiledSchema, subSchemaPointer, {$ref: `#${refPointer}`})\n      }\n      if (!hasOwn(schemaRefLibrary, 'refPointer')) {\n        schemaRefLibrary[refPointer] = !refPointer.length ? compiledSchema :\n          getSubSchema(compiledSchema, refPointer, schemaRefLibrary, recursiveRefMap)\n      }\n      if (!schemaRecursiveRefMap.has(subSchemaPointer)) {\n        schemaRecursiveRefMap.set(subSchemaPointer, refPointer)\n      }\n      const fromDataRef = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema) as any\n      if (!dataRecursiveRefMap.has(fromDataRef)) {\n        const toDataRef = JsonPointer.toDataPointer(refPointer, compiledSchema) as any\n        dataRecursiveRefMap.set(fromDataRef, toDataRef)\n      }\n    }\n    if (subSchema.type === 'array' &&\n      (hasOwn(subSchema, 'items') || hasOwn(subSchema, 'additionalItems'))\n    ) {\n      const dataPointer = JsonPointer.toDataPointer(subSchemaPointer, compiledSchema) as any\n      if (!arrayMap.has(dataPointer)) {\n        const tupleItems = isArray(subSchema.items) ? subSchema.items.length : 0\n        arrayMap.set(dataPointer, tupleItems)\n      }\n    }\n  }, true)\n  return compiledSchema\n}\n","import {hasValue, isObject} from '../validator'\nimport {hasOwn, mergeFilteredObject} from '../utility'\nimport {JsonPointer} from '../jsonpointer.functions'\nimport {getTitleMapFromOneOf} from './getTitleMapFromOneOf'\n\n/**\n * 'updateInputOptions' function\n */\nexport function updateInputOptions(\n  layoutNode: any,\n  schema: any,\n  jsf: any\n): void {\n  if (!isObject(layoutNode) || !isObject(layoutNode.options)) {\n    return\n  }\n\n  // Set all option values in layoutNode.options\n  const newOptions: any = {}\n  const fixUiKeys = key => key.slice(0, 3).toLowerCase() === 'ui:' ? key.slice(3) : key\n  mergeFilteredObject(newOptions, jsf.formOptions.defautWidgetOptions, [], fixUiKeys);\n  [[JsonPointer.get(schema, '/ui:widget/options'), []],\n    [JsonPointer.get(schema, '/ui:widget'), []],\n    [schema, [\n      'additionalProperties', 'additionalItems', 'properties', 'items',\n      'required', 'type', 'x-schema-form', '$ref'\n    ]],\n    [JsonPointer.get(schema, '/x-schema-form/options'), []],\n    [JsonPointer.get(schema, '/x-schema-form'), ['items', 'options']],\n    [layoutNode, [\n      '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n      'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n    ]],\n    [layoutNode.options, []],\n  ].forEach(([object, excludeKeys]) =>\n    mergeFilteredObject(newOptions, object, excludeKeys, fixUiKeys)\n  )\n  if (!hasOwn(newOptions, 'titleMap')) {\n    let newTitleMap: any = null\n    newTitleMap = getTitleMapFromOneOf(schema, newOptions.flatList)\n    if (newTitleMap) {\n      newOptions.titleMap = newTitleMap\n    }\n    if (!hasOwn(newOptions, 'titleMap') && !hasOwn(newOptions, 'enum') && hasOwn(schema, 'items')) {\n      if (JsonPointer.has(schema, '/items/titleMap')) {\n        newOptions.titleMap = schema.items.titleMap\n      } else if (JsonPointer.has(schema, '/items/enum')) {\n        newOptions.enum = schema.items.enum\n        if (!hasOwn(newOptions, 'enumNames') && JsonPointer.has(schema, '/items/enumNames')) {\n          newOptions.enumNames = schema.items.enumNames\n        }\n      } else if (JsonPointer.has(schema, '/items/oneOf')) {\n        newTitleMap = getTitleMapFromOneOf(schema.items, newOptions.flatList)\n        if (newTitleMap) {\n          newOptions.titleMap = newTitleMap\n        }\n      }\n    }\n  }\n\n  // If schema type is integer, enforce by setting multipleOf = 1\n  if (schema.type === 'integer' && !hasValue(newOptions.multipleOf)) {\n    newOptions.multipleOf = 1\n  }\n\n  // Copy any typeahead word lists to options.typeahead.source\n  if (JsonPointer.has(newOptions, '/autocomplete/source')) {\n    newOptions.typeahead = newOptions.autocomplete\n  } else if (JsonPointer.has(newOptions, '/tagsinput/source')) {\n    newOptions.typeahead = newOptions.tagsinput\n  } else if (JsonPointer.has(newOptions, '/tagsinput/typeahead/source')) {\n    newOptions.typeahead = newOptions.tagsinput.typeahead\n  }\n\n  layoutNode.options = newOptions\n}\n","import * as _ from 'lodash'\n\nexport interface OptionObject {\n  changed?: boolean\n  draft?: number\n}\n\n/**\n * 'convertSchemaToDraft6' function\n *\n * Converts a JSON Schema from draft 1 through 4 format to draft 6 format\n *\n * Inspired by on geraintluff's JSON Schema 3 to 4 compatibility function:\n *   https://github.com/geraintluff/json-schema-compatibility\n * Also uses suggestions from AJV's JSON Schema 4 to 6 migration guide:\n *   https://github.com/epoberezkin/ajv/releases/tag/5.0.0\n * And additional details from the official JSON Schema documentation:\n *   http://json-schema.org\n *\n * @param schema - JSON schema (draft 1, 2, 3, 4, or 6)\n * @param options - options: parent schema changed?, schema draft number?\n * @return JSON schema (draft 6)\n */\nexport function convertSchemaToDraft6(\n  schema: any,\n  options: OptionObject = {}\n) {\n  let draft: number = options.draft || null\n  let changed: boolean = options.changed || false\n\n  if (typeof schema !== 'object') {\n    return schema\n  }\n  if (typeof schema.map === 'function') {\n    return [...schema.map(subSchema => convertSchemaToDraft6(subSchema, {changed, draft}))]\n  }\n  let newSchema = {...schema}\n  const simpleTypes = ['array', 'boolean', 'integer', 'null', 'number', 'object', 'string']\n\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0\\d\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    draft = newSchema.$schema[30]\n  }\n\n  // Convert v1-v2 'contentEncoding' to 'media.binaryEncoding'\n  // Note: This is only used in JSON hyper-schema (not regular JSON schema)\n  if (newSchema.contentEncoding) {\n    newSchema.media = {binaryEncoding: newSchema.contentEncoding}\n    delete newSchema.contentEncoding\n    changed = true\n  }\n\n  // Convert v1-v3 'extends' to 'allOf'\n  if (typeof newSchema.extends === 'object') {\n    newSchema.allOf = typeof newSchema.extends.map === 'function' ?\n      newSchema.extends.map(subSchema => convertSchemaToDraft6(subSchema, {changed, draft})) :\n      [convertSchemaToDraft6(newSchema.extends, {changed, draft})]\n    delete newSchema.extends\n    changed = true\n  }\n\n  // Convert v1-v3 'disallow' to 'not'\n  if (newSchema.disallow) {\n    if (typeof newSchema.disallow === 'string') {\n      newSchema.not = {type: newSchema.disallow}\n    } else if (typeof newSchema.disallow.map === 'function') {\n      newSchema.not = {\n        anyOf: newSchema.disallow\n          .map(type => typeof type === 'object' ? type : {type})\n      }\n    }\n    delete newSchema.disallow\n    changed = true\n  }\n\n  // Convert v3 string 'dependencies' properties to arrays\n  if (typeof newSchema.dependencies === 'object' &&\n    Object.keys(newSchema.dependencies)\n      .some(key => typeof newSchema.dependencies[key] === 'string')\n  ) {\n    newSchema.dependencies = {...newSchema.dependencies}\n    Object.keys(newSchema.dependencies)\n      .filter(key => typeof newSchema.dependencies[key] === 'string')\n      .forEach(key => newSchema.dependencies[key] = [newSchema.dependencies[key]])\n    changed = true\n  }\n\n  // Convert v1 'maxDecimal' to 'multipleOf'\n  if (typeof newSchema.maxDecimal === 'number') {\n    newSchema.multipleOf = 1 / Math.pow(10, newSchema.maxDecimal)\n    delete newSchema.divisibleBy\n    changed = true\n    if (!draft || draft === 2) {\n      draft = 1\n    }\n  }\n\n  // Convert v2-v3 'divisibleBy' to 'multipleOf'\n  if (typeof newSchema.divisibleBy === 'number') {\n    newSchema.multipleOf = newSchema.divisibleBy\n    delete newSchema.divisibleBy\n    changed = true\n  }\n\n  // Convert v1-v2 boolean 'minimumCanEqual' to 'exclusiveMinimum'\n  if (typeof newSchema.minimum === 'number' && newSchema.minimumCanEqual === false) {\n    newSchema.exclusiveMinimum = newSchema.minimum\n    delete newSchema.minimum\n    changed = true\n    if (!draft) {\n      draft = 2\n    }\n  } else if (typeof newSchema.minimumCanEqual === 'boolean') {\n    delete newSchema.minimumCanEqual\n    changed = true\n    if (!draft) {\n      draft = 2\n    }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMinimum' to numeric\n  if (typeof newSchema.minimum === 'number' && newSchema.exclusiveMinimum === true) {\n    newSchema.exclusiveMinimum = newSchema.minimum\n    delete newSchema.minimum\n    changed = true\n  } else if (typeof newSchema.exclusiveMinimum === 'boolean') {\n    delete newSchema.exclusiveMinimum\n    changed = true\n  }\n\n  // Convert v1-v2 boolean 'maximumCanEqual' to 'exclusiveMaximum'\n  if (typeof newSchema.maximum === 'number' && newSchema.maximumCanEqual === false) {\n    newSchema.exclusiveMaximum = newSchema.maximum\n    delete newSchema.maximum\n    changed = true\n    if (!draft) {\n      draft = 2\n    }\n  } else if (typeof newSchema.maximumCanEqual === 'boolean') {\n    delete newSchema.maximumCanEqual\n    changed = true\n    if (!draft) {\n      draft = 2\n    }\n  }\n\n  // Convert v3-v4 boolean 'exclusiveMaximum' to numeric\n  if (typeof newSchema.maximum === 'number' && newSchema.exclusiveMaximum === true) {\n    newSchema.exclusiveMaximum = newSchema.maximum\n    delete newSchema.maximum\n    changed = true\n  } else if (typeof newSchema.exclusiveMaximum === 'boolean') {\n    delete newSchema.exclusiveMaximum\n    changed = true\n  }\n\n  // Search object 'properties' for 'optional', 'required', and 'requires' items,\n  // and convert them into object 'required' arrays and 'dependencies' objects\n  if (typeof newSchema.properties === 'object') {\n    const properties = {...newSchema.properties}\n    const requiredKeys = Array.isArray(newSchema.required) ?\n      new Set(newSchema.required) : new Set()\n\n    // Convert v1-v2 boolean 'optional' properties to 'required' array\n    if (draft === 1 || draft === 2 ||\n      Object.keys(properties).some(key => properties[key].optional === true)\n    ) {\n      Object.keys(properties)\n        .filter(key => properties[key].optional !== true)\n        .forEach(key => requiredKeys.add(key))\n      changed = true\n      if (!draft) {\n        draft = 2\n      }\n    }\n\n    // Convert v3 boolean 'required' properties to 'required' array\n    if (Object.keys(properties).some(key => properties[key].required === true)) {\n      Object.keys(properties)\n        .filter(key => properties[key].required === true)\n        .forEach(key => requiredKeys.add(key))\n      changed = true\n    }\n\n    if (requiredKeys.size) {\n      newSchema.required = Array.from(requiredKeys)\n    }\n\n    // Convert v1-v2 array or string 'requires' properties to 'dependencies' object\n    if (Object.keys(properties).some(key => properties[key].requires)) {\n      const dependencies = typeof newSchema.dependencies === 'object' ?\n        {...newSchema.dependencies} : {}\n      Object.keys(properties)\n        .filter(key => properties[key].requires)\n        .forEach(key => dependencies[key] =\n          typeof properties[key].requires === 'string' ?\n            [properties[key].requires] : properties[key].requires\n        )\n      newSchema.dependencies = dependencies\n      changed = true\n      if (!draft) {\n        draft = 2\n      }\n    }\n\n    newSchema.properties = properties\n  }\n\n  // Revove v1-v2 boolean 'optional' key\n  if (typeof newSchema.optional === 'boolean') {\n    delete newSchema.optional\n    changed = true\n    if (!draft) {\n      draft = 2\n    }\n  }\n\n  // Revove v1-v2 'requires' key\n  if (newSchema.requires) {\n    delete newSchema.requires\n  }\n\n  // Revove v3 boolean 'required' key\n  if (typeof newSchema.required === 'boolean') {\n    delete newSchema.required\n  }\n\n  // Convert id to $id\n  if (typeof newSchema.id === 'string' && !newSchema.$id) {\n    if (newSchema.id.slice(-1) === '#') {\n      newSchema.id = newSchema.id.slice(0, -1)\n    }\n    newSchema.$id = newSchema.id + '-CONVERTED-TO-DRAFT-06#'\n    delete newSchema.id\n    changed = true\n  }\n\n  // Check if v1-v3 'any' or object types will be converted\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n      !newSchema.type.every(type => simpleTypes.includes(type)) :\n      !simpleTypes.includes(newSchema.type)\n  )) {\n    changed = true\n  }\n\n  // If schema changed, update or remove $schema identifier\n  if (typeof newSchema.$schema === 'string' &&\n    /http\\:\\/\\/json\\-schema\\.org\\/draft\\-0[1-4]\\/schema\\#/.test(newSchema.$schema)\n  ) {\n    newSchema.$schema = 'http://json-schema.org/draft-06/schema#'\n    changed = true\n  } else if (changed && typeof newSchema.$schema === 'string') {\n    const addToDescription = 'Converted to draft 6 from ' + newSchema.$schema\n    if (typeof newSchema.description === 'string' && newSchema.description.length) {\n      newSchema.description += '\\n' + addToDescription\n    } else {\n      newSchema.description = addToDescription\n    }\n    delete newSchema.$schema\n  }\n\n  // Convert v1-v3 'any' and object types\n  if (newSchema.type && (typeof newSchema.type.every === 'function' ?\n      !newSchema.type.every(type => simpleTypes.includes(type)) :\n      !simpleTypes.includes(newSchema.type)\n  )) {\n    if (newSchema.type.length === 1) {\n      newSchema.type = newSchema.type[0]\n    }\n    if (typeof newSchema.type === 'string') {\n      // Convert string 'any' type to array of all standard types\n      if (newSchema.type === 'any') {\n        newSchema.type = simpleTypes\n        // Delete non-standard string type\n      } else {\n        delete newSchema.type\n      }\n    } else if (typeof newSchema.type === 'object') {\n      if (typeof newSchema.type.every === 'function') {\n        // If array of strings, only allow standard types\n        if (newSchema.type.every(type => typeof type === 'string')) {\n          newSchema.type = newSchema.type.some(type => type === 'any') ?\n            newSchema.type = simpleTypes :\n            newSchema.type.filter(type => simpleTypes.includes(type))\n          // If type is an array with objects, convert the current schema to an 'anyOf' array\n        } else if (newSchema.type.length > 1) {\n          const arrayKeys = ['additionalItems', 'items', 'maxItems', 'minItems', 'uniqueItems', 'contains']\n          const numberKeys = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum']\n          const objectKeys = ['maxProperties', 'minProperties', 'required', 'additionalProperties',\n            'properties', 'patternProperties', 'dependencies', 'propertyNames']\n          const stringKeys = ['maxLength', 'minLength', 'pattern', 'format']\n          const filterKeys = {\n            array: [...numberKeys, ...objectKeys, ...stringKeys],\n            integer: [...arrayKeys, ...objectKeys, ...stringKeys],\n            number: [...arrayKeys, ...objectKeys, ...stringKeys],\n            object: [...arrayKeys, ...numberKeys, ...stringKeys],\n            string: [...arrayKeys, ...numberKeys, ...objectKeys],\n            all: [...arrayKeys, ...numberKeys, ...objectKeys, ...stringKeys],\n          }\n          const anyOf = []\n          for (const type of newSchema.type) {\n            const newType = typeof type === 'string' ? {type} : {...type}\n            Object.keys(newSchema)\n              .filter(key => !newType.hasOwnProperty(key) &&\n                ![...(filterKeys[newType.type] || filterKeys.all), 'type', 'default']\n                  .includes(key)\n              )\n              .forEach(key => newType[key] = newSchema[key])\n            anyOf.push(newType)\n          }\n          newSchema = newSchema.hasOwnProperty('default') ?\n            {anyOf, default: newSchema.default} : {anyOf}\n          // If type is an object, merge it with the current schema\n        } else {\n          const typeSchema = newSchema.type\n          delete newSchema.type\n          Object.assign(newSchema, typeSchema)\n        }\n      }\n    } else {\n      delete newSchema.type\n    }\n  }\n\n  // Convert sub schemas\n  Object.keys(newSchema)\n    .filter(key => typeof newSchema[key] === 'object')\n    .forEach(key => {\n      if (\n        ['definitions', 'dependencies', 'properties', 'patternProperties']\n          .includes(key) && typeof newSchema[key].map !== 'function'\n      ) {\n        const newKey = {}\n        Object.keys(newSchema[key]).forEach(subKey => newKey[subKey] =\n          convertSchemaToDraft6(newSchema[key][subKey], {changed, draft})\n        )\n        newSchema[key] = newKey\n      } else if (\n        ['items', 'additionalItems', 'additionalProperties',\n          'allOf', 'anyOf', 'oneOf', 'not'].includes(key)\n      ) {\n        newSchema[key] = convertSchemaToDraft6(newSchema[key], {changed, draft})\n      } else {\n        newSchema[key] = _.cloneDeep(newSchema[key])\n      }\n    })\n\n  return newSchema\n}\n","import {AbstractControl, FormArray, FormControl, FormGroup, ValidatorFn} from '@angular/forms'\nimport {forEach, hasOwn} from '../utility'\nimport {JsonValidators} from '../../json.validators'\nimport {inArray} from '../validator'\nimport * as _ from 'lodash'\n\n/**\n * 'buildFormGroup' function\n */\nexport function buildFormGroup(template: any): AbstractControl {\n  const validatorFns: ValidatorFn[] = []\n  let validatorFn: ValidatorFn = null\n  if (hasOwn(template, 'validators')) {\n    forEach(template.validators, (parameters, validator) => {\n      if (typeof JsonValidators[validator] === 'function') {\n        validatorFns.push(JsonValidators[validator].apply(null, parameters))\n      }\n    })\n    if (validatorFns.length &&\n      inArray(template.controlType, ['FormGroup', 'FormArray'])\n    ) {\n      validatorFn = validatorFns.length > 1 ?\n        JsonValidators.compose(validatorFns) : validatorFns[0]\n    }\n  }\n  if (hasOwn(template, 'controlType')) {\n    switch (template.controlType) {\n      case 'FormGroup':\n        const groupControls: { [key: string]: AbstractControl } = {}\n        forEach(template.controls, (controls, key) => {\n          const newControl: AbstractControl = buildFormGroup(controls)\n          if (newControl) {\n            groupControls[key] = newControl\n          }\n        })\n        return new FormGroup(groupControls, validatorFn)\n      case 'FormArray':\n        return new FormArray(_.filter(_.map(template.controls,\n          controls => buildFormGroup(controls)\n        )), validatorFn)\n      case 'FormControl':\n        return new FormControl(template.value, validatorFns)\n    }\n  }\n  return null\n}\n","import {forEach, hasOwn} from '../utility'\nimport {isArray, isEmpty} from '../validator'\nimport {JsonPointer} from '../jsonpointer.functions'\n\n/**\n * 'setRequiredFields' function\n *\n * @param schema - JSON Schema\n * @param formControlTemplate - Form Control Template object\n * @return true if any fields have been set to required, false if not\n */\nexport function setRequiredFields(\n  schema: any,\n  formControlTemplate: any\n): boolean {\n  let fieldsRequired = false\n  if (hasOwn(schema, 'required') && !isEmpty(schema.required)) {\n    fieldsRequired = true\n    let requiredArray = isArray(schema.required) ? schema.required : [schema.required]\n    requiredArray = forEach(requiredArray,\n      key => JsonPointer.set(formControlTemplate, '/' + key + '/validators/required', [])\n    )\n  }\n  return fieldsRequired\n\n  // TODO: Add support for patternProperties\n  // https://spacetelescope.github.io/understanding-json-schema/reference/object.html#pattern-properties\n}\n","import {JsonPointer} from '../jsonpointer.functions'\nimport {isArray, isDefined, isEmpty, isObject, isPrimitive} from '../validator'\nimport {hasOwn} from '../utility'\nimport {getControlValidators, removeRecursiveReferences} from '../json-schema'\nimport {setRequiredFields} from './setRequiredFields'\nimport * as _ from 'lodash'\n\n/**\n * 'buildFormGroupTemplate' function\n *\n * Builds a template for an Angular FormGroup from a JSON Schema.\n *\n * TODO: add support for pattern properties\n * https://spacetelescope.github.io/understanding-json-schema/reference/object.html\n */\nexport function buildFormGroupTemplate(\n  jsf: any,\n  nodeValue: any = null,\n  setValues = true,\n  schemaPointer = '',\n  dataPointer = '',\n  templatePointer = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer)\n  if (setValues) {\n    if (!isDefined(nodeValue) && (\n      jsf.formOptions.setSchemaDefaults === true ||\n      (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n    )) {\n      nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default')\n    }\n  } else {\n    nodeValue = null\n  }\n  // TODO: If nodeValue still not set, check layout for default value\n  const schemaType: string | string[] = JsonPointer.get(schema, '/type')\n  const controlType =\n    (hasOwn(schema, 'properties') || hasOwn(schema, 'additionalProperties')) &&\n    schemaType === 'object' ? 'FormGroup' :\n      (hasOwn(schema, 'items') || hasOwn(schema, 'additionalItems')) &&\n      schemaType === 'array' ? 'FormArray' :\n        !schemaType && hasOwn(schema, '$ref') ? '$ref' : 'FormControl'\n  const shortDataPointer =\n    removeRecursiveReferences(dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap)\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map())\n  }\n  const nodeOptions = jsf.dataMap.get(shortDataPointer)\n  if (!nodeOptions.has('schemaType')) {\n    nodeOptions.set('schemaPointer', schemaPointer)\n    nodeOptions.set('schemaType', schema.type)\n    if (schema.format) {\n      nodeOptions.set('schemaFormat', schema.format)\n      if (!schema.type) {\n        nodeOptions.set('schemaType', 'string')\n      }\n    }\n    if (controlType) {\n      nodeOptions.set('templatePointer', templatePointer)\n      nodeOptions.set('templateType', controlType)\n    }\n  }\n  let controls: any\n  const validators = getControlValidators(schema)\n  switch (controlType) {\n    case 'FormGroup':\n      controls = {}\n      if (hasOwn(schema, 'ui:order') || hasOwn(schema, 'properties')) {\n        const propertyKeys = schema['ui:order'] || Object.keys(schema.properties)\n        if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n          const unnamedKeys = Object.keys(schema.properties)\n            .filter(key => !propertyKeys.includes(key))\n          for (let i = propertyKeys.length - 1; i >= 0; i--) {\n            if (propertyKeys[i] === '*') {\n              propertyKeys.splice(i, 1, ...unnamedKeys)\n            }\n          }\n        }\n        propertyKeys\n          .filter(key => hasOwn(schema.properties, key) ||\n            hasOwn(schema, 'additionalProperties')\n          )\n          .forEach(key => controls[key] = buildFormGroupTemplate(\n            jsf, JsonPointer.get(nodeValue, [key]), setValues,\n            schemaPointer + (hasOwn(schema.properties, key) ?\n              '/properties/' + key : '/additionalProperties'\n            ),\n            dataPointer + '/' + key,\n            templatePointer + '/controls/' + key\n          ))\n        jsf.formOptions.fieldsRequired = setRequiredFields(schema, controls)\n      }\n      return {controlType, controls, validators}\n\n    case 'FormArray':\n      controls = []\n      const minItems =\n        Math.max(schema.minItems || 0, nodeOptions.get('minItems') || 0)\n      const maxItems =\n        Math.min(schema.maxItems || 1000, nodeOptions.get('maxItems') || 1000)\n      let additionalItemsPointer: string = null\n      if (isArray(schema.items)) { // 'items' is an array = tuple items\n        const tupleItems = nodeOptions.get('tupleItems') ||\n          (isArray(schema.items) ? Math.min(schema.items.length, maxItems) : 0)\n        for (let i = 0; i < tupleItems; i++) {\n          if (i < minItems) {\n            controls.push(buildFormGroupTemplate(\n              jsf, isArray(nodeValue) ? nodeValue[i] : nodeValue, setValues,\n              schemaPointer + '/items/' + i,\n              dataPointer + '/' + i,\n              templatePointer + '/controls/' + i\n            ))\n          } else {\n            const schemaRefPointer = removeRecursiveReferences(\n              schemaPointer + '/items/' + i, jsf.schemaRecursiveRefMap\n            )\n            const itemRefPointer = removeRecursiveReferences(\n              shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n            )\n            const itemRecursive = itemRefPointer !== shortDataPointer + '/' + i\n            if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n              jsf.templateRefLibrary[itemRefPointer] = null\n              jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n                jsf, null, setValues,\n                schemaRefPointer,\n                itemRefPointer,\n                templatePointer + '/controls/' + i\n              )\n            }\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaPointer + '/items/' + i,\n                  dataPointer + '/' + i,\n                  templatePointer + '/controls/' + i\n                ) :\n                itemRecursive ?\n                  null : _.cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            )\n          }\n        }\n\n        // If 'additionalItems' is an object = additional list items (after tuple items)\n        if (schema.items.length < maxItems && isObject(schema.additionalItems)) {\n          additionalItemsPointer = schemaPointer + '/additionalItems'\n        }\n\n        // If 'items' is an object = list items only (no tuple items)\n      } else {\n        additionalItemsPointer = schemaPointer + '/items'\n      }\n\n      if (additionalItemsPointer) {\n        const schemaRefPointer = removeRecursiveReferences(\n          additionalItemsPointer, jsf.schemaRecursiveRefMap\n        )\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        )\n        const itemRecursive = itemRefPointer !== shortDataPointer + '/-'\n        if (!hasOwn(jsf.templateRefLibrary, itemRefPointer)) {\n          jsf.templateRefLibrary[itemRefPointer] = null\n          jsf.templateRefLibrary[itemRefPointer] = buildFormGroupTemplate(\n            jsf, null, setValues,\n            schemaRefPointer,\n            itemRefPointer,\n            templatePointer + '/controls/-'\n          )\n        }\n        // const itemOptions = jsf.dataMap.get(itemRefPointer) || new Map();\n        const itemOptions = nodeOptions\n        if (!itemRecursive || hasOwn(validators, 'required')) {\n          const arrayLength = Math.min(Math.max(\n            itemRecursive ? 0 :\n              (itemOptions.get('tupleItems') + itemOptions.get('listItems')) || 0,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), maxItems)\n          for (let i = controls.length; i < arrayLength; i++) {\n            controls.push(\n              isArray(nodeValue) ?\n                buildFormGroupTemplate(\n                  jsf, nodeValue[i], setValues,\n                  schemaRefPointer,\n                  dataPointer + '/-',\n                  templatePointer + '/controls/-'\n                ) :\n                itemRecursive ?\n                  null : _.cloneDeep(jsf.templateRefLibrary[itemRefPointer])\n            )\n          }\n        }\n      }\n      return {controlType, controls, validators}\n\n    case '$ref':\n      const schemaRef = JsonPointer.compile(schema.$ref)\n      const dataRef = JsonPointer.toDataPointer(schemaRef, schema)\n      const refPointer = removeRecursiveReferences(\n        dataRef, jsf.dataRecursiveRefMap, jsf.arrayMap\n      )\n      if (refPointer && !hasOwn(jsf.templateRefLibrary, refPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.templateRefLibrary[refPointer] = null\n        const newTemplate = buildFormGroupTemplate(jsf, setValues, setValues, schemaRef)\n        if (newTemplate) {\n          jsf.templateRefLibrary[refPointer] = newTemplate\n        } else {\n          delete jsf.templateRefLibrary[refPointer]\n        }\n      }\n      return null\n\n    case 'FormControl':\n      const value = {\n        value: setValues && isPrimitive(nodeValue) ? nodeValue : null,\n        disabled: nodeOptions.get('disabled') || false\n      }\n      return {controlType, value, validators}\n\n    default:\n      return null\n  }\n}\n","import {\n  hasValue,\n  inArray,\n  isArray,\n  isDate,\n  isDefined,\n  isObject,\n  SchemaType,\n  toJavaScriptType,\n  toSchemaType\n} from '../validator'\nimport {JsonPointer} from '../jsonpointer.functions'\nimport {removeRecursiveReferences} from '../json-schema'\n\n/**\n * 'formatFormData' function\n *\n * @param formData - Angular FormGroup data object\n * @param dataMap -\n * @param recursiveRefMap -\n * @param arrayMap -\n * @param returnEmptyFields -\n * @param fixErrors - if TRUE, tries to fix data\n * @return formatted data object\n */\nexport function formatFormData(\n  formData: any,\n  dataMap: Map<string, any>,\n  recursiveRefMap: Map<string, string>,\n  arrayMap: Map<string, number>,\n  returnEmptyFields = false,\n  fixErrors = false\n): any {\n  if (formData === null || typeof formData !== 'object') {\n    return formData\n  }\n  const formattedData = isArray(formData) ? [] : {}\n  JsonPointer.forEachDeep(formData, (value, dataPointer) => {\n\n    // If returnEmptyFields === true,\n    // add empty arrays and objects to all allowed keys\n    if (returnEmptyFields && isArray(value)) {\n      JsonPointer.set(formattedData, dataPointer, [])\n    } else if (returnEmptyFields && isObject(value) && !isDate(value)) {\n      JsonPointer.set(formattedData, dataPointer, {})\n    } else {\n      const genericPointer =\n        JsonPointer.has(dataMap, [dataPointer, 'schemaType']) ? dataPointer :\n          removeRecursiveReferences(dataPointer, recursiveRefMap, arrayMap)\n      if (JsonPointer.has(dataMap, [genericPointer, 'schemaType'])) {\n        const schemaType: SchemaType | SchemaType[] =\n          dataMap.get(genericPointer).get('schemaType')\n        if (schemaType === 'null') {\n          JsonPointer.set(formattedData, dataPointer, null)\n        } else if ((hasValue(value) || returnEmptyFields) &&\n          inArray(schemaType, ['string', 'integer', 'number', 'boolean'])\n        ) {\n          const newValue = (fixErrors || (value === null && returnEmptyFields)) ?\n            toSchemaType(value, schemaType as any) : toJavaScriptType(value, schemaType as any)\n          if (isDefined(newValue) || returnEmptyFields) {\n            JsonPointer.set(formattedData, dataPointer, newValue)\n          }\n\n          // If returnEmptyFields === false,\n          // only add empty arrays and objects to required keys\n        } else if (schemaType === 'object' && !returnEmptyFields) {\n          (dataMap.get(genericPointer).get('required') || []).forEach(key => {\n            const keySchemaType =\n              dataMap.get(`${genericPointer}/${key}`).get('schemaType')\n            if (keySchemaType === 'array') {\n              JsonPointer.set(formattedData, `${dataPointer}/${key}`, [])\n            } else if (keySchemaType === 'object') {\n              JsonPointer.set(formattedData, `${dataPointer}/${key}`, {})\n            }\n          })\n        }\n\n        // Finish incomplete 'date-time' entries\n        if (dataMap.get(genericPointer).get('schemaFormat') === 'date-time') {\n          // \"2000-03-14T01:59:26.535\" -> \"2000-03-14T01:59:26.535Z\" (add \"Z\")\n          if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d:[0-5]\\d(?:\\.\\d+)?$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}Z`)\n            // \"2000-03-14T01:59\" -> \"2000-03-14T01:59:00Z\" (add \":00Z\")\n          } else if (/^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d[t\\s][0-2]\\d:[0-5]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00Z`)\n            // \"2000-03-14\" -> \"2000-03-14T00:00:00Z\" (add \"T00:00:00Z\")\n          } else if (fixErrors && /^\\d\\d\\d\\d-[0-1]\\d-[0-3]\\d$/i.test(value)) {\n            JsonPointer.set(formattedData, dataPointer, `${value}:00:00:00Z`)\n          }\n        }\n      } else if (typeof value !== 'object' || isDate(value) ||\n        (value === null && returnEmptyFields)\n      ) {\n        console.error('formatFormData error: ' +\n          `Schema type not found for form value at ${genericPointer}`)\n        console.error('dataMap', dataMap)\n        console.error('recursiveRefMap', recursiveRefMap)\n        console.error('genericPointer', genericPointer)\n      }\n    }\n  })\n  return formattedData\n}\n","import {JsonPointer, Pointer} from '../jsonpointer.functions'\nimport {isArray, isObject} from '../validator'\nimport {hasOwn} from '../utility'\nimport {FormGroup} from '@angular/forms'\n\n/**\n * 'getControl' function\n *\n * Uses a JSON Pointer for a data object to retrieve a control from\n * an Angular formGroup or formGroup template. (Note: though a formGroup\n * template is much simpler, its basic structure is idential to a formGroup).\n *\n * If the optional third parameter 'returnGroup' is set to TRUE, the group\n * containing the control is returned, rather than the control itself.\n *\n * @param formGroup - Angular FormGroup to get value from\n * @param dataPointer - JSON Pointer (string or array)\n * @param returnGroup - If true, return group containing control\n * @return Located value (or null, if no control found)\n */\nexport function getControl(\n  formGroup: FormGroup, dataPointer: Pointer, returnGroup = false\n) {\n  if (!isObject(formGroup) || !JsonPointer.isJsonPointer(dataPointer)) {\n    if (!JsonPointer.isJsonPointer(dataPointer)) {\n      // If dataPointer input is not a valid JSON pointer, check to\n      // see if it is instead a valid object path, using dot notaion\n      if (typeof dataPointer === 'string') {\n        const formControl = formGroup.get(dataPointer)\n        if (formControl) {\n          return formControl\n        }\n      }\n      console.error(`getControl error: Invalid JSON Pointer: ${dataPointer}`)\n    }\n    if (!isObject(formGroup)) {\n      console.error(`getControl error: Invalid formGroup: ${formGroup}`)\n    }\n    return null\n  }\n  let dataPointerArray = JsonPointer.parse(dataPointer)\n  if (returnGroup) {\n    dataPointerArray = dataPointerArray.slice(0, -1)\n  }\n\n  // If formGroup input is a real formGroup (not a formGroup template)\n  // try using formGroup.get() to return the control\n  if (typeof formGroup.get === 'function' &&\n    dataPointerArray.every(key => key.indexOf('.') === -1)\n  ) {\n    const formControl = formGroup.get(dataPointerArray.join('.'))\n    if (formControl) {\n      return formControl\n    }\n  }\n\n  // If formGroup input is a formGroup template,\n  // or formGroup.get() failed to return the control,\n  // search the formGroup object for dataPointer's control\n  let subGroup: any = formGroup\n  for (const key of dataPointerArray) {\n    if (hasOwn(subGroup, 'controls')) {\n      subGroup = subGroup.controls\n    }\n    if (isArray(subGroup) && (key === '-')) {\n      subGroup = subGroup[subGroup.length - 1]\n    } else if (hasOwn(subGroup, key)) {\n      subGroup = subGroup[key]\n    } else {\n      console.error(`getControl error: Unable to find \"${key}\" item in FormGroup.`)\n      console.error(dataPointer)\n      console.error(formGroup)\n      return\n    }\n  }\n  return subGroup\n}\n","import {isArray, isEmpty, isObject} from '../validator'\n\n/**\n * 'mergeValues' function\n *\n * @param  valuesToMerge - Multiple values to merge\n * @return Merged values\n */\nexport function mergeValues(...valuesToMerge: any[]) {\n  let mergedValues: any = null\n  for (const currentValue of valuesToMerge) {\n    if (!isEmpty(currentValue)) {\n      if (typeof currentValue === 'object' &&\n        (isEmpty(mergedValues) || typeof mergedValues !== 'object')\n      ) {\n        if (isArray(currentValue)) {\n          mergedValues = [...currentValue]\n        } else if (isObject(currentValue)) {\n          mergedValues = {...currentValue}\n        }\n      } else if (typeof currentValue !== 'object') {\n        mergedValues = currentValue\n      } else if (isObject(mergedValues) && isObject(currentValue)) {\n        Object.assign(mergedValues, currentValue)\n      } else if (isObject(mergedValues) && isArray(currentValue)) {\n        const newValues = []\n        for (const value of currentValue) {\n          newValues.push(mergeValues(mergedValues, value))\n        }\n        mergedValues = newValues\n      } else if (isArray(mergedValues) && isObject(currentValue)) {\n        const newValues = []\n        for (const value of mergedValues) {\n          newValues.push(mergeValues(value, currentValue))\n        }\n        mergedValues = newValues\n      } else if (isArray(mergedValues) && isArray(currentValue)) {\n        const newValues = []\n        for (let i = 0; i < Math.max(mergedValues.length, currentValue.length); i++) {\n          if (i < mergedValues.length && i < currentValue.length) {\n            newValues.push(mergeValues(mergedValues[i], currentValue[i]))\n          } else if (i < mergedValues.length) {\n            newValues.push(mergedValues[i])\n          } else if (i < currentValue.length) {\n            newValues.push(currentValue[i])\n          }\n        }\n        mergedValues = newValues\n      }\n    }\n  }\n  return mergedValues\n}\n","import {JsonPointer} from '../jsonpointer.functions'\nimport {fixTitle, hasOwn} from '../utility'\nimport {getInputType, isInputRequired, removeRecursiveReferences, updateInputOptions} from '../json-schema'\nimport {isArray, isDefined, isEmpty, isNumber, isObject} from '../validator'\nimport * as _ from 'lodash'\n/**\n * 'getLayoutNode' function\n * Copy a new layoutNode from layoutRefLibrary\n */\nexport function getLayoutNode(\n  refNode: any,\n  jsf: any,\n  widgetLibrary: any = null,\n  nodeValue: any = null\n) {\n\n  // If recursive reference and building initial layout, return Add button\n  if (refNode.recursiveReference && widgetLibrary) {\n    const newLayoutNode = _.cloneDeep(refNode)\n    if (!newLayoutNode.options) {\n      newLayoutNode.options = {}\n    }\n    Object.assign(newLayoutNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n    })\n    Object.assign(newLayoutNode.options, {\n      removable: false,\n      title: 'Add ' + newLayoutNode.$ref,\n    })\n    return newLayoutNode\n\n    // Otherwise, return referenced layout\n  } else {\n    let newLayoutNode = jsf.layoutRefLibrary[refNode.$ref]\n    // If value defined, build new node from schema (to set array lengths)\n    if (isDefined(nodeValue)) {\n      newLayoutNode = buildLayoutFromSchema(\n        jsf, widgetLibrary, nodeValue,\n        JsonPointer.toSchemaPointer(refNode.$ref, jsf.schema) as any,\n        refNode.$ref, newLayoutNode.arrayItem,\n        newLayoutNode.arrayItemType, newLayoutNode.options.removable, false\n      )\n    } else {\n      // If value not defined, copy node from layoutRefLibrary\n      newLayoutNode = _.cloneDeep(newLayoutNode)\n      JsonPointer.forEachDeep(newLayoutNode, (subNode, pointer) => {\n\n        // Reset all _id's in newLayoutNode to unique values\n        if (hasOwn(subNode, '_id')) {\n          subNode._id = _.uniqueId()\n        }\n\n        // If adding a recursive item, prefix current dataPointer\n        // to all dataPointers in new layoutNode\n        if (refNode.recursiveReference && hasOwn(subNode, 'dataPointer')) {\n          subNode.dataPointer = refNode.dataPointer + subNode.dataPointer\n        }\n      })\n    }\n    return newLayoutNode\n  }\n}\n/**\n * 'buildLayoutFromSchema' function\n */\nexport function buildLayoutFromSchema(\n  jsf: any,\n  widgetLibrary: any,\n  nodeValue: any = null,\n  schemaPointer: string = '',\n  dataPointer: string = '',\n  arrayItem: boolean = false,\n  arrayItemType: string = null,\n  removable: boolean = null,\n  forRefLibrary: boolean = false,\n  dataPointerPrefix: string = ''\n) {\n  const schema = JsonPointer.get(jsf.schema, schemaPointer)\n  if (!hasOwn(schema, 'type') && !hasOwn(schema, '$ref') &&\n    !hasOwn(schema, 'x-schema-form')\n  ) {\n    return null\n  }\n  const newNodeType: string = getInputType(schema)\n  if (!isDefined(nodeValue) && (\n    jsf.formOptions.setSchemaDefaults === true ||\n    (jsf.formOptions.setSchemaDefaults === 'auto' && isEmpty(jsf.formValues))\n  )) {\n    nodeValue = JsonPointer.get(jsf.schema, schemaPointer + '/default')\n  }\n  let newNode: any = {\n    _id: forRefLibrary ? null : _.uniqueId(),\n    arrayItem,\n    dataPointer: JsonPointer.toGenericPointer(dataPointer, jsf.arrayMap),\n    dataType: schema.type || (hasOwn(schema, '$ref') ? '$ref' : null),\n    options: {},\n    required: isInputRequired(jsf.schema, schemaPointer),\n    type: newNodeType,\n    widget: widgetLibrary.getWidget(newNodeType),\n  }\n  const lastDataKey = JsonPointer.toKey(newNode.dataPointer)\n  if (lastDataKey !== '-') {\n    newNode.name = lastDataKey\n  }\n  if (newNode.arrayItem) {\n    newNode.arrayItemType = arrayItemType\n    newNode.options.removable = removable !== false\n  }\n  const shortDataPointer = removeRecursiveReferences(\n    dataPointerPrefix + dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n  )\n  const recursive = !shortDataPointer.length ||\n    shortDataPointer !== dataPointerPrefix + dataPointer\n  if (!jsf.dataMap.has(shortDataPointer)) {\n    jsf.dataMap.set(shortDataPointer, new Map())\n  }\n  const nodeDataMap = jsf.dataMap.get(shortDataPointer)\n  if (!nodeDataMap.has('inputType')) {\n    nodeDataMap.set('schemaPointer', schemaPointer)\n    nodeDataMap.set('inputType', newNode.type)\n    nodeDataMap.set('widget', newNode.widget)\n    nodeDataMap.set('disabled', !!newNode.options.disabled)\n  }\n  updateInputOptions(newNode, schema, jsf)\n  if (!newNode.options.title && newNode.name && !/^\\d+$/.test(newNode.name)) {\n    newNode.options.title = fixTitle(newNode.name)\n  }\n\n  if (newNode.dataType === 'object') {\n    if (isArray(schema.required) && !nodeDataMap.has('required')) {\n      nodeDataMap.set('required', schema.required)\n    }\n    if (isObject(schema.properties)) {\n      const newSection: any[] = []\n      const propertyKeys = schema['ui:order'] || Object.keys(schema.properties)\n      if (propertyKeys.includes('*') && !hasOwn(schema.properties, '*')) {\n        const unnamedKeys = Object.keys(schema.properties)\n          .filter(key => !propertyKeys.includes(key))\n        for (let i = propertyKeys.length - 1; i >= 0; i--) {\n          if (propertyKeys[i] === '*') {\n            propertyKeys.splice(i, 1, ...unnamedKeys)\n          }\n        }\n      }\n      propertyKeys\n        .filter(key => hasOwn(schema.properties, key) ||\n          hasOwn(schema, 'additionalProperties')\n        )\n        .forEach(key => {\n          const keySchemaPointer = hasOwn(schema.properties, key) ?\n            '/properties/' + key : '/additionalProperties'\n          const innerItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isObject(nodeValue) ? nodeValue[key] : null,\n            schemaPointer + keySchemaPointer,\n            dataPointer + '/' + key,\n            false, null, null, forRefLibrary, dataPointerPrefix\n          )\n          if (innerItem) {\n            if (isInputRequired(schema, '/' + key)) {\n              innerItem.options.required = true\n              jsf.fieldsRequired = true\n            }\n            newSection.push(innerItem)\n          }\n        })\n      if (dataPointer === '' && !forRefLibrary) {\n        newNode = newSection\n      } else {\n        newNode.items = newSection\n      }\n    }\n    // TODO: Add patternProperties and additionalProperties inputs?\n    // ... possibly provide a way to enter both key names and values?\n    // if (isObject(schema.patternProperties)) { }\n    // if (isObject(schema.additionalProperties)) { }\n\n  } else if (newNode.dataType === 'array') {\n    newNode.items = []\n    const templateArray: any[] = []\n    newNode.options.maxItems = Math.min(\n      schema.maxItems || 1000, newNode.options.maxItems || 1000\n    )\n    newNode.options.minItems = Math.max(\n      schema.minItems || 0, newNode.options.minItems || 0\n    )\n    if (!newNode.options.minItems && isInputRequired(jsf.schema, schemaPointer)) {\n      newNode.options.minItems = 1\n    }\n    if (!hasOwn(newNode.options, 'listItems')) {\n      newNode.options.listItems = 1\n    }\n    newNode.options.tupleItems = isArray(schema.items) ? schema.items.length : 0\n    if (newNode.options.maxItems <= newNode.options.tupleItems) {\n      newNode.options.tupleItems = newNode.options.maxItems\n      newNode.options.listItems = 0\n    } else if (newNode.options.maxItems <\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.maxItems - newNode.options.tupleItems\n    } else if (newNode.options.minItems >\n      newNode.options.tupleItems + newNode.options.listItems\n    ) {\n      newNode.options.listItems = newNode.options.minItems - newNode.options.tupleItems\n    }\n    if (!nodeDataMap.has('maxItems')) {\n      nodeDataMap.set('maxItems', newNode.options.maxItems)\n      nodeDataMap.set('minItems', newNode.options.minItems)\n      nodeDataMap.set('tupleItems', newNode.options.tupleItems)\n      nodeDataMap.set('listItems', newNode.options.listItems)\n    }\n    if (!jsf.arrayMap.has(shortDataPointer)) {\n      jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems)\n    }\n    removable = newNode.options.removable !== false\n    let additionalItemsSchemaPointer: string = null\n\n    // If 'items' is an array = tuple items\n    if (isArray(schema.items)) {\n      newNode.items = []\n      for (let i = 0; i < newNode.options.tupleItems; i++) {\n        let newItem: any\n        const itemRefPointer = removeRecursiveReferences(\n          shortDataPointer + '/' + i, jsf.dataRecursiveRefMap, jsf.arrayMap\n        )\n        const itemRecursive = !itemRefPointer.length ||\n          itemRefPointer !== shortDataPointer + '/' + i\n\n        // If removable, add tuple item layout to layoutRefLibrary\n        if (removable && i >= newNode.options.minItems) {\n          if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n            // Set to null first to prevent recursive reference from causing endless loop\n            jsf.layoutRefLibrary[itemRefPointer] = null\n            jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n              jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n              schemaPointer + '/items/' + i,\n              itemRecursive ? '' : dataPointer + '/' + i,\n              true, 'tuple', true, true, itemRecursive ? dataPointer + '/' + i : ''\n            )\n            if (itemRecursive) {\n              jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true\n            }\n          }\n          newItem = getLayoutNode({\n            $ref: itemRefPointer,\n            dataPointer: dataPointer + '/' + i,\n            recursiveReference: itemRecursive,\n          }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null)\n        } else {\n          newItem = buildLayoutFromSchema(\n            jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null,\n            schemaPointer + '/items/' + i,\n            dataPointer + '/' + i,\n            true, 'tuple', false, forRefLibrary, dataPointerPrefix\n          )\n        }\n        if (newItem) {\n          newNode.items.push(newItem)\n        }\n      }\n\n      // If 'additionalItems' is an object = additional list items, after tuple items\n      if (isObject(schema.additionalItems)) {\n        additionalItemsSchemaPointer = schemaPointer + '/additionalItems'\n      }\n\n      // If 'items' is an object = list items only (no tuple items)\n    } else if (isObject(schema.items)) {\n      additionalItemsSchemaPointer = schemaPointer + '/items'\n    }\n\n    if (additionalItemsSchemaPointer) {\n      const itemRefPointer = removeRecursiveReferences(\n        shortDataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n      )\n      const itemRecursive = !itemRefPointer.length ||\n        itemRefPointer !== shortDataPointer + '/-'\n      const itemSchemaPointer = removeRecursiveReferences(\n        additionalItemsSchemaPointer, jsf.schemaRecursiveRefMap, jsf.arrayMap\n      )\n      // Add list item layout to layoutRefLibrary\n      if (itemRefPointer.length && !hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[itemRefPointer] = null\n        jsf.layoutRefLibrary[itemRefPointer] = buildLayoutFromSchema(\n          jsf, widgetLibrary, null,\n          itemSchemaPointer,\n          itemRecursive ? '' : dataPointer + '/-',\n          true, 'list', removable, true, itemRecursive ? dataPointer + '/-' : ''\n        )\n        if (itemRecursive) {\n          jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true\n        }\n      }\n\n      // Add any additional default items\n      if (!itemRecursive || newNode.options.required) {\n        const arrayLength = Math.min(Math.max(\n          itemRecursive ? 0 :\n            newNode.options.tupleItems + newNode.options.listItems,\n          isArray(nodeValue) ? nodeValue.length : 0\n        ), newNode.options.maxItems)\n        if (newNode.items.length < arrayLength) {\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: dataPointer + '/-',\n              recursiveReference: itemRecursive,\n            }, jsf, widgetLibrary, isArray(nodeValue) ? nodeValue[i] : null))\n          }\n        }\n      }\n\n      // If needed, add button to add items to array\n      if (newNode.options.addable !== false &&\n        newNode.options.minItems < newNode.options.maxItems &&\n        (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n      ) {\n        let buttonText =\n          ((jsf.layoutRefLibrary[itemRefPointer] || {}).options || {}).title\n        const prefix = buttonText ? 'Add ' : 'Add to '\n        if (!buttonText) {\n          buttonText = schema.title || fixTitle(JsonPointer.toKey(dataPointer))\n        }\n        if (!/^add\\b/i.test(buttonText)) {\n          buttonText = prefix + buttonText\n        }\n        newNode.items.push({\n          _id: _.uniqueId(),\n          arrayItem: true,\n          arrayItemType: 'list',\n          dataPointer: newNode.dataPointer + '/-',\n          options: {\n            listItems: newNode.options.listItems,\n            maxItems: newNode.options.maxItems,\n            minItems: newNode.options.minItems,\n            removable: false,\n            title: buttonText,\n            tupleItems: newNode.options.tupleItems,\n          },\n          recursiveReference: itemRecursive,\n          type: '$ref',\n          widget: widgetLibrary.getWidget('$ref'),\n          $ref: itemRefPointer,\n        })\n      }\n    }\n\n  } else if (newNode.dataType === '$ref') {\n    const schemaRef = JsonPointer.compile(schema.$ref)\n    const dataRef = JsonPointer.toDataPointer(schemaRef, jsf.schema) as any\n    let buttonText = ''\n\n    // Get newNode title\n    if (newNode.options.add) {\n      buttonText = newNode.options.add\n    } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n      buttonText =\n        (/^add\\b/i.test(newNode.name) ? '' : 'Add ') + fixTitle(newNode.name)\n\n      // If newNode doesn't have a title, look for title of parent array item\n    } else {\n      const parentSchema =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1)\n      if (hasOwn(parentSchema, 'title')) {\n        buttonText = 'Add to ' + parentSchema.title\n      } else {\n        const pointerArray = JsonPointer.parse(newNode.dataPointer)\n        buttonText = 'Add to ' + fixTitle(pointerArray[pointerArray.length - 2])\n      }\n    }\n    Object.assign(newNode, {\n      recursiveReference: true,\n      widget: widgetLibrary.getWidget('$ref'),\n      $ref: dataRef,\n    })\n    Object.assign(newNode.options, {\n      removable: false,\n      title: buttonText,\n    })\n    if (isNumber(JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems)) {\n      newNode.options.maxItems =\n        JsonPointer.get(jsf.schema, schemaPointer, 0, -1).maxItems\n    }\n\n    // Add layout template to layoutRefLibrary\n    if (dataRef.length) {\n      if (!hasOwn(jsf.layoutRefLibrary, dataRef)) {\n        // Set to null first to prevent recursive reference from causing endless loop\n        jsf.layoutRefLibrary[dataRef] = null\n        const newLayout = buildLayoutFromSchema(\n          jsf, widgetLibrary, null, schemaRef, '',\n          newNode.arrayItem, newNode.arrayItemType, true, true, dataPointer\n        )\n        if (newLayout) {\n          newLayout.recursiveReference = true\n          jsf.layoutRefLibrary[dataRef] = newLayout\n        } else {\n          delete jsf.layoutRefLibrary[dataRef]\n        }\n      } else if (!jsf.layoutRefLibrary[dataRef].recursiveReference) {\n        jsf.layoutRefLibrary[dataRef].recursiveReference = true\n      }\n    }\n  }\n  return newNode\n}\n","import {copy, forEach, hasOwn} from '../utility'\nimport {isArray, isDefined, isObject} from '../validator'\n\n/**\n * 'mapLayout' function\n *\n * Creates a new layout by running each element in an existing layout through\n * an iteratee. Recursively maps within array elements 'items' and 'tabs'.\n * The iteratee is invoked with four arguments: (value, index, layout, path)\n *\n * The returned layout may be longer (or shorter) then the source layout.\n *\n * If an item from the source layout returns multiple items (as '*' usually will),\n * this function will keep all returned items in-line with the surrounding items.\n *\n * If an item from the source layout causes an error and returns null, it is\n * skipped without error, and the function will still return all non-null items.\n *\n * @param layout - the layout to map\n * @param fn - the function to invoke on each element\n * @param layoutPointer - the layoutPointer to layout, inside rootLayout\n * @param rootLayout - the root layout, which contains layout\n */\nexport function mapLayout(\n  layout: any[],\n  fn: (v: any, i?: number, l?: any, p?: string) => any,\n  layoutPointer: string|string[] = '',\n  rootLayout: any = layout\n): any[] {\n  let indexPad = 0\n  let newLayout: any[] = []\n  forEach(layout, (item, index) => {\n    const realIndex = +index + indexPad\n    const newLayoutPointer = layoutPointer + '/' + realIndex\n    let newNode: any = copy(item)\n    let itemsArray: any[] = []\n    if (isObject(item)) {\n      if (hasOwn(item, 'tabs')) {\n        item.items = item.tabs\n        delete item.tabs\n      }\n      if (hasOwn(item, 'items')) {\n        itemsArray = isArray(item.items) ? item.items : [item.items]\n      }\n    }\n    if (itemsArray.length) {\n      newNode.items = mapLayout(itemsArray, fn, newLayoutPointer + '/items', rootLayout)\n    }\n    newNode = fn(newNode, realIndex, newLayoutPointer, rootLayout)\n    if (!isDefined(newNode)) {\n      indexPad--\n    } else {\n      if (isArray(newNode)) {\n        indexPad += newNode.length - 1\n      }\n      newLayout = newLayout.concat(newNode)\n    }\n  })\n  return newLayout\n}\n","import {JsonPointer} from '../jsonpointer.functions'\nimport {inArray, isArray, isEmpty, isObject, isString} from '../validator'\nimport {fixTitle, forEach, hasOwn} from '../utility'\nimport {\n  checkInlineType,\n  getFromSchema,\n  getInputType,\n  isInputRequired,\n  removeRecursiveReferences,\n  updateInputOptions\n} from '../json-schema'\nimport {buildLayoutFromSchema, getLayoutNode} from './buildLayoutFromSchema'\nimport {mapLayout} from './mapLayout'\nimport * as _ from 'lodash'\n\n/**\n * 'buildLayout' function\n */\nexport function buildLayout(jsf: any, widgetLibrary: any): any[] {\n  let hasSubmitButton = !JsonPointer.get(jsf, '/formOptions/addSubmit')\n  const formLayout = mapLayout(jsf.layout, (layoutItem, index, layoutPointer) => {\n    const currentIndex = index\n    const newNode: any = {\n      _id: _.uniqueId(),\n      options: {},\n    }\n    if (isObject(layoutItem)) {\n      Object.assign(newNode, layoutItem)\n      Object.keys(newNode)\n        .filter(option => !inArray(option, [\n          '_id', '$ref', 'arrayItem', 'arrayItemType', 'dataPointer', 'dataType',\n          'items', 'key', 'name', 'options', 'recursiveReference', 'type', 'widget'\n        ]))\n        .forEach(option => {\n          newNode.options[option] = newNode[option]\n          delete newNode[option]\n        })\n      if (!hasOwn(newNode, 'type') && isString(newNode.widget)) {\n        newNode.type = newNode.widget\n        delete newNode.widget\n      }\n      if (!hasOwn(newNode.options, 'title')) {\n        if (hasOwn(newNode.options, 'legend')) {\n          newNode.options.title = newNode.options.legend\n          delete newNode.options.legend\n        }\n      }\n      if (!hasOwn(newNode.options, 'validationMessages')) {\n        if (hasOwn(newNode.options, 'errorMessages')) {\n          newNode.options.validationMessages = newNode.options.errorMessages\n          delete newNode.options.errorMessages\n\n          // Convert Angular Schema Form (AngularJS) 'validationMessage' to\n          // Angular JSON Schema Form 'validationMessages'\n          // TV4 codes from https://github.com/geraintluff/tv4/blob/master/source/api.js\n        } else if (hasOwn(newNode.options, 'validationMessage')) {\n          if (typeof newNode.options.validationMessage === 'string') {\n            newNode.options.validationMessages = newNode.options.validationMessage\n          } else {\n            newNode.options.validationMessages = {}\n            Object.keys(newNode.options.validationMessage).forEach(key => {\n              const code = key + ''\n              const newKey =\n                code === '0' ? 'type' :\n                  code === '1' ? 'enum' :\n                    code === '100' ? 'multipleOf' :\n                      code === '101' ? 'minimum' :\n                        code === '102' ? 'exclusiveMinimum' :\n                          code === '103' ? 'maximum' :\n                            code === '104' ? 'exclusiveMaximum' :\n                              code === '200' ? 'minLength' :\n                                code === '201' ? 'maxLength' :\n                                  code === '202' ? 'pattern' :\n                                    code === '300' ? 'minProperties' :\n                                      code === '301' ? 'maxProperties' :\n                                        code === '302' ? 'required' :\n                                          code === '304' ? 'dependencies' :\n                                            code === '400' ? 'minItems' :\n                                              code === '401' ? 'maxItems' :\n                                                code === '402' ? 'uniqueItems' :\n                                                  code === '500' ? 'format' : code + ''\n              newNode.options.validationMessages[newKey] = newNode.options.validationMessage[key]\n            })\n          }\n          delete newNode.options.validationMessage\n        }\n      }\n    } else if (JsonPointer.isJsonPointer(layoutItem)) {\n      newNode.dataPointer = layoutItem\n    } else if (isString(layoutItem)) {\n      newNode.key = layoutItem\n    } else {\n      console.error('buildLayout error: Form layout element not recognized:')\n      console.error(layoutItem)\n      return null\n    }\n    let nodeSchema: any = null\n\n    // If newNode does not have a dataPointer, try to find an equivalent\n    if (!hasOwn(newNode, 'dataPointer')) {\n\n      // If newNode has a key, change it to a dataPointer\n      if (hasOwn(newNode, 'key')) {\n        newNode.dataPointer = newNode.key === '*' ? newNode.key :\n          JsonPointer.compile(JsonPointer.parseObjectPath(newNode.key), '-')\n        delete newNode.key\n\n        // If newNode is an array, search for dataPointer in child nodes\n      } else if (hasOwn(newNode, 'type') && newNode.type.slice(-5) === 'array') {\n        const findDataPointer = (items) => {\n          if (items === null || typeof items !== 'object') {\n            return\n          }\n          if (hasOwn(items, 'dataPointer')) {\n            return items.dataPointer\n          }\n          if (isArray(items.items)) {\n            for (const item of items.items) {\n              if (hasOwn(item, 'dataPointer') && item.dataPointer.indexOf('/-') !== -1) {\n                return item.dataPointer\n              }\n              if (hasOwn(item, 'items')) {\n                const searchItem = findDataPointer(item)\n                if (searchItem) {\n                  return searchItem\n                }\n              }\n            }\n          }\n        }\n        const childDataPointer = findDataPointer(newNode)\n        if (childDataPointer) {\n          newNode.dataPointer =\n            childDataPointer.slice(0, childDataPointer.lastIndexOf('/-'))\n        }\n      }\n    }\n\n    if (hasOwn(newNode, 'dataPointer')) {\n      if (newNode.dataPointer === '*') {\n        return buildLayoutFromSchema(jsf, widgetLibrary, jsf.formValues)\n      }\n      const nodeValue =\n        JsonPointer.get(jsf.formValues, newNode.dataPointer.replace(/\\/-/g, '/1'))\n\n      // TODO: Create function getFormValues(jsf, dataPointer, forRefLibrary)\n      // check formOptions.setSchemaDefaults and formOptions.setLayoutDefaults\n      // then set apropriate values from initialVaues, schema, or layout\n\n      newNode.dataPointer =\n        JsonPointer.toGenericPointer(newNode.dataPointer, jsf.arrayMap)\n      const LastKey = JsonPointer.toKey(newNode.dataPointer)\n      if (!newNode.name && isString(LastKey) && LastKey !== '-') {\n        newNode.name = LastKey\n      }\n      const shortDataPointer = removeRecursiveReferences(\n        newNode.dataPointer, jsf.dataRecursiveRefMap, jsf.arrayMap\n      )\n      const recursive = !shortDataPointer.length ||\n        shortDataPointer !== newNode.dataPointer\n      let schemaPointer: string\n      if (!jsf.dataMap.has(shortDataPointer)) {\n        jsf.dataMap.set(shortDataPointer, new Map())\n      }\n      const nodeDataMap = jsf.dataMap.get(shortDataPointer)\n      if (nodeDataMap.has('schemaPointer')) {\n        schemaPointer = nodeDataMap.get('schemaPointer')\n      } else {\n        schemaPointer = JsonPointer.toSchemaPointer(shortDataPointer, jsf.schema) as any\n        nodeDataMap.set('schemaPointer', schemaPointer)\n      }\n      nodeDataMap.set('disabled', !!newNode.options.disabled)\n      nodeSchema = JsonPointer.get(jsf.schema, schemaPointer)\n      if (nodeSchema) {\n        if (!hasOwn(newNode, 'type')) {\n          newNode.type = getInputType(nodeSchema, newNode)\n        } else if (!widgetLibrary.hasWidget(newNode.type)) {\n          const oldWidgetType = newNode.type\n          newNode.type = getInputType(nodeSchema, newNode)\n          console.error(`error: widget type \"${oldWidgetType}\" ` +\n            `not found in library. Replacing with \"${newNode.type}\".`)\n        } else {\n          newNode.type = checkInlineType(newNode.type, nodeSchema, newNode)\n        }\n        if (nodeSchema.type === 'object' && isArray(nodeSchema.required)) {\n          nodeDataMap.set('required', nodeSchema.required)\n        }\n        newNode.dataType =\n          nodeSchema.type || (hasOwn(nodeSchema, '$ref') ? '$ref' : null)\n        updateInputOptions(newNode, nodeSchema, jsf)\n\n        // Present checkboxes as single control, rather than array\n        if (newNode.type === 'checkboxes' && hasOwn(nodeSchema, 'items')) {\n          updateInputOptions(newNode, nodeSchema.items, jsf)\n        } else if (newNode.dataType === 'array') {\n          newNode.options.maxItems = Math.min(\n            nodeSchema.maxItems || 1000, newNode.options.maxItems || 1000\n          )\n          newNode.options.minItems = Math.max(\n            nodeSchema.minItems || 0, newNode.options.minItems || 0\n          )\n          newNode.options.listItems = Math.max(\n            newNode.options.listItems || 0, isArray(nodeValue) ? nodeValue.length : 0\n          )\n          newNode.options.tupleItems =\n            isArray(nodeSchema.items) ? nodeSchema.items.length : 0\n          if (newNode.options.maxItems < newNode.options.tupleItems) {\n            newNode.options.tupleItems = newNode.options.maxItems\n            newNode.options.listItems = 0\n          } else if (newNode.options.maxItems <\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.maxItems - newNode.options.tupleItems\n          } else if (newNode.options.minItems >\n            newNode.options.tupleItems + newNode.options.listItems\n          ) {\n            newNode.options.listItems =\n              newNode.options.minItems - newNode.options.tupleItems\n          }\n          if (!nodeDataMap.has('maxItems')) {\n            nodeDataMap.set('maxItems', newNode.options.maxItems)\n            nodeDataMap.set('minItems', newNode.options.minItems)\n            nodeDataMap.set('tupleItems', newNode.options.tupleItems)\n            nodeDataMap.set('listItems', newNode.options.listItems)\n          }\n          if (!jsf.arrayMap.has(shortDataPointer)) {\n            jsf.arrayMap.set(shortDataPointer, newNode.options.tupleItems)\n          }\n        }\n        if (isInputRequired(jsf.schema, schemaPointer)) {\n          newNode.options.required = true\n          jsf.fieldsRequired = true\n        }\n      } else {\n        // TODO: create item in FormGroup model from layout key (?)\n        updateInputOptions(newNode, {}, jsf)\n      }\n\n      if (!newNode.options.title && !/^\\d+$/.test(newNode.name)) {\n        newNode.options.title = fixTitle(newNode.name)\n      }\n\n      if (hasOwn(newNode.options, 'copyValueTo')) {\n        if (typeof newNode.options.copyValueTo === 'string') {\n          newNode.options.copyValueTo = [newNode.options.copyValueTo]\n        }\n        if (isArray(newNode.options.copyValueTo)) {\n          newNode.options.copyValueTo = newNode.options.copyValueTo.map(item =>\n            JsonPointer.compile(JsonPointer.parseObjectPath(item), '-')\n          )\n        }\n      }\n\n      newNode.widget = widgetLibrary.getWidget(newNode.type)\n      nodeDataMap.set('inputType', newNode.type)\n      nodeDataMap.set('widget', newNode.widget)\n\n      if (newNode.dataType === 'array' &&\n        (hasOwn(newNode, 'items') || hasOwn(newNode, 'additionalItems'))\n      ) {\n        const itemRefPointer = removeRecursiveReferences(\n          newNode.dataPointer + '/-', jsf.dataRecursiveRefMap, jsf.arrayMap\n        )\n        if (!jsf.dataMap.has(itemRefPointer)) {\n          jsf.dataMap.set(itemRefPointer, new Map())\n        }\n        jsf.dataMap.get(itemRefPointer).set('inputType', 'section')\n\n        // Fix insufficiently nested array item groups\n        if (newNode.items.length > 1) {\n          const arrayItemGroup = []\n          const arrayItemGroupTemplate = []\n          let newIndex = 0\n          for (let i = newNode.items.length - 1; i >= 0; i--) {\n            const subItem = newNode.items[i]\n            if (hasOwn(subItem, 'dataPointer') &&\n              subItem.dataPointer.slice(0, itemRefPointer.length) === itemRefPointer\n            ) {\n              const arrayItem = newNode.items.splice(i, 1)[0]\n              arrayItem.dataPointer = newNode.dataPointer + '/-' +\n                arrayItem.dataPointer.slice(itemRefPointer.length)\n              arrayItemGroup.unshift(arrayItem)\n              newIndex++\n            } else {\n              subItem.arrayItem = true\n              // TODO: Check schema to get arrayItemType and removable\n              subItem.arrayItemType = 'list'\n              subItem.removable = newNode.options.removable !== false\n            }\n          }\n          if (arrayItemGroup.length) {\n            newNode.items.push({\n              _id: _.uniqueId(),\n              arrayItem: true,\n              arrayItemType: newNode.options.tupleItems > newNode.items.length ?\n                'tuple' : 'list',\n              items: arrayItemGroup,\n              options: {removable: newNode.options.removable !== false,},\n              dataPointer: newNode.dataPointer + '/-',\n              type: 'section',\n              widget: widgetLibrary.getWidget('section'),\n            })\n          }\n        } else {\n          // TODO: Fix to hndle multiple items\n          newNode.items[0].arrayItem = true\n          if (!newNode.items[0].dataPointer) {\n            newNode.items[0].dataPointer =\n              JsonPointer.toGenericPointer(itemRefPointer, jsf.arrayMap)\n          }\n          if (!JsonPointer.has(newNode, '/items/0/options/removable')) {\n            newNode.items[0].options.removable = true\n          }\n          if (newNode.options.orderable === false) {\n            newNode.items[0].options.orderable = false\n          }\n          newNode.items[0].arrayItemType =\n            newNode.options.tupleItems ? 'tuple' : 'list'\n        }\n\n        if (isArray(newNode.items)) {\n          const arrayListItems =\n            newNode.items.filter(item => item.type !== '$ref').length -\n            newNode.options.tupleItems\n          if (arrayListItems > newNode.options.listItems) {\n            newNode.options.listItems = arrayListItems\n            nodeDataMap.set('listItems', arrayListItems)\n          }\n        }\n\n        if (!hasOwn(jsf.layoutRefLibrary, itemRefPointer)) {\n          jsf.layoutRefLibrary[itemRefPointer] =\n            _.cloneDeep(newNode.items[newNode.items.length - 1])\n          if (recursive) {\n            jsf.layoutRefLibrary[itemRefPointer].recursiveReference = true\n          }\n          forEach(jsf.layoutRefLibrary[itemRefPointer], (item, key) => {\n            if (hasOwn(item, '_id')) {\n              item._id = null\n            }\n            if (recursive) {\n              if (hasOwn(item, 'dataPointer')) {\n                item.dataPointer = item.dataPointer.slice(itemRefPointer.length)\n              }\n            }\n          }, 'top-down')\n        }\n\n        // Add any additional default items\n        if (!newNode.recursiveReference || newNode.options.required) {\n          const arrayLength = Math.min(Math.max(\n            newNode.options.tupleItems + newNode.options.listItems,\n            isArray(nodeValue) ? nodeValue.length : 0\n          ), newNode.options.maxItems)\n          for (let i = newNode.items.length; i < arrayLength; i++) {\n            newNode.items.push(getLayoutNode({\n              $ref: itemRefPointer,\n              dataPointer: newNode.dataPointer,\n              recursiveReference: newNode.recursiveReference,\n            }, jsf, widgetLibrary))\n          }\n        }\n\n        // If needed, add button to add items to array\n        if (newNode.options.addable !== false &&\n          newNode.options.minItems < newNode.options.maxItems &&\n          (newNode.items[newNode.items.length - 1] || {}).type !== '$ref'\n        ) {\n          let buttonText = 'Add'\n          if (newNode.options.title) {\n            if (/^add\\b/i.test(newNode.options.title)) {\n              buttonText = newNode.options.title\n            } else {\n              buttonText += ' ' + newNode.options.title\n            }\n          } else if (newNode.name && !/^\\d+$/.test(newNode.name)) {\n            if (/^add\\b/i.test(newNode.name)) {\n              buttonText += ' ' + fixTitle(newNode.name)\n            } else {\n              buttonText = fixTitle(newNode.name)\n            }\n\n            // If newNode doesn't have a title, look for title of parent array item\n          } else {\n            const parentSchema =\n              getFromSchema(jsf.schema, newNode.dataPointer, 'parentSchema')\n            if (hasOwn(parentSchema, 'title')) {\n              buttonText += ' to ' + parentSchema.title\n            } else {\n              const pointerArray = JsonPointer.parse(newNode.dataPointer)\n              buttonText += ' to ' + fixTitle(pointerArray[pointerArray.length - 2])\n            }\n          }\n          newNode.items.push({\n            _id: _.uniqueId(),\n            arrayItem: true,\n            arrayItemType: 'list',\n            dataPointer: newNode.dataPointer + '/-',\n            options: {\n              listItems: newNode.options.listItems,\n              maxItems: newNode.options.maxItems,\n              minItems: newNode.options.minItems,\n              removable: false,\n              title: buttonText,\n              tupleItems: newNode.options.tupleItems,\n            },\n            recursiveReference: recursive,\n            type: '$ref',\n            widget: widgetLibrary.getWidget('$ref'),\n            $ref: itemRefPointer,\n          })\n          if (isString(JsonPointer.get(newNode, '/style/add'))) {\n            newNode.items[newNode.items.length - 1].options.fieldStyle =\n              newNode.style.add\n            delete newNode.style.add\n            if (isEmpty(newNode.style)) {\n              delete newNode.style\n            }\n          }\n        }\n      } else {\n        newNode.arrayItem = false\n      }\n    } else if (hasOwn(newNode, 'type') || hasOwn(newNode, 'items')) {\n      const parentType: string =\n        JsonPointer.get(jsf.layout, layoutPointer, 0, -2).type\n      if (!hasOwn(newNode, 'type')) {\n        newNode.type =\n          inArray(parentType, ['tabs', 'tabarray']) ? 'tab' : 'array'\n      }\n      newNode.arrayItem = parentType === 'array'\n      newNode.widget = widgetLibrary.getWidget(newNode.type)\n      updateInputOptions(newNode, {}, jsf)\n    }\n    if (newNode.type === 'submit') {\n      hasSubmitButton = true\n    }\n    return newNode\n  })\n  if (jsf.hasRootReference) {\n    const fullLayout = _.cloneDeep(formLayout)\n    if (fullLayout[fullLayout.length - 1].type === 'submit') {\n      fullLayout.pop()\n    }\n    jsf.layoutRefLibrary[''] = {\n      _id: null,\n      dataPointer: '',\n      dataType: 'object',\n      items: fullLayout,\n      name: '',\n      options: _.cloneDeep(jsf.formOptions.defautWidgetOptions),\n      recursiveReference: true,\n      required: false,\n      type: 'section',\n      widget: widgetLibrary.getWidget('section'),\n    }\n  }\n  if (!hasSubmitButton) {\n    formLayout.push({\n      _id: _.uniqueId(),\n      options: {title: 'Submit'},\n      type: 'submit',\n      widget: widgetLibrary.getWidget('submit'),\n    })\n  }\n  return formLayout\n}\n","export function ordinal(value: number | string): string {\n  if (typeof value === 'number') {\n    value = value + ''\n  }\n  const last = value.slice(-1)\n  const nextToLast = value.slice(-2, 1)\n  return (nextToLast !== '1' && {1: 'st', 2: 'nd', 3: 'rd'}[last]) || 'th'\n}\n","/**\n * 'findDate' function\n */\nexport function findDate(text): string {\n  if (!text) {\n    return null\n  }\n  let foundDate: any[]\n  // Match ...YYYY-MM-DD...\n  foundDate = text.match(/(?:19|20)\\d\\d[-_\\\\\\/\\. ](?:0?\\d|1[012])[-_\\\\\\/\\. ](?:[012]?\\d|3[01])(?!\\d)/)\n  if (foundDate) {\n    return foundDate[0]\n  }\n  // Match ...MM-DD-YYYY...\n  foundDate = text.match(/(?:[012]?\\d|3[01])[-_\\\\\\/\\. ](?:0?\\d|1[012])[-_\\\\\\/\\. ](?:19|20)\\d\\d(?!\\d)/)\n  if (foundDate) {\n    return foundDate[0]\n  }\n  // Match MM-DD-YY...\n  foundDate = text.match(/^(?:[012]?\\d|3[01])[-_\\\\\\/\\. ](?:0?\\d|1[012])[-_\\\\\\/\\. ]\\d\\d(?!\\d)/)\n  if (foundDate) {\n    return foundDate[0]\n  }\n  // Match YY-MM-DD...\n  foundDate = text.match(/^\\d\\d[-_\\\\\\/\\. ](?:[012]?\\d|3[01])[-_\\\\\\/\\. ](?:0?\\d|1[012])(?!\\d)/)\n  if (foundDate) {\n    return foundDate[0]\n  }\n  // Match YYYYMMDD...\n  foundDate = text.match(/^(?:19|20)\\d\\d(?:0\\d|1[012])(?:[012]\\d|3[01])/)\n  if (foundDate) {\n    return foundDate[0]\n  }\n}\n","import {findDate} from './findDate'\n\n/**\n * 'stringToDate' function\n */\nexport function stringToDate(dateString: string): Date {\n  const getDate: string = findDate(dateString)\n  if (!getDate) {\n    return null\n  }\n  let dateParts: number[] = []\n  // Split x-y-z to [x, y, z]\n  if (/^\\d+[^\\d]\\d+[^\\d]\\d+$/.test(getDate)) {\n    dateParts = getDate.split(/[^\\d]/).map(part => +part)\n    // Split xxxxyyzz to [xxxx, yy, zz]\n  } else if (/^\\d{8}$/.test(getDate)) {\n    dateParts = [+getDate.slice(0, 4), +getDate.slice(4, 6), +getDate.slice(6)]\n  }\n  const thisYear = +(new Date().getFullYear() + '').slice(-2)\n  // Check for [YYYY, MM, DD]\n  if (dateParts[0] > 1000 && dateParts[0] < 2100 && dateParts[1] <= 12 && dateParts[2] <= 31) {\n    return new Date(dateParts[0], dateParts[1] - 1, dateParts[2])\n    // Check for [MM, DD, YYYY]\n  } else if (dateParts[0] <= 12 && dateParts[1] <= 31 && dateParts[2] > 1000 && dateParts[2] < 2100) {\n    return new Date(dateParts[2], dateParts[0] - 1, dateParts[1])\n    // Check for [MM, DD, YY]\n  } else if (dateParts[0] <= 12 && dateParts[1] <= 31 && dateParts[2] < 100) {\n    const year = (dateParts[2] <= thisYear ? 2000 : 1900) + dateParts[2]\n    return new Date(year, dateParts[0] - 1, dateParts[1])\n    // Check for [YY, MM, DD]\n  } else if (dateParts[0] < 100 && dateParts[1] <= 12 && dateParts[2] <= 31) {\n    const year = (dateParts[0] <= thisYear ? 2000 : 1900) + dateParts[0]\n    return new Date(year, dateParts[1] - 1, dateParts[2])\n  }\n  return null\n}\n","import {ordinal} from './ordinal'\nimport {stringToDate} from './stringToDate'\n\n/**\n * 'dateToString' function\n */\nexport function dateToString(date: Date | string, options: any = {}): string {\n  const dateFormat = options.dateFormat || 'YYYY-MM-DD'\n  // TODO: Use options.locale to change default format and names\n  // const locale = options.locale || 'en-US';\n  if (typeof date === 'string') {\n    date = stringToDate(date)\n  }\n  if (Object.prototype.toString.call(date) !== '[object Date]') {\n    return null\n  }\n  const longMonths = ['January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December']\n  const shortMonths = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n  const longDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']\n  const shortDays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']\n  return dateFormat\n    .replace(/YYYY/ig, date.getFullYear() + '')\n    .replace(/YY/ig, (date.getFullYear() + '').slice(-2))\n    .replace(/MMMM/ig, longMonths[date.getMonth()])\n    .replace(/MMM/ig, shortMonths[date.getMonth()])\n    .replace(/MM/ig, ('0' + (date.getMonth() + 1)).slice(-2))\n    .replace(/M/ig, (date.getMonth() + 1) + '')\n    .replace(/DDDD/ig, longDays[date.getDay()])\n    .replace(/DDD/ig, shortDays[date.getDay()])\n    .replace(/DD/ig, ('0' + date.getDate()).slice(-2))\n    .replace(/D/ig, date.getDate() + '')\n    .replace(/S/ig, ordinal(date.getDate()))\n}\n","import {Injectable} from '@angular/core'\n\n@Injectable()\nexport class Framework {\n  name: string\n  framework: any\n  widgets?: { [key: string]: any } = {}\n  stylesheets?: string[] = []\n  scripts?: string[] = []\n}\n","export const enValidationMessages: any = { // Default English error messages\n  required: 'This field is required.',\n  minLength: 'Must be {{minimumLength}} characters or longer (current length: {{currentLength}})',\n  maxLength: 'Must be {{maximumLength}} characters or shorter (current length: {{currentLength}})',\n  pattern: 'Must match pattern: {{requiredPattern}}',\n  format(error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Must be a date, like \"2000-12-31\"'\n      case 'time':\n        return 'Must be a time, like \"16:20\" or \"03:14:15.9265\"'\n      case 'date-time':\n        return 'Must be a date-time, like \"2000-03-14T01:59\" or \"2000-03-14T01:59:26.535Z\"'\n      case 'email':\n        return 'Must be an email address, like \"name@example.com\"'\n      case 'hostname':\n        return 'Must be a hostname, like \"example.com\"'\n      case 'ipv4':\n        return 'Must be an IPv4 address, like \"127.0.0.1\"'\n      case 'ipv6':\n        return 'Must be an IPv6 address, like \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"'\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Must be a url, like \"http://www.example.com/page.html\"'\n      case 'uuid':\n        return 'Must be a uuid, like \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"'\n      case 'color':\n        return 'Must be a color, like \"#FFFFFF\" or \"rgb(255, 255, 255)\"'\n      case 'json-pointer':\n        return 'Must be a JSON Pointer, like \"/pointer/to/something\"'\n      case 'relative-json-pointer':\n        return 'Must be a relative JSON Pointer, like \"2/pointer/to/something\"'\n      case 'regex':\n        return 'Must be a regular expression, like \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"'\n      default:\n        return 'Must be a correctly formatted ' + error.requiredFormat\n    }\n  },\n  minimum: 'Must be {{minimumValue}} or more',\n  exclusiveMinimum: 'Must be more than {{exclusiveMinimumValue}}',\n  maximum: 'Must be {{maximumValue}} or less',\n  exclusiveMaximum: 'Must be less than {{exclusiveMaximumValue}}',\n  multipleOf(error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue)\n      return `Must have ${decimals} or fewer decimal places.`\n    } else {\n      return `Must be a multiple of ${error.multipleOfValue}.`\n    }\n  },\n  minProperties: 'Must have {{minimumProperties}} or more items (current items: {{currentProperties}})',\n  maxProperties: 'Must have {{maximumProperties}} or fewer items (current items: {{currentProperties}})',\n  minItems: 'Must have {{minimumItems}} or more items (current items: {{currentItems}})',\n  maxItems: 'Must have {{maximumItems}} or fewer items (current items: {{currentItems}})',\n  uniqueItems: 'All items must be unique',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n}\n","export const frValidationMessages: any = { // French error messages\n  required: 'Est obligatoire.',\n  minLength: 'Doit avoir minimum {{minimumLength}} caractères (actuellement: {{currentLength}})',\n  maxLength: 'Doit avoir maximum {{maximumLength}} caractères (actuellement: {{currentLength}})',\n  pattern: 'Doit respecter: {{requiredPattern}}',\n  format(error) {\n    switch (error.requiredFormat) {\n      case 'date':\n        return 'Doit être une date, tel que \"2000-12-31\"'\n      case 'time':\n        return 'Doit être une heure, tel que \"16:20\" ou \"03:14:15.9265\"'\n      case 'date-time':\n        return 'Doit être une date et une heure, tel que \"2000-03-14T01:59\" ou \"2000-03-14T01:59:26.535Z\"'\n      case 'email':\n        return 'Doit être une adresse e-mail, tel que \"name@example.com\"'\n      case 'hostname':\n        return 'Doit être un nom de domaine, tel que \"example.com\"'\n      case 'ipv4':\n        return 'Doit être une adresse IPv4, tel que \"127.0.0.1\"'\n      case 'ipv6':\n        return 'Doit être une adresse IPv6, tel que \"1234:5678:9ABC:DEF0:1234:5678:9ABC:DEF0\"'\n      // TODO: add examples for 'uri', 'uri-reference', and 'uri-template'\n      // case 'uri': case 'uri-reference': case 'uri-template':\n      case 'url':\n        return 'Doit être une URL, tel que \"http://www.example.com/page.html\"'\n      case 'uuid':\n        return 'Doit être un UUID, tel que \"12345678-9ABC-DEF0-1234-56789ABCDEF0\"'\n      case 'color':\n        return 'Doit être une couleur, tel que \"#FFFFFF\" or \"rgb(255, 255, 255)\"'\n      case 'json-pointer':\n        return 'Doit être un JSON Pointer, tel que \"/pointer/to/something\"'\n      case 'relative-json-pointer':\n        return 'Doit être un relative JSON Pointer, tel que \"2/pointer/to/something\"'\n      case 'regex':\n        return 'Doit être une expression régulière, tel que \"(1-)?\\\\d{3}-\\\\d{3}-\\\\d{4}\"'\n      default:\n        return 'Doit être avoir le format correct: ' + error.requiredFormat\n    }\n  },\n  minimum: 'Doit être supérieur à {{minimumValue}}',\n  exclusiveMinimum: 'Doit avoir minimum {{exclusiveMinimumValue}} charactères',\n  maximum: 'Doit être inférieur à {{maximumValue}}',\n  exclusiveMaximum: 'Doit avoir maximum {{exclusiveMaximumValue}} charactères',\n  multipleOf(error) {\n    if ((1 / error.multipleOfValue) % 10 === 0) {\n      const decimals = Math.log10(1 / error.multipleOfValue)\n      return `Doit comporter ${decimals} ou moins de decimales.`\n    } else {\n      return `Doit être un multiple de ${error.multipleOfValue}.`\n    }\n  },\n  minProperties: 'Doit comporter au minimum {{minimumProperties}} éléments',\n  maxProperties: 'Doit comporter au maximum {{maximumProperties}} éléments',\n  minItems: 'Doit comporter au minimum {{minimumItems}} éléments',\n  maxItems: 'Doit comporter au maximum {{minimumItems}} éléments',\n  uniqueItems: 'Tous les éléments doivent être uniques',\n  // Note: No default error messages for 'type', 'const', 'enum', or 'dependencies'\n}\n"],"names":["fromPromise","isObservable","Observable","__values","Injectable","isEqual","_.isEqual","map","forkJoin","_.cloneDeep","__spread","FormGroup","FormArray","_.filter","_.map","FormControl","_.uniqueId"],"mappings":"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"}